{"files":[{"path":["/","Users","cat","hydra","src","app.rs"],"content":"use std::cell::{Cell, RefCell};\nuse std::collections::HashMap;\nuse std::path::PathBuf;\nuse std::time::Instant;\n\nuse crossterm::event::{KeyCode, KeyEvent, MouseButton, MouseEvent, MouseEventKind};\nuse ratatui::layout::{Position, Rect};\n\nuse crate::logs::{GlobalStats, SessionStats};\nuse crate::session::{AgentType, Session, SessionStatus};\n\n/// Results from a background message/stats refresh task.\npub struct MessageRefreshResult {\n    pub log_uuids: HashMap<String, String>,\n    pub uuid_retry_cooldowns: HashMap<String, u8>,\n    pub last_messages: HashMap<String, String>,\n    pub session_stats: HashMap<String, SessionStats>,\n    pub global_stats: GlobalStats,\n    pub diff_files: Vec<DiffFile>,\n}\nuse crate::tmux::{SessionManager, TmuxSessionManager};\n\n#[derive(Debug, Clone, PartialEq)]\npub enum Mode {\n    Browse,\n    Attached,\n    NewSessionAgent,\n    ConfirmDelete,\n}\n\npub struct App {\n    pub sessions: Vec<Session>,\n    pub selected: usize,\n    pub preview: String,\n    /// Cached preview line count to avoid O(n) line scans every frame.\n    pub preview_line_count: u16,\n    pub mode: Mode,\n    pub agent_selection: usize,\n    pub should_quit: bool,\n    pub project_id: String,\n    /// Which session the preview is currently showing (for skip-if-unchanged optimization).\n    preview_session: Option<String>,\n    pub cwd: String,\n    pub status_message: Option<String>,\n    pub sidebar_area: Cell<Rect>,\n    pub preview_area: Cell<Rect>,\n    pub preview_scroll_offset: u16,\n    prev_captures: HashMap<String, String>,\n    /// Raw (un-normalized) pane captures for skip-normalization optimization.\n    raw_captures: HashMap<String, String>,\n    /// Consecutive ticks with unchanged pane content (for Running→Idle debounce).\n    idle_ticks: HashMap<String, u8>,\n    /// Consecutive ticks with changed pane content (for Idle→Running debounce).\n    changed_ticks: HashMap<String, u8>,\n    /// Consecutive refresh ticks where is_pane_dead() reported dead (for Exited debounce).\n    dead_ticks: HashMap<String, u8>,\n    task_starts: HashMap<String, Instant>,\n    task_last_active: HashMap<String, Instant>,\n    pub last_messages: HashMap<String, String>,\n    pub session_stats: HashMap<String, SessionStats>,\n    pub global_stats: GlobalStats,\n    /// Per-file git diff stats from `git diff --numstat`\n    pub diff_files: Vec<DiffFile>,\n    log_uuids: HashMap<String, String>,\n    /// Per-session cooldown (in refresh cycles) before retrying UUID resolution.\n    uuid_retry_cooldowns: HashMap<String, u8>,\n    /// Latest per-session pane captures from `refresh_sessions` tick.\n    /// Used by preview refresh to avoid redundant tmux calls.\n    latest_pane_captures: HashMap<String, String>,\n    message_tick: u8,\n    pub manifest_dir: PathBuf,\n    manager: Box<dyn SessionManager>,\n    /// Whether `preview` currently contains full scrollback (not just live pane).\n    preview_has_scrollback: bool,\n    /// Pending literal keys to send to tmux (tmux_name, text).\n    /// Set by `handle_mouse` for forwarding clicks; consumed by the event loop.\n    pub pending_literal_keys: Option<(String, String)>,\n    /// When false, mouse capture is disabled so the terminal handles text selection natively.\n    pub mouse_captured: bool,\n    /// Cached diff tree lines: (diff_files, width, rendered lines).\n    /// Updated lazily in draw_sidebar to avoid recomputing on every frame.\n    pub diff_tree_cache: RefCell<(Vec<DiffFile>, usize, Vec<ratatui::text::Line<'static>>)>,\n    /// Background refresh channel for async message/stats/diff updates.\n    bg_refresh_rx: Option<tokio::sync::oneshot::Receiver<MessageRefreshResult>>,\n}\n\nimpl App {\n    /// Consecutive dead ticks required before accepting Exited (~600ms at 200ms/refresh).\n    const DEAD_TICK_THRESHOLD: u8 = 3;\n    /// Extended dead tick threshold when subagents are active (~3s), allowing orchestration to settle.\n    const DEAD_TICK_SUBAGENT_THRESHOLD: u8 = 15;\n\n    pub fn new(project_id: String, cwd: String) -> Self {\n        Self::new_with_manager(project_id, cwd, Box::new(TmuxSessionManager::new()))\n    }\n\n    pub fn new_with_manager(\n        project_id: String,\n        cwd: String,\n        manager: Box<dyn SessionManager>,\n    ) -> Self {\n        Self {\n            sessions: Vec::new(),\n            selected: 0,\n            preview: String::new(),\n            preview_line_count: 0,\n            mode: Mode::Browse,\n            agent_selection: 0,\n            should_quit: false,\n            project_id,\n            cwd,\n            preview_session: None,\n            status_message: None,\n            sidebar_area: Cell::new(Rect::default()),\n            preview_area: Cell::new(Rect::default()),\n            preview_scroll_offset: 0,\n            prev_captures: HashMap::new(),\n            raw_captures: HashMap::new(),\n            idle_ticks: HashMap::new(),\n            changed_ticks: HashMap::new(),\n            dead_ticks: HashMap::new(),\n            task_starts: HashMap::new(),\n            task_last_active: HashMap::new(),\n            last_messages: HashMap::new(),\n            session_stats: HashMap::new(),\n            global_stats: GlobalStats::default(),\n            diff_files: Vec::new(),\n            log_uuids: HashMap::new(),\n            uuid_retry_cooldowns: HashMap::new(),\n            latest_pane_captures: HashMap::new(),\n            message_tick: 0,\n            manifest_dir: crate::manifest::default_base_dir(),\n            manager,\n            preview_has_scrollback: false,\n            pending_literal_keys: None,\n            mouse_captured: true,\n            diff_tree_cache: RefCell::new((Vec::new(), 0, Vec::new())),\n            bg_refresh_rx: None,\n        }\n    }\n\n    fn set_preview_content(&mut self, content: String, has_scrollback: bool) {\n        self.preview_line_count = count_lines_u16(&content);\n        self.preview = content;\n        self.preview_has_scrollback = has_scrollback;\n    }\n\n    #[cfg(test)]\n    pub fn set_preview_text(&mut self, content: String) {\n        self.preview_line_count = count_lines_u16(&content);\n        self.preview = content;\n    }\n\n    pub async fn refresh_sessions(&mut self) {\n        let pid = self.project_id.clone();\n        let result = self.manager.list_sessions(&pid).await;\n        match result {\n            Ok(mut sessions) => {\n                let now = Instant::now();\n                let prev_statuses: HashMap<String, SessionStatus> = self\n                    .sessions\n                    .iter()\n                    .map(|s| (s.tmux_name.clone(), s.status.clone()))\n                    .collect();\n\n                // Batch-capture pane content in parallel for all non-exited sessions.\n                // This turns N sequential subprocess waits into 1 parallel wait.\n                let live_names: Vec<String> = sessions\n                    .iter()\n                    .filter(|s| s.status != SessionStatus::Exited)\n                    .map(|s| s.tmux_name.clone())\n                    .collect();\n                let capture_results = self.manager.capture_panes(&live_names).await;\n                let captures: HashMap<String, String> = live_names\n                    .into_iter()\n                    .zip(capture_results)\n                    .map(|(name, res)| (name, res.unwrap_or_default()))\n                    .collect();\n\n                for session in &mut sessions {\n                    let name = session.tmux_name.clone();\n\n                    let has_active_subagents = self\n                        .session_stats\n                        .get(&name)\n                        .map(|st| st.active_subagents > 0)\n                        .unwrap_or(false);\n\n                    // Debounce Exited: require consecutive dead ticks before accepting.\n                    // A single is_pane_dead()=true (e.g. timeout during heavy I/O) should\n                    // not permanently mark a session as Exited.\n                    if session.status == SessionStatus::Exited {\n                        let count = self.dead_ticks.entry(name.clone()).or_insert(0);\n                        *count = count.saturating_add(1);\n                        let threshold = if has_active_subagents {\n                            Self::DEAD_TICK_SUBAGENT_THRESHOLD\n                        } else {\n                            Self::DEAD_TICK_THRESHOLD\n                        };\n                        if *count < threshold {\n                            // Not enough consecutive dead ticks — keep previous non-Exited status\n                            session.status = prev_statuses\n                                .get(&name)\n                                .filter(|s| **s != SessionStatus::Exited)\n                                .cloned()\n                                .unwrap_or(SessionStatus::Idle);\n                        }\n                    } else {\n                        self.dead_ticks.insert(name.clone(), 0);\n                    }\n\n                    // Carry forward previous status for hysteresis.\n                    // list_sessions() returns fresh Session objects; without this, the\n                    // default status would defeat the debounce logic.\n                    if let Some(prev_status) = prev_statuses.get(&name) {\n                        if session.status == SessionStatus::Exited {\n                            // Pane is confirmed dead (passed debounce); keep Exited\n                        } else if *prev_status == SessionStatus::Exited {\n                            // Pane was dead, now alive: clear stale caches for fresh start\n                            self.prev_captures.remove(&name);\n                            self.raw_captures.remove(&name);\n                            self.idle_ticks.remove(&name);\n                            self.changed_ticks.remove(&name);\n                            // Keep Idle from list_sessions(); content comparison will see\n                            // first_capture and immediately set Running\n                        } else {\n                            // Normal: carry forward prev status for hysteresis\n                            session.status = prev_status.clone();\n                        }\n                    }\n\n                    // Determine Running vs Idle by comparing pane content.\n                    //\n                    // Pane content is normalized (strip spinners, ANSI, trailing\n                    // whitespace) then compared against the previous tick.\n                    //\n                    // Log signal (`task_elapsed`) is used only to *accelerate*\n                    // Idle detection: when the log confirms the agent finished\n                    // (assistant replied), the idle threshold drops from 30 to 8\n                    // ticks. The log is never used to force Running — it updates\n                    // too infrequently (~5s) and stale data would keep sessions\n                    // stuck in Running after the agent finishes.\n                    //\n                    // Hysteresis thresholds (pane-based):\n                    //   Running → Idle: 30 ticks (~3s), or 8 ticks if log says idle\n                    //   Idle → Running: 5 consecutive changed ticks (~500ms)\n                    // First capture (no previous): immediately set Running.\n                    let log_idle = self\n                        .session_stats\n                        .get(&name)\n                        .map(|st| st.task_elapsed().is_none())\n                        .unwrap_or(false);\n                    let idle_threshold: u8 = if log_idle { 8 } else { 30 };\n\n                    if let Some(content) = captures.get(&name) {\n                        let raw_prev = self.raw_captures.get(&name);\n                        let first_capture = raw_prev.is_none();\n                        let raw_unchanged = !first_capture && raw_prev.unwrap() == content;\n                        self.raw_captures.insert(name.clone(), content.clone());\n\n                        // If raw content is identical, skip normalization entirely.\n                        // Only normalize when raw differs (to filter spinner noise).\n                        let (unchanged, raw_changed_but_normalized_same) = if raw_unchanged {\n                            (true, false)\n                        } else {\n                            let normalized = normalize_capture(content);\n                            let prev = self.prev_captures.get(&name);\n                            let normalized_unchanged = prev.is_some_and(|p| *p == normalized);\n                            self.prev_captures.insert(name.clone(), normalized);\n                            (normalized_unchanged, normalized_unchanged)\n                        };\n\n                        // Codex often signals active work with spinner/progress-only\n                        // updates. If raw capture changed but normalized text did not,\n                        // still count it as activity for Codex sessions.\n                        let changed = !unchanged\n                            || (session.agent_type == AgentType::Codex\n                                && raw_changed_but_normalized_same);\n\n                        if first_capture {\n                            // Brand-new session — assume Running until debounce says otherwise.\n                            session.status = SessionStatus::Running;\n                        } else if !changed {\n                            let count = self.idle_ticks.entry(name.clone()).or_insert(0);\n                            *count = count.saturating_add(1);\n                            self.changed_ticks.insert(name.clone(), 0);\n\n                            if has_active_subagents {\n                                session.status = SessionStatus::Running;\n                            } else if *count >= idle_threshold {\n                                session.status = SessionStatus::Idle;\n                            }\n                            // else: keep current status (hysteresis)\n                        } else {\n                            let count = self.changed_ticks.entry(name.clone()).or_insert(0);\n                            *count = count.saturating_add(1);\n                            self.idle_ticks.insert(name.clone(), 0);\n\n                            if *count >= 5 {\n                                session.status = SessionStatus::Running;\n                            }\n                            // else: keep current status (don't flip to Running on a single blip)\n                        }\n                    }\n\n                    // Track task elapsed time.\n                    // Prefer log-derived timestamps (survives Hydra restarts),\n                    // fall back to in-memory Instant tracking for responsiveness.\n                    let log_elapsed = self\n                        .session_stats\n                        .get(&name)\n                        .and_then(|st| st.task_elapsed());\n\n                    match session.status {\n                        SessionStatus::Running => {\n                            self.task_starts.entry(name.clone()).or_insert(now);\n                            self.task_last_active.insert(name.clone(), now);\n                            // Log elapsed is authoritative when available\n                            session.task_elapsed = log_elapsed.or_else(|| {\n                                let start = self.task_starts[&name];\n                                Some(now.duration_since(start))\n                            });\n                        }\n                        SessionStatus::Idle => {\n                            // Log says agent is still working (e.g. thinking)\n                            if log_elapsed.is_some() {\n                                session.task_elapsed = log_elapsed;\n                            } else if let (Some(&start), Some(&last)) = (\n                                self.task_starts.get(&name),\n                                self.task_last_active.get(&name),\n                            ) {\n                                if now.duration_since(last).as_secs() < 5 {\n                                    session.task_elapsed = Some(last.duration_since(start));\n                                } else {\n                                    self.task_starts.remove(&name);\n                                    self.task_last_active.remove(&name);\n                                }\n                            }\n                        }\n                        SessionStatus::Exited => {\n                            self.task_starts.remove(&name);\n                            self.task_last_active.remove(&name);\n                        }\n                    }\n                }\n                // Remember which session was selected before re-sorting\n                let selected_name = self\n                    .sessions\n                    .get(self.selected)\n                    .map(|s| s.tmux_name.clone());\n\n                // Group by status (Idle → Running → Exited), then alphabetically\n                // within each group. Headers make the grouping explicit so\n                // reordering feels intentional rather than chaotic.\n                sessions.sort_by(|a, b| {\n                    a.status\n                        .sort_order()\n                        .cmp(&b.status.sort_order())\n                        .then(a.name.cmp(&b.name))\n                });\n\n                // Reuse these cheap pane snapshots for preview refresh.\n                self.latest_pane_captures = captures;\n                self.sessions = sessions;\n\n                // Restore selection to the same session after sort\n                if let Some(name) = selected_name {\n                    if let Some(idx) = self.sessions.iter().position(|s| s.tmux_name == name) {\n                        self.selected = idx;\n                    }\n                }\n            }\n            Err(e) => {\n                self.latest_pane_captures.clear();\n                self.status_message = Some(format!(\"Error listing sessions: {e}\"));\n            }\n        }\n        // Prune stale entries from per-session HashMaps to prevent unbounded\n        // memory growth when sessions are created and deleted over time.\n        {\n            let live_keys: std::collections::HashSet<&String> =\n                self.sessions.iter().map(|s| &s.tmux_name).collect();\n            self.prev_captures.retain(|k, _| live_keys.contains(k));\n            self.raw_captures.retain(|k, _| live_keys.contains(k));\n            self.idle_ticks.retain(|k, _| live_keys.contains(k));\n            self.changed_ticks.retain(|k, _| live_keys.contains(k));\n            self.dead_ticks.retain(|k, _| live_keys.contains(k));\n            self.task_starts.retain(|k, _| live_keys.contains(k));\n            self.task_last_active.retain(|k, _| live_keys.contains(k));\n            self.last_messages.retain(|k, _| live_keys.contains(k));\n            self.session_stats.retain(|k, _| live_keys.contains(k));\n            self.log_uuids.retain(|k, _| live_keys.contains(k));\n            self.uuid_retry_cooldowns.retain(|k, _| live_keys.contains(k));\n            self.latest_pane_captures\n                .retain(|k, _| live_keys.contains(k));\n        }\n\n        // Keep selected index in bounds\n        if self.sessions.is_empty() {\n            self.selected = 0;\n        } else if self.selected >= self.sessions.len() {\n            self.selected = self.sessions.len() - 1;\n        }\n    }\n\n    pub async fn refresh_preview(&mut self) {\n        let tmux_name = self\n            .sessions\n            .get(self.selected)\n            .map(|s| s.tmux_name.clone());\n        if let Some(tmux_name) = tmux_name {\n            let same_session = self.preview_session.as_ref() == Some(&tmux_name);\n            let wants_scrollback = self.preview_scroll_offset > 0;\n\n            // If the user is inspecting history, keep the current scrollback snapshot\n            // stable and avoid re-capturing huge buffers every event/tick.\n            if same_session && wants_scrollback && self.preview_has_scrollback {\n                return;\n            }\n\n            // Skip no-op refreshes for unchanged live view.\n            if same_session\n                && !wants_scrollback\n                && !self.preview_has_scrollback\n                && self.idle_ticks.get(&tmux_name).copied().unwrap_or(0) >= 1\n            {\n                return;\n            }\n\n            if wants_scrollback {\n                let result = self.manager.capture_pane_scrollback(&tmux_name).await;\n                match result {\n                    Ok(content) => self.set_preview_content(content, true),\n                    Err(_) => {\n                        self.set_preview_content(String::from(\"[unable to capture pane]\"), true)\n                    }\n                }\n            } else if let Some(content) = self.latest_pane_captures.get(&tmux_name) {\n                self.set_preview_content(content.clone(), false);\n            } else {\n                let result = self.manager.capture_pane(&tmux_name).await;\n                match result {\n                    Ok(content) => self.set_preview_content(content, false),\n                    Err(_) => {\n                        self.set_preview_content(String::from(\"[unable to capture pane]\"), false)\n                    }\n                }\n            }\n            self.preview_session = Some(tmux_name);\n        } else {\n            self.set_preview_content(String::from(\"No sessions. Press 'n' to create one.\"), false);\n            self.preview_session = None;\n        }\n    }\n\n    /// Poll for background refresh results and spawn new background tasks.\n    /// Non-blocking: spawns heavy I/O (JSONL parsing, git diff, UUID resolution)\n    /// on a background tokio task and polls results via oneshot channel.\n    pub fn refresh_messages(&mut self) {\n        // Always poll for completed background results\n        if let Some(mut rx) = self.bg_refresh_rx.take() {\n            match rx.try_recv() {\n                Ok(result) => {\n                    self.log_uuids.extend(result.log_uuids);\n                    self.uuid_retry_cooldowns = result.uuid_retry_cooldowns;\n                    self.last_messages.extend(result.last_messages);\n                    self.session_stats = result.session_stats;\n                    self.global_stats = result.global_stats;\n                    self.diff_files = result.diff_files;\n                }\n                Err(tokio::sync::oneshot::error::TryRecvError::Empty) => {\n                    // Still running, put it back\n                    self.bg_refresh_rx = Some(rx);\n                }\n                Err(tokio::sync::oneshot::error::TryRecvError::Closed) => {\n                    // Task panicked or was dropped\n                }\n            }\n        }\n\n        self.message_tick = self.message_tick.wrapping_add(1);\n        // Run every 50 ticks (~5 seconds at 100ms interval)\n        if self.message_tick % 50 != 0 {\n            return;\n        }\n\n        // Don't start a new background task if one is already running\n        if self.bg_refresh_rx.is_some() {\n            return;\n        }\n\n        // Clone data for background task\n        let tmux_names: Vec<String> = self.sessions.iter().map(|s| s.tmux_name.clone()).collect();\n        let log_uuids = self.log_uuids.clone();\n        let uuid_retry_cooldowns = self.uuid_retry_cooldowns.clone();\n        let session_stats = self.session_stats.clone();\n        let global_stats = self.global_stats.clone();\n        let cwd = self.cwd.clone();\n\n        let (tx, rx) = tokio::sync::oneshot::channel();\n        self.bg_refresh_rx = Some(rx);\n\n        tokio::spawn(async move {\n            let result =\n                compute_message_refresh(\n                    tmux_names,\n                    log_uuids,\n                    uuid_retry_cooldowns,\n                    session_stats,\n                    global_stats,\n                    cwd,\n                )\n                .await;\n            let _ = tx.send(result);\n        });\n    }\n\n    pub fn select_next(&mut self) {\n        if !self.sessions.is_empty() {\n            self.selected = (self.selected + 1) % self.sessions.len();\n            self.preview_scroll_offset = 0;\n            self.preview_session = None;\n            self.preview_has_scrollback = false;\n        }\n    }\n\n    pub fn select_prev(&mut self) {\n        if !self.sessions.is_empty() {\n            self.selected = if self.selected == 0 {\n                self.sessions.len() - 1\n            } else {\n                self.selected - 1\n            };\n            self.preview_scroll_offset = 0;\n            self.preview_session = None;\n            self.preview_has_scrollback = false;\n        }\n    }\n\n    pub fn scroll_preview_up(&mut self) {\n        self.preview_scroll_offset = self.preview_scroll_offset.saturating_add(3);\n    }\n\n    pub fn scroll_preview_down(&mut self) {\n        self.preview_scroll_offset = self.preview_scroll_offset.saturating_sub(3);\n    }\n\n    pub fn attach_selected(&mut self) {\n        if !self.sessions.is_empty() {\n            self.mode = Mode::Attached;\n        }\n    }\n\n    pub fn detach(&mut self) {\n        self.mode = Mode::Browse;\n    }\n\n    pub fn start_new_session(&mut self) {\n        self.mode = Mode::NewSessionAgent;\n        self.agent_selection = 0;\n        self.status_message = None;\n    }\n\n    pub async fn confirm_new_session(&mut self) {\n        let agents = AgentType::all();\n        let agent = agents[self.agent_selection].clone();\n        let existing: Vec<String> = self.sessions.iter().map(|s| s.name.clone()).collect();\n        let name = crate::session::generate_name(&existing);\n        let pid = self.project_id.clone();\n        let cwd = self.cwd.clone();\n        let manifest_dir = self.manifest_dir.clone();\n\n        let record = crate::manifest::SessionRecord::for_new_session(&name, &agent, &cwd);\n        let cmd = record.create_command();\n\n        let result = self\n            .manager\n            .create_session(&pid, &name, &agent, &cwd, Some(&cmd))\n            .await;\n        match result {\n            Ok(_) => {\n                let mut msg = format!(\"Created session '{}' with {}\", name, agent);\n                if let Err(e) = crate::manifest::add_session(&manifest_dir, &pid, record).await {\n                    msg.push_str(&format!(\" (warning: manifest save failed: {e})\"));\n                }\n                self.status_message = Some(msg);\n                self.refresh_sessions().await;\n                if let Some(idx) = self.sessions.iter().position(|s| s.name == name) {\n                    self.selected = idx;\n                }\n            }\n            Err(e) => {\n                self.status_message = Some(format!(\"Failed to create session: {e}\"));\n            }\n        }\n        self.mode = Mode::Browse;\n    }\n\n    pub fn request_delete(&mut self) {\n        if !self.sessions.is_empty() {\n            self.mode = Mode::ConfirmDelete;\n            self.status_message = None;\n        }\n    }\n\n    pub async fn confirm_delete(&mut self) {\n        if let Some(session) = self.sessions.get(self.selected) {\n            let name = session.name.clone();\n            let tmux_name = session.tmux_name.clone();\n            let pid = self.project_id.clone();\n            let manifest_dir = self.manifest_dir.clone();\n            let result = self.manager.kill_session(&tmux_name).await;\n            match result {\n                Ok(_) => {\n                    let mut msg = format!(\"Killed session '{name}'\");\n                    if let Err(e) =\n                        crate::manifest::remove_session(&manifest_dir, &pid, &name).await\n                    {\n                        msg.push_str(&format!(\" (warning: manifest update failed: {e})\"));\n                    }\n                    self.status_message = Some(msg);\n                }\n                Err(e) => {\n                    self.status_message = Some(format!(\"Failed to kill session: {e}\"));\n                }\n            }\n        }\n        self.mode = Mode::Browse;\n        self.refresh_sessions().await;\n    }\n\n    pub async fn revive_sessions(&mut self) {\n        let pid = self.project_id.clone();\n        let manifest_dir = self.manifest_dir.clone();\n        let mut manifest = crate::manifest::load_manifest(&manifest_dir, &pid).await;\n\n        if manifest.sessions.is_empty() {\n            return;\n        }\n\n        // Get live session names\n        let live = self.manager.list_sessions(&pid).await.unwrap_or_default();\n        let live_names: std::collections::HashSet<String> =\n            live.iter().map(|s| s.name.clone()).collect();\n\n        let mut revived = 0u32;\n        let mut failed = 0u32;\n        let mut manifest_dirty = false;\n\n        let names: Vec<String> = manifest.sessions.keys().cloned().collect();\n        for name in names {\n            if live_names.contains(&name) {\n                continue;\n            }\n\n            let record = manifest.sessions[&name].clone();\n\n            let success = match record.agent_type.parse::<AgentType>() {\n                Ok(agent) => {\n                    let resume_cmd = record.resume_command();\n                    self.manager\n                        .create_session(&pid, &name, &agent, &record.cwd, Some(&resume_cmd))\n                        .await\n                        .is_ok()\n                }\n                Err(_) => false,\n            };\n\n            if success {\n                if let Some(r) = manifest.sessions.get_mut(&name) {\n                    if r.failed_attempts > 0 {\n                        r.failed_attempts = 0;\n                        manifest_dirty = true;\n                    }\n                }\n                revived += 1;\n            } else {\n                failed += 1;\n                manifest_dirty = true;\n                let prune = manifest.sessions.get_mut(&name).map(|r| {\n                    r.failed_attempts += 1;\n                    r.failed_attempts >= crate::manifest::MAX_FAILED_ATTEMPTS\n                });\n                if prune == Some(true) {\n                    manifest.sessions.remove(&name);\n                }\n            }\n        }\n\n        if manifest_dirty {\n            let _ = crate::manifest::save_manifest(&manifest_dir, &pid, &manifest).await;\n        }\n\n        if revived > 0 || failed > 0 {\n            let msg = if failed == 0 {\n                format!(\"Revived {revived} session(s)\")\n            } else {\n                format!(\"Revived {revived}, failed {failed} session(s)\")\n            };\n            self.status_message = Some(msg);\n        }\n    }\n\n    pub fn cancel_mode(&mut self) {\n        self.mode = Mode::Browse;\n        self.status_message = None;\n    }\n\n    /// Send any pending literal keys queued by `handle_mouse`.\n    pub async fn flush_pending_keys(&mut self) {\n        if let Some((tmux_name, text)) = self.pending_literal_keys.take() {\n            let _ = self.manager.send_keys_literal(&tmux_name, &text).await;\n        }\n    }\n\n    pub fn handle_mouse(&mut self, mouse: MouseEvent) {\n        let pos = Position::new(mouse.column, mouse.row);\n        let sidebar = self.sidebar_area.get();\n        let preview = self.preview_area.get();\n\n        fn inner(r: Rect) -> Rect {\n            if r.width < 2 || r.height < 2 {\n                Rect::default()\n            } else {\n                Rect::new(r.x + 1, r.y + 1, r.width - 2, r.height - 2)\n            }\n        }\n\n        match self.mode {\n            Mode::Browse => match mouse.kind {\n                MouseEventKind::Down(_) => {\n                    let sidebar_inner = inner(sidebar);\n                    if sidebar_inner.contains(pos) {\n                        let row_offset = (mouse.row - sidebar_inner.y) as usize;\n                        let mut cumulative = 0usize;\n                        let mut target_idx = None;\n                        let mut current_group: Option<u8> = None;\n                        for (i, session) in self.sessions.iter().enumerate() {\n                            let group = session.status.sort_order();\n                            if current_group != Some(group) {\n                                current_group = Some(group);\n                                // Sidebar renders a status header line before each group.\n                                if row_offset == cumulative {\n                                    break;\n                                }\n                                cumulative += 1;\n                            }\n                            let item_height = if self.last_messages.contains_key(&session.tmux_name)\n                            {\n                                2\n                            } else {\n                                1\n                            };\n                            if row_offset < cumulative + item_height {\n                                target_idx = Some(i);\n                                break;\n                            }\n                            cumulative += item_height;\n                        }\n                        if let Some(idx) = target_idx {\n                            if self.selected != idx {\n                                self.selected = idx;\n                                self.preview_scroll_offset = 0;\n                                self.preview_session = None;\n                                self.preview_has_scrollback = false;\n                            }\n                        }\n                    } else if preview.contains(pos) {\n                        self.attach_selected();\n                    }\n                }\n                MouseEventKind::ScrollUp => {\n                    if preview.contains(pos) {\n                        self.scroll_preview_up();\n                    } else if sidebar.contains(pos) {\n                        self.select_prev();\n                    }\n                }\n                MouseEventKind::ScrollDown => {\n                    if preview.contains(pos) {\n                        self.scroll_preview_down();\n                    } else if sidebar.contains(pos) {\n                        self.select_next();\n                    }\n                }\n                _ => {}\n            },\n            Mode::Attached => match mouse.kind {\n                MouseEventKind::ScrollUp => {\n                    if preview.contains(pos) {\n                        self.scroll_preview_up();\n                    }\n                }\n                MouseEventKind::ScrollDown => {\n                    if preview.contains(pos) {\n                        self.scroll_preview_down();\n                    }\n                }\n                MouseEventKind::Down(MouseButton::Left) => {\n                    if inner(preview).contains(pos) {\n                        // Reset scroll to bottom so user sees live output after clicking.\n                        self.preview_scroll_offset = 0;\n                    } else {\n                        self.detach();\n                    }\n                }\n                MouseEventKind::Down(_) => {\n                    if !inner(preview).contains(pos) {\n                        self.detach();\n                    }\n                }\n                _ => {}\n            },\n            _ => {}\n        }\n    }\n\n    pub fn agent_select_next(&mut self) {\n        let count = AgentType::all().len();\n        self.agent_selection = (self.agent_selection + 1) % count;\n    }\n\n    pub fn agent_select_prev(&mut self) {\n        let count = AgentType::all().len();\n        self.agent_selection = if self.agent_selection == 0 {\n            count - 1\n        } else {\n            self.agent_selection - 1\n        };\n    }\n\n    pub async fn handle_key(&mut self, key: KeyEvent) {\n        match self.mode {\n            Mode::Browse => self.handle_browse_key(key.code),\n            Mode::Attached => self.handle_attached_key(key).await,\n            Mode::NewSessionAgent => self.handle_agent_select_key(key.code).await,\n            Mode::ConfirmDelete => self.handle_confirm_delete_key(key.code).await,\n        }\n    }\n\n    pub fn handle_browse_key(&mut self, code: KeyCode) {\n        match code {\n            KeyCode::Char('q') => self.should_quit = true,\n            KeyCode::Char('j') | KeyCode::Down => self.select_next(),\n            KeyCode::Char('k') | KeyCode::Up => self.select_prev(),\n            KeyCode::Enter => self.attach_selected(),\n            KeyCode::Char('n') => self.start_new_session(),\n            KeyCode::Char('d') => self.request_delete(),\n            KeyCode::Char('c') => self.mouse_captured = !self.mouse_captured,\n            _ => {}\n        }\n    }\n\n    pub async fn handle_attached_key(&mut self, key: KeyEvent) {\n        if key.code == KeyCode::Esc {\n            self.detach();\n            return;\n        }\n\n        if let Some(session) = self.sessions.get(self.selected) {\n            if let Some(tmux_key) = crate::tmux::keycode_to_tmux(key.code, key.modifiers) {\n                let tmux_name = session.tmux_name.clone();\n                let _ = self.manager.send_keys(&tmux_name, &tmux_key).await;\n            }\n        }\n    }\n\n    pub async fn handle_agent_select_key(&mut self, code: KeyCode) {\n        match code {\n            KeyCode::Enter => self.confirm_new_session().await,\n            KeyCode::Esc => self.cancel_mode(),\n            KeyCode::Char('j') | KeyCode::Down => self.agent_select_next(),\n            KeyCode::Char('k') | KeyCode::Up => self.agent_select_prev(),\n            _ => {}\n        }\n    }\n\n    pub async fn handle_confirm_delete_key(&mut self, code: KeyCode) {\n        match code {\n            KeyCode::Char('y') => self.confirm_delete().await,\n            KeyCode::Esc | KeyCode::Char('n') => self.cancel_mode(),\n            _ => {}\n        }\n    }\n}\n\n/// A single file's diff stats from `git diff --numstat` or untracked listing.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct DiffFile {\n    pub path: String,\n    pub insertions: u32,\n    pub deletions: u32,\n    pub untracked: bool,\n}\n\n/// Background task: compute message refresh results off the main event loop.\n/// Runs UUID resolution, JSONL parsing, global stats, and git diff in a background task.\nasync fn compute_message_refresh(\n    tmux_names: Vec<String>,\n    mut log_uuids: HashMap<String, String>,\n    mut uuid_retry_cooldowns: HashMap<String, u8>,\n    mut session_stats: HashMap<String, SessionStats>,\n    mut global_stats: GlobalStats,\n    cwd: String,\n) -> MessageRefreshResult {\n    /// Retry unresolved UUID discovery every ~30s (6 refresh cycles at 5s each).\n    const UUID_RETRY_COOLDOWN_CYCLES: u8 = 6;\n\n    let mut last_messages = HashMap::new();\n\n    for tmux_name in &tmux_names {\n        // Try to resolve UUID if not cached\n        if !log_uuids.contains_key(tmux_name) {\n            let should_attempt_resolve = match uuid_retry_cooldowns.get_mut(tmux_name) {\n                Some(cooldown) if *cooldown > 0 => {\n                    *cooldown -= 1;\n                    false\n                }\n                _ => true,\n            };\n\n            if should_attempt_resolve {\n                if let Some(uuid) = crate::logs::resolve_session_uuid(tmux_name).await {\n                    log_uuids.insert(tmux_name.clone(), uuid);\n                    uuid_retry_cooldowns.remove(tmux_name);\n                } else {\n                    uuid_retry_cooldowns\n                        .insert(tmux_name.clone(), UUID_RETRY_COOLDOWN_CYCLES);\n                }\n            }\n        }\n\n        // Read last message and update stats if UUID is known\n        if let Some(uuid) = log_uuids.get(tmux_name).cloned() {\n            uuid_retry_cooldowns.remove(tmux_name);\n            let stats = session_stats.entry(tmux_name.clone()).or_default();\n            if let Some(msg) =\n                crate::logs::update_session_stats_and_last_message(&cwd, &uuid, stats)\n            {\n                last_messages.insert(tmux_name.clone(), msg);\n            }\n        }\n    }\n\n    // Refresh machine-wide stats for today\n    crate::logs::update_global_stats(&mut global_stats);\n\n    // Refresh per-file git diff stats\n    let diff_files = get_git_diff_numstat(&cwd).await;\n\n    MessageRefreshResult {\n        log_uuids,\n        uuid_retry_cooldowns,\n        last_messages,\n        session_stats,\n        global_stats,\n        diff_files,\n    }\n}\n\nfn count_lines_u16(content: &str) -> u16 {\n    content.lines().count().min(u16::MAX as usize) as u16\n}\n\n/// Normalize captured pane content to reduce noise from spinners and cursors.\n/// Strips braille spinner characters (⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏), common line-drawing\n/// spinners (|/-\\), trailing whitespace, and ANSI escape sequences so that\n/// cosmetic animation doesn't trigger Running/Idle status changes.\nfn normalize_capture(content: &str) -> String {\n    let mut result = String::with_capacity(content.len());\n    let mut chars = content.chars().peekable();\n    while let Some(ch) = chars.next() {\n        // Skip ANSI escape sequences: ESC [ ... final_byte\n        if ch == '\\x1b' {\n            if chars.peek() == Some(&'[') {\n                chars.next();\n                // Consume until we hit a letter (the final byte of the CSI sequence)\n                while let Some(&c) = chars.peek() {\n                    chars.next();\n                    if c.is_ascii_alphabetic() {\n                        break;\n                    }\n                }\n            }\n            continue;\n        }\n        // Skip braille spinner characters (U+2800..U+28FF)\n        if ('\\u{2800}'..='\\u{28FF}').contains(&ch) {\n            continue;\n        }\n        result.push(ch);\n    }\n    // Trim trailing whitespace from each line\n    result\n        .lines()\n        .map(|l| l.trim_end())\n        .collect::<Vec<_>>()\n        .join(\"\\n\")\n}\n\n/// Parse `git diff --numstat` output into per-file stats.\n/// Each line: `<insertions>\\t<deletions>\\t<path>`\n/// Binary files show `-\\t-\\t<path>` — we skip those.\nfn parse_diff_numstat(output: &str) -> Vec<DiffFile> {\n    output\n        .lines()\n        .filter_map(|line| {\n            let mut parts = line.split('\\t');\n            let ins_str = parts.next()?;\n            let del_str = parts.next()?;\n            let path = parts.next()?.to_string();\n            if path.is_empty() {\n                return None;\n            }\n            let insertions = ins_str.parse().ok()?; // skips binary \"-\"\n            let deletions = del_str.parse().ok()?;\n            Some(DiffFile {\n                path,\n                insertions,\n                deletions,\n                untracked: false,\n            })\n        })\n        .collect()\n}\n\n/// Maximum number of diff files to process (bounds sort + render cost per tick).\nconst MAX_DIFF_FILES: usize = 200;\n\n/// Get per-file git diff stats for the working tree, including untracked files.\nasync fn get_git_diff_numstat(cwd: &str) -> Vec<DiffFile> {\n    let git_future = async {\n        tokio::join!(\n            tokio::process::Command::new(\"git\")\n                .args([\"diff\", \"--numstat\"])\n                .current_dir(cwd)\n                .output(),\n            tokio::process::Command::new(\"git\")\n                .args([\"ls-files\", \"--others\", \"--exclude-standard\"])\n                .current_dir(cwd)\n                .output(),\n        )\n    };\n\n    let (diff_out, untracked_out) =\n        match tokio::time::timeout(std::time::Duration::from_secs(3), git_future).await {\n            Ok(results) => results,\n            Err(_) => return Vec::new(), // timeout — return empty\n        };\n\n    let mut files = match diff_out {\n        Ok(o) if o.status.success() => parse_diff_numstat(&String::from_utf8_lossy(&o.stdout)),\n        _ => Vec::new(),\n    };\n\n    if let Ok(o) = untracked_out {\n        if o.status.success() {\n            for path in String::from_utf8_lossy(&o.stdout).lines() {\n                let path = path.trim();\n                if !path.is_empty() {\n                    files.push(DiffFile {\n                        path: path.to_string(),\n                        insertions: 0,\n                        deletions: 0,\n                        untracked: true,\n                    });\n                }\n            }\n        }\n    }\n\n    files.truncate(MAX_DIFF_FILES);\n    files\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::session::{AgentType, Session};\n    use crate::tmux::SessionManager;\n    use crossterm::event::MouseButton;\n\n    // ── Mock and helpers ─────────────────────────────────────────────\n\n    /// Configurable mock that covers all SessionManager error/success paths.\n    /// Use builder methods to override specific behaviors; defaults return Ok.\n    /// Unified mock that handles all SessionManager test scenarios:\n    /// - Error injection via `with_*_error()` builders\n    /// - Call tracking for send_keys/send_keys_literal via shared Arc<Mutex<Vec>>\n    /// - Capture call counting via AtomicUsize\n    /// - Dynamic capture responses via `capture_fn`\n    struct MockSessionManager {\n        sessions: Vec<Session>,\n        create_result: Result<String, String>,\n        list_result: Option<Result<Vec<Session>, String>>,\n        capture_result: Option<Result<String, String>>,\n        kill_result: Option<Result<(), String>>,\n        scrollback_result: Option<Result<String, String>>,\n        // Call tracking\n        sent_keys: std::sync::Arc<std::sync::Mutex<Vec<(String, String)>>>,\n        sent_literals: std::sync::Arc<std::sync::Mutex<Vec<(String, String)>>>,\n        capture_count: std::sync::Arc<std::sync::atomic::AtomicUsize>,\n        scrollback_count: std::sync::Arc<std::sync::atomic::AtomicUsize>,\n        // Dynamic capture: if set, capture_pane calls this with the call index\n        capture_fn: Option<std::sync::Arc<dyn Fn(usize) -> String + Send + Sync>>,\n        // Dynamic list: if set, list_sessions calls this with the call index\n        list_fn: Option<std::sync::Arc<dyn Fn(usize) -> Vec<Session> + Send + Sync>>,\n        list_count: std::sync::Arc<std::sync::atomic::AtomicUsize>,\n    }\n\n    impl MockSessionManager {\n        fn new() -> Self {\n            Self {\n                sessions: vec![],\n                create_result: Ok(\"mock-session\".to_string()),\n                list_result: None,\n                capture_result: None,\n                kill_result: None,\n                scrollback_result: None,\n                sent_keys: std::sync::Arc::new(std::sync::Mutex::new(Vec::new())),\n                sent_literals: std::sync::Arc::new(std::sync::Mutex::new(Vec::new())),\n                capture_count: std::sync::Arc::new(std::sync::atomic::AtomicUsize::new(0)),\n                scrollback_count: std::sync::Arc::new(std::sync::atomic::AtomicUsize::new(0)),\n                capture_fn: None,\n                list_fn: None,\n                list_count: std::sync::Arc::new(std::sync::atomic::AtomicUsize::new(0)),\n            }\n        }\n        fn with_sessions(sessions: Vec<Session>) -> Self {\n            let mut m = Self::new();\n            m.sessions = sessions;\n            m\n        }\n        fn with_list_error(mut self, msg: &str) -> Self {\n            self.list_result = Some(Err(msg.to_string()));\n            self\n        }\n        fn with_create_error(mut self, msg: &str) -> Self {\n            self.create_result = Err(msg.to_string());\n            self\n        }\n        fn with_capture_error(mut self, msg: &str) -> Self {\n            self.capture_result = Some(Err(msg.to_string()));\n            self\n        }\n        fn with_kill_error(mut self, msg: &str) -> Self {\n            self.kill_result = Some(Err(msg.to_string()));\n            self\n        }\n        fn with_capture_fn<F>(mut self, f: F) -> Self\n        where\n            F: Fn(usize) -> String + Send + Sync + 'static,\n        {\n            self.capture_fn = Some(std::sync::Arc::new(f));\n            self\n        }\n        fn with_list_fn<F>(mut self, f: F) -> Self\n        where\n            F: Fn(usize) -> Vec<Session> + Send + Sync + 'static,\n        {\n            self.list_fn = Some(std::sync::Arc::new(f));\n            self\n        }\n    }\n\n    #[async_trait::async_trait]\n    impl SessionManager for MockSessionManager {\n        async fn list_sessions(&self, _project_id: &str) -> anyhow::Result<Vec<Session>> {\n            let n = self\n                .list_count\n                .fetch_add(1, std::sync::atomic::Ordering::SeqCst);\n            match &self.list_result {\n                Some(Err(msg)) => Err(anyhow::anyhow!(\"{}\", msg)),\n                _ => {\n                    if let Some(f) = &self.list_fn {\n                        Ok(f(n))\n                    } else {\n                        Ok(self.sessions.clone())\n                    }\n                }\n            }\n        }\n        async fn create_session(\n            &self,\n            _project_id: &str,\n            _name: &str,\n            _agent: &AgentType,\n            _cwd: &str,\n            _command_override: Option<&str>,\n        ) -> anyhow::Result<String> {\n            self.create_result.clone().map_err(|e| anyhow::anyhow!(e))\n        }\n        async fn capture_pane(&self, _tmux_name: &str) -> anyhow::Result<String> {\n            let n = self\n                .capture_count\n                .fetch_add(1, std::sync::atomic::Ordering::SeqCst);\n            match &self.capture_result {\n                Some(Err(msg)) => Err(anyhow::anyhow!(\"{}\", msg)),\n                _ => {\n                    if let Some(f) = &self.capture_fn {\n                        Ok(f(n))\n                    } else {\n                        Ok(\"mock pane content\".to_string())\n                    }\n                }\n            }\n        }\n        async fn kill_session(&self, _tmux_name: &str) -> anyhow::Result<()> {\n            match &self.kill_result {\n                Some(Err(msg)) => Err(anyhow::anyhow!(\"{}\", msg)),\n                _ => Ok(()),\n            }\n        }\n        async fn send_keys(&self, tmux_name: &str, key: &str) -> anyhow::Result<()> {\n            self.sent_keys\n                .lock()\n                .unwrap()\n                .push((tmux_name.to_string(), key.to_string()));\n            Ok(())\n        }\n        async fn send_keys_literal(&self, tmux_name: &str, text: &str) -> anyhow::Result<()> {\n            self.sent_literals\n                .lock()\n                .unwrap()\n                .push((tmux_name.to_string(), text.to_string()));\n            Ok(())\n        }\n        async fn capture_pane_scrollback(&self, _tmux_name: &str) -> anyhow::Result<String> {\n            self.scrollback_count\n                .fetch_add(1, std::sync::atomic::Ordering::SeqCst);\n            match &self.scrollback_result {\n                Some(Err(msg)) => Err(anyhow::anyhow!(\"{}\", msg)),\n                _ => Ok(\"mock pane content\".to_string()),\n            }\n        }\n    }\n\n    fn test_app() -> App {\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(MockSessionManager::new()),\n        );\n        // Use a per-thread temp dir to avoid writing to the real home directory.\n        // The dir is created lazily by manifest functions when needed.\n        app.manifest_dir = std::env::temp_dir()\n            .join(\"hydra-test\")\n            .join(format!(\"{:?}\", std::thread::current().id()));\n        app\n    }\n\n    fn test_app_with_sessions(sessions: Vec<Session>) -> App {\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(MockSessionManager::with_sessions(sessions.clone())),\n        );\n        app.sessions = sessions;\n        app.manifest_dir = std::env::temp_dir()\n            .join(\"hydra-test\")\n            .join(format!(\"{:?}\", std::thread::current().id()));\n        app\n    }\n\n    fn make_session(name: &str, agent: AgentType) -> Session {\n        make_session_with_status(name, agent, crate::session::SessionStatus::Idle)\n    }\n\n    fn make_session_with_status(name: &str, agent: AgentType, status: SessionStatus) -> Session {\n        Session {\n            name: name.to_string(),\n            tmux_name: format!(\"hydra-testid-{name}\"),\n            agent_type: agent,\n            status,\n            task_elapsed: None,\n            _alive: true,\n        }\n    }\n\n    // ── Navigation tests ─────────────────────────────────────────────\n\n    #[test]\n    fn select_next_wraps_around() {\n        let sessions = vec![\n            make_session(\"a\", AgentType::Claude),\n            make_session(\"b\", AgentType::Claude),\n            make_session(\"c\", AgentType::Claude),\n        ];\n        let mut app = test_app_with_sessions(sessions);\n        app.selected = 2; // last item\n        app.select_next();\n        assert_eq!(\n            app.selected, 0,\n            \"select_next should wrap from last to first\"\n        );\n    }\n\n    #[test]\n    fn select_prev_wraps_around() {\n        let sessions = vec![\n            make_session(\"a\", AgentType::Claude),\n            make_session(\"b\", AgentType::Claude),\n            make_session(\"c\", AgentType::Claude),\n        ];\n        let mut app = test_app_with_sessions(sessions);\n        app.selected = 0; // first item\n        app.select_prev();\n        assert_eq!(\n            app.selected, 2,\n            \"select_prev should wrap from first to last\"\n        );\n    }\n\n    #[test]\n    fn select_next_with_empty_sessions_does_nothing() {\n        let mut app = test_app();\n        assert!(app.sessions.is_empty());\n        app.selected = 0;\n        app.select_next();\n        assert_eq!(\n            app.selected, 0,\n            \"select_next on empty sessions should not change selected\"\n        );\n    }\n\n    #[test]\n    fn select_prev_with_empty_sessions_does_nothing() {\n        let mut app = test_app();\n        assert!(app.sessions.is_empty());\n        app.selected = 0;\n        app.select_prev();\n        assert_eq!(\n            app.selected, 0,\n            \"select_prev on empty sessions should not change selected\"\n        );\n    }\n\n    #[test]\n    fn select_next_updates_index_correctly() {\n        let sessions = vec![\n            make_session(\"a\", AgentType::Claude),\n            make_session(\"b\", AgentType::Claude),\n            make_session(\"c\", AgentType::Claude),\n        ];\n        let mut app = test_app_with_sessions(sessions);\n        assert_eq!(app.selected, 0);\n        app.select_next();\n        assert_eq!(app.selected, 1);\n        app.select_next();\n        assert_eq!(app.selected, 2);\n    }\n\n    #[test]\n    fn select_prev_updates_index_correctly() {\n        let sessions = vec![\n            make_session(\"a\", AgentType::Claude),\n            make_session(\"b\", AgentType::Claude),\n            make_session(\"c\", AgentType::Claude),\n        ];\n        let mut app = test_app_with_sessions(sessions);\n        app.selected = 2;\n        app.select_prev();\n        assert_eq!(app.selected, 1);\n        app.select_prev();\n        assert_eq!(app.selected, 0);\n    }\n\n    // ── Mode transition tests ────────────────────────────────────────\n\n    #[test]\n    fn start_new_session_goes_to_agent_select() {\n        let mut app = test_app();\n        app.status_message = Some(\"old status\".to_string());\n        app.start_new_session();\n        assert_eq!(app.mode, Mode::NewSessionAgent);\n        assert_eq!(app.agent_selection, 0);\n        assert!(\n            app.status_message.is_none(),\n            \"status_message should be cleared\"\n        );\n    }\n\n    #[test]\n    fn cancel_mode_returns_to_browse() {\n        let mut app = test_app();\n        app.mode = Mode::NewSessionAgent;\n        app.status_message = Some(\"error message\".to_string());\n        app.cancel_mode();\n        assert_eq!(app.mode, Mode::Browse);\n        assert!(\n            app.status_message.is_none(),\n            \"status_message should be cleared\"\n        );\n    }\n\n    #[test]\n    fn cancel_mode_from_confirm_delete_returns_to_browse() {\n        let sessions = vec![make_session(\"s1\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.mode = Mode::ConfirmDelete;\n        app.cancel_mode();\n        assert_eq!(app.mode, Mode::Browse);\n    }\n\n    #[test]\n    fn request_delete_with_sessions_transitions_to_confirm_delete() {\n        let sessions = vec![make_session(\"s1\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.status_message = Some(\"old\".to_string());\n        app.request_delete();\n        assert_eq!(app.mode, Mode::ConfirmDelete);\n        assert!(\n            app.status_message.is_none(),\n            \"status_message should be cleared\"\n        );\n    }\n\n    #[test]\n    fn request_delete_with_no_sessions_stays_in_browse() {\n        let mut app = test_app();\n        assert!(app.sessions.is_empty());\n        app.request_delete();\n        assert_eq!(\n            app.mode,\n            Mode::Browse,\n            \"mode should remain Browse when no sessions\"\n        );\n    }\n\n    #[test]\n    fn attach_selected_with_sessions_transitions_to_attached() {\n        let sessions = vec![make_session(\"s1\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.attach_selected();\n        assert_eq!(app.mode, Mode::Attached);\n    }\n\n    #[test]\n    fn attach_selected_with_no_sessions_stays_in_browse() {\n        let mut app = test_app();\n        assert!(app.sessions.is_empty());\n        app.attach_selected();\n        assert_eq!(\n            app.mode,\n            Mode::Browse,\n            \"mode should remain Browse when no sessions\"\n        );\n    }\n\n    #[test]\n    fn detach_transitions_to_browse() {\n        let sessions = vec![make_session(\"s1\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.mode = Mode::Attached;\n        app.detach();\n        assert_eq!(app.mode, Mode::Browse);\n    }\n\n    // ── Agent selection tests ────────────────────────────────────────\n\n    #[test]\n    fn agent_select_next_wraps_around() {\n        let mut app = test_app();\n        let agent_count = AgentType::all().len();\n        app.agent_selection = agent_count - 1; // last agent\n        app.agent_select_next();\n        assert_eq!(\n            app.agent_selection, 0,\n            \"agent_select_next should wrap from last to first\"\n        );\n    }\n\n    #[test]\n    fn agent_select_prev_wraps_around() {\n        let mut app = test_app();\n        app.agent_selection = 0; // first agent\n        app.agent_select_prev();\n        let agent_count = AgentType::all().len();\n        assert_eq!(\n            app.agent_selection,\n            agent_count - 1,\n            \"agent_select_prev should wrap from first to last\"\n        );\n    }\n\n    #[test]\n    fn agent_select_next_increments() {\n        let mut app = test_app();\n        app.agent_selection = 0;\n        app.agent_select_next();\n        assert_eq!(app.agent_selection, 1);\n    }\n\n    #[test]\n    fn agent_select_prev_decrements() {\n        let mut app = test_app();\n        let agent_count = AgentType::all().len();\n        app.agent_selection = agent_count - 1;\n        app.agent_select_prev();\n        assert_eq!(app.agent_selection, agent_count - 2);\n    }\n\n    // ── Session creation flow tests ──────────────────────────────────\n\n    #[test]\n    fn full_new_session_flow() {\n        let mut app = test_app();\n\n        // Step 1: start new session — goes straight to agent select\n        app.start_new_session();\n        assert_eq!(app.mode, Mode::NewSessionAgent);\n        assert_eq!(app.agent_selection, 0);\n\n        // Step 2: cycle agent selection\n        app.agent_select_next();\n        assert_eq!(app.agent_selection, 1);\n    }\n\n    #[tokio::test]\n    async fn confirm_new_session_auto_generates_name() {\n        let mut app = test_app();\n        app.mode = Mode::NewSessionAgent;\n        app.agent_selection = 0;\n\n        app.confirm_new_session().await;\n\n        assert_eq!(\n            app.mode,\n            Mode::Browse,\n            \"mode should return to Browse after confirm\"\n        );\n        assert!(app.status_message.is_some());\n        assert!(\n            app.status_message\n                .as_ref()\n                .unwrap()\n                .contains(\"Created session 'alpha'\"),\n            \"should auto-generate name 'alpha': got {:?}\",\n            app.status_message\n        );\n    }\n\n    // ── Delete flow tests ────────────────────────────────────────────\n\n    #[tokio::test]\n    async fn delete_flow_request_then_confirm() {\n        let sessions = vec![make_session(\"doomed\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n\n        // Step 1: request delete\n        app.request_delete();\n        assert_eq!(app.mode, Mode::ConfirmDelete);\n\n        // Step 2: confirm delete (mock kill_session returns Ok)\n        app.confirm_delete().await;\n        assert_eq!(\n            app.mode,\n            Mode::Browse,\n            \"mode should return to Browse after confirm_delete\"\n        );\n        assert!(app.status_message.is_some());\n        assert!(\n            app.status_message\n                .as_ref()\n                .unwrap()\n                .contains(\"Killed session\"),\n            \"status should indicate session was killed: got {:?}\",\n            app.status_message\n        );\n    }\n\n    #[test]\n    fn delete_flow_request_then_cancel() {\n        let sessions = vec![make_session(\"safe\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n\n        app.request_delete();\n        assert_eq!(app.mode, Mode::ConfirmDelete);\n\n        app.cancel_mode();\n        assert_eq!(app.mode, Mode::Browse, \"cancel should return to Browse\");\n        assert!(app.status_message.is_none());\n    }\n\n    // ── Quit tests ───────────────────────────────────────────────────\n\n    #[test]\n    fn should_quit_starts_false() {\n        let app = test_app();\n        assert!(!app.should_quit, \"should_quit should start as false\");\n    }\n\n    #[test]\n    fn should_quit_stays_true_once_set() {\n        let mut app = test_app();\n        app.should_quit = true;\n        assert!(app.should_quit, \"should_quit should remain true once set\");\n        // Verify it doesn't reset unexpectedly after other operations\n        app.select_next();\n        assert!(\n            app.should_quit,\n            \"should_quit should still be true after other operations\"\n        );\n    }\n\n    // ── Additional edge-case tests ───────────────────────────────────\n\n    #[test]\n    fn select_next_with_single_session_stays_at_zero() {\n        let sessions = vec![make_session(\"only\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        assert_eq!(app.selected, 0);\n        app.select_next();\n        assert_eq!(app.selected, 0, \"single session: next should wrap to 0\");\n    }\n\n    #[test]\n    fn select_prev_with_single_session_stays_at_zero() {\n        let sessions = vec![make_session(\"only\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        assert_eq!(app.selected, 0);\n        app.select_prev();\n        assert_eq!(app.selected, 0, \"single session: prev should wrap to 0\");\n    }\n\n    #[test]\n    fn new_app_starts_in_browse_mode() {\n        let app = test_app();\n        assert_eq!(app.mode, Mode::Browse);\n    }\n\n    // ── parse_diff_numstat tests ──────────────────────────────────\n\n    #[test]\n    fn parse_diff_numstat_multiple_files() {\n        let out = \"45\\t12\\tsrc/app.rs\\n30\\t5\\tsrc/ui.rs\\n3\\t0\\tREADME.md\\n\";\n        let files = super::parse_diff_numstat(out);\n        assert_eq!(files.len(), 3);\n        assert_eq!(\n            files[0],\n            super::DiffFile {\n                path: \"src/app.rs\".into(),\n                insertions: 45,\n                deletions: 12,\n                untracked: false\n            }\n        );\n        assert_eq!(\n            files[1],\n            super::DiffFile {\n                path: \"src/ui.rs\".into(),\n                insertions: 30,\n                deletions: 5,\n                untracked: false\n            }\n        );\n        assert_eq!(\n            files[2],\n            super::DiffFile {\n                path: \"README.md\".into(),\n                insertions: 3,\n                deletions: 0,\n                untracked: false\n            }\n        );\n    }\n\n    #[test]\n    fn parse_diff_numstat_skips_binary() {\n        let out = \"-\\t-\\timage.png\\n10\\t2\\tsrc/main.rs\\n\";\n        let files = super::parse_diff_numstat(out);\n        assert_eq!(files.len(), 1);\n        assert_eq!(files[0].path, \"src/main.rs\");\n    }\n\n    #[test]\n    fn parse_diff_numstat_empty() {\n        assert!(super::parse_diff_numstat(\"\").is_empty());\n        assert!(super::parse_diff_numstat(\"\\n\").is_empty());\n    }\n\n    #[test]\n    fn new_app_has_empty_sessions() {\n        let app = test_app();\n        assert!(app.sessions.is_empty());\n    }\n\n    #[test]\n    fn new_app_has_zero_selected() {\n        let app = test_app();\n        assert_eq!(app.selected, 0);\n    }\n\n    #[test]\n    fn new_app_has_no_status_message() {\n        let app = test_app();\n        assert!(app.status_message.is_none());\n    }\n\n    #[test]\n    fn multiple_cancel_mode_calls_remain_in_browse() {\n        let mut app = test_app();\n        app.mode = Mode::NewSessionAgent;\n        app.cancel_mode();\n        assert_eq!(app.mode, Mode::Browse);\n        app.cancel_mode();\n        assert_eq!(\n            app.mode,\n            Mode::Browse,\n            \"repeated cancel should stay in Browse\"\n        );\n    }\n\n    #[test]\n    fn request_delete_clears_status_message() {\n        let sessions = vec![make_session(\"s\", AgentType::Codex)];\n        let mut app = test_app_with_sessions(sessions);\n        app.status_message = Some(\"old msg\".to_string());\n        app.request_delete();\n        assert!(\n            app.status_message.is_none(),\n            \"request_delete should clear status_message\"\n        );\n    }\n\n    #[test]\n    fn detach_from_already_browse_stays_browse() {\n        let mut app = test_app();\n        assert_eq!(app.mode, Mode::Browse);\n        app.detach();\n        assert_eq!(\n            app.mode,\n            Mode::Browse,\n            \"detach from Browse should remain Browse\"\n        );\n    }\n\n    #[tokio::test]\n    async fn refresh_preview_with_no_sessions_shows_placeholder() {\n        let mut app = test_app();\n        app.refresh_preview().await;\n        assert!(\n            app.preview.contains(\"No sessions\"),\n            \"preview with no sessions should show placeholder, got: {:?}\",\n            app.preview\n        );\n    }\n\n    #[tokio::test]\n    async fn refresh_preview_with_session_captures_pane() {\n        let sessions = vec![make_session(\"s1\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.refresh_preview().await;\n        assert_eq!(\n            app.preview, \"mock pane content\",\n            \"preview should contain mock pane content\"\n        );\n    }\n\n    #[tokio::test]\n    async fn refresh_sessions_populates_from_manager() {\n        let sessions = vec![\n            make_session(\"a\", AgentType::Claude),\n            make_session(\"b\", AgentType::Codex),\n        ];\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(MockSessionManager::with_sessions(sessions.clone())),\n        );\n        assert!(app.sessions.is_empty(), \"sessions should start empty\");\n        app.refresh_sessions().await;\n        assert_eq!(\n            app.sessions.len(),\n            2,\n            \"refresh_sessions should populate from manager\"\n        );\n    }\n\n    // ── Scroll tests ─────────────────────────────────────────────────\n\n    #[test]\n    fn scroll_preview_up_increases_offset() {\n        let mut app = test_app();\n        assert_eq!(app.preview_scroll_offset, 0);\n        app.scroll_preview_up();\n        assert_eq!(app.preview_scroll_offset, 3);\n        app.scroll_preview_up();\n        assert_eq!(app.preview_scroll_offset, 6);\n    }\n\n    #[test]\n    fn scroll_preview_down_decreases_offset() {\n        let mut app = test_app();\n        app.preview_scroll_offset = 6;\n        app.scroll_preview_down();\n        assert_eq!(app.preview_scroll_offset, 3);\n        app.scroll_preview_down();\n        assert_eq!(app.preview_scroll_offset, 0);\n    }\n\n    #[test]\n    fn scroll_preview_down_saturates_at_zero() {\n        let mut app = test_app();\n        assert_eq!(app.preview_scroll_offset, 0);\n        app.scroll_preview_down();\n        assert_eq!(app.preview_scroll_offset, 0, \"should not go below 0\");\n    }\n\n    #[test]\n    fn scroll_preview_up_saturates_at_max() {\n        let mut app = test_app();\n        app.preview_scroll_offset = u16::MAX - 1;\n        app.scroll_preview_up();\n        assert_eq!(app.preview_scroll_offset, u16::MAX);\n    }\n\n    #[test]\n    fn select_next_resets_scroll_offset() {\n        let sessions = vec![\n            make_session(\"a\", AgentType::Claude),\n            make_session(\"b\", AgentType::Claude),\n        ];\n        let mut app = test_app_with_sessions(sessions);\n        app.preview_scroll_offset = 10;\n        app.select_next();\n        assert_eq!(app.preview_scroll_offset, 0, \"scroll should reset on nav\");\n    }\n\n    #[test]\n    fn select_prev_resets_scroll_offset() {\n        let sessions = vec![\n            make_session(\"a\", AgentType::Claude),\n            make_session(\"b\", AgentType::Claude),\n        ];\n        let mut app = test_app_with_sessions(sessions);\n        app.selected = 1;\n        app.preview_scroll_offset = 10;\n        app.select_prev();\n        assert_eq!(app.preview_scroll_offset, 0);\n    }\n\n    // ── Mouse handling tests ─────────────────────────────────────────\n\n    #[test]\n    fn mouse_click_sidebar_selects_session() {\n        let sessions = vec![\n            make_session(\"a\", AgentType::Claude),\n            make_session(\"b\", AgentType::Claude),\n            make_session(\"c\", AgentType::Claude),\n        ];\n        let mut app = test_app_with_sessions(sessions);\n        // Set sidebar area to simulate layout (x=0, y=0, w=24, h=20)\n        app.sidebar_area.set(Rect::new(0, 0, 24, 20));\n        app.preview_area.set(Rect::new(24, 0, 56, 20));\n\n        // Sidebar always has a status header row, so second session is row y=3.\n        app.handle_mouse(MouseEvent {\n            kind: MouseEventKind::Down(MouseButton::Left),\n            column: 5,\n            row: 3,\n            modifiers: crossterm::event::KeyModifiers::NONE,\n        });\n        assert_eq!(\n            app.selected, 1,\n            \"clicking second row should select session 1\"\n        );\n    }\n\n    #[test]\n    fn mouse_click_sidebar_status_header_does_not_change_selection() {\n        let sessions = vec![\n            make_session_with_status(\"a\", AgentType::Claude, SessionStatus::Idle),\n            make_session_with_status(\"b\", AgentType::Claude, SessionStatus::Running),\n        ];\n        let mut app = test_app_with_sessions(sessions);\n        app.sidebar_area.set(Rect::new(0, 0, 24, 20));\n        app.preview_area.set(Rect::new(24, 0, 56, 20));\n        app.selected = 1;\n\n        // Click first status header row (top row inside border).\n        app.handle_mouse(MouseEvent {\n            kind: MouseEventKind::Down(MouseButton::Left),\n            column: 5,\n            row: 1,\n            modifiers: crossterm::event::KeyModifiers::NONE,\n        });\n        assert_eq!(app.selected, 1, \"header rows should not select a session\");\n    }\n\n    #[test]\n    fn mouse_click_sidebar_with_multiple_status_groups() {\n        let sessions = vec![\n            make_session_with_status(\"a\", AgentType::Claude, SessionStatus::Idle),\n            make_session_with_status(\"b\", AgentType::Claude, SessionStatus::Running),\n            make_session_with_status(\"c\", AgentType::Claude, SessionStatus::Exited),\n        ];\n        let mut app = test_app_with_sessions(sessions);\n        app.sidebar_area.set(Rect::new(0, 0, 24, 20));\n        app.preview_area.set(Rect::new(24, 0, 56, 20));\n        app.selected = 0;\n\n        // Running group has its own header; session \"b\" is at y=4.\n        app.handle_mouse(MouseEvent {\n            kind: MouseEventKind::Down(MouseButton::Left),\n            column: 5,\n            row: 4,\n            modifiers: crossterm::event::KeyModifiers::NONE,\n        });\n        assert_eq!(app.selected, 1, \"click should map to running session row\");\n    }\n\n    #[test]\n    fn mouse_click_preview_attaches() {\n        let sessions = vec![make_session(\"a\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.sidebar_area.set(Rect::new(0, 0, 24, 20));\n        app.preview_area.set(Rect::new(24, 0, 56, 20));\n\n        // Click inside the preview area border\n        app.handle_mouse(MouseEvent {\n            kind: MouseEventKind::Down(MouseButton::Left),\n            column: 30,\n            row: 5,\n            modifiers: crossterm::event::KeyModifiers::NONE,\n        });\n        assert_eq!(app.mode, Mode::Attached);\n    }\n\n    #[test]\n    fn mouse_scroll_up_preview_scrolls() {\n        let sessions = vec![make_session(\"a\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.sidebar_area.set(Rect::new(0, 0, 24, 20));\n        app.preview_area.set(Rect::new(24, 0, 56, 20));\n\n        app.handle_mouse(MouseEvent {\n            kind: MouseEventKind::ScrollUp,\n            column: 30,\n            row: 5,\n            modifiers: crossterm::event::KeyModifiers::NONE,\n        });\n        assert_eq!(app.preview_scroll_offset, 3);\n    }\n\n    #[test]\n    fn mouse_scroll_down_preview_scrolls() {\n        let sessions = vec![make_session(\"a\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.sidebar_area.set(Rect::new(0, 0, 24, 20));\n        app.preview_area.set(Rect::new(24, 0, 56, 20));\n        app.preview_scroll_offset = 6;\n\n        app.handle_mouse(MouseEvent {\n            kind: MouseEventKind::ScrollDown,\n            column: 30,\n            row: 5,\n            modifiers: crossterm::event::KeyModifiers::NONE,\n        });\n        assert_eq!(app.preview_scroll_offset, 3);\n    }\n\n    #[test]\n    fn mouse_scroll_sidebar_navigates() {\n        let sessions = vec![\n            make_session(\"a\", AgentType::Claude),\n            make_session(\"b\", AgentType::Claude),\n            make_session(\"c\", AgentType::Claude),\n        ];\n        let mut app = test_app_with_sessions(sessions);\n        app.sidebar_area.set(Rect::new(0, 0, 24, 20));\n        app.preview_area.set(Rect::new(24, 0, 56, 20));\n\n        // Scroll down in sidebar = select next\n        app.handle_mouse(MouseEvent {\n            kind: MouseEventKind::ScrollDown,\n            column: 5,\n            row: 3,\n            modifiers: crossterm::event::KeyModifiers::NONE,\n        });\n        assert_eq!(app.selected, 1);\n\n        // Scroll up in sidebar = select prev\n        app.handle_mouse(MouseEvent {\n            kind: MouseEventKind::ScrollUp,\n            column: 5,\n            row: 3,\n            modifiers: crossterm::event::KeyModifiers::NONE,\n        });\n        assert_eq!(app.selected, 0);\n    }\n\n    #[test]\n    fn mouse_attached_click_outside_detaches() {\n        let sessions = vec![make_session(\"a\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.mode = Mode::Attached;\n        app.sidebar_area.set(Rect::new(0, 0, 24, 20));\n        app.preview_area.set(Rect::new(24, 0, 56, 20));\n\n        // Click outside preview inner area (on the border)\n        app.handle_mouse(MouseEvent {\n            kind: MouseEventKind::Down(MouseButton::Left),\n            column: 24, // on border\n            row: 0,     // on border\n            modifiers: crossterm::event::KeyModifiers::NONE,\n        });\n        assert_eq!(app.mode, Mode::Browse);\n    }\n\n    #[test]\n    fn mouse_attached_scroll_up_in_preview() {\n        let sessions = vec![make_session(\"a\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.mode = Mode::Attached;\n        app.sidebar_area.set(Rect::new(0, 0, 24, 20));\n        app.preview_area.set(Rect::new(24, 0, 56, 20));\n\n        app.handle_mouse(MouseEvent {\n            kind: MouseEventKind::ScrollUp,\n            column: 30,\n            row: 5,\n            modifiers: crossterm::event::KeyModifiers::NONE,\n        });\n        assert_eq!(app.preview_scroll_offset, 3);\n        assert_eq!(app.mode, Mode::Attached, \"should stay attached\");\n    }\n\n    #[test]\n    fn mouse_attached_scroll_down_in_preview() {\n        let sessions = vec![make_session(\"a\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.mode = Mode::Attached;\n        app.sidebar_area.set(Rect::new(0, 0, 24, 20));\n        app.preview_area.set(Rect::new(24, 0, 56, 20));\n        app.preview_scroll_offset = 6;\n\n        app.handle_mouse(MouseEvent {\n            kind: MouseEventKind::ScrollDown,\n            column: 30,\n            row: 5,\n            modifiers: crossterm::event::KeyModifiers::NONE,\n        });\n        assert_eq!(app.preview_scroll_offset, 3);\n    }\n\n    #[test]\n    fn mouse_other_mode_is_noop() {\n        let mut app = test_app();\n        app.mode = Mode::ConfirmDelete;\n        app.sidebar_area.set(Rect::new(0, 0, 24, 20));\n        app.preview_area.set(Rect::new(24, 0, 56, 20));\n\n        // Mouse events in ConfirmDelete mode should be no-ops\n        app.handle_mouse(MouseEvent {\n            kind: MouseEventKind::Down(MouseButton::Left),\n            column: 5,\n            row: 5,\n            modifiers: crossterm::event::KeyModifiers::NONE,\n        });\n        assert_eq!(app.mode, Mode::ConfirmDelete);\n    }\n\n    // ── Refresh edge cases ───────────────────────────────────────────\n\n    #[tokio::test]\n    async fn refresh_sessions_error_sets_status_message() {\n        let mock = MockSessionManager::new().with_list_error(\"tmux not running\");\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(mock),\n        );\n        app.refresh_sessions().await;\n        assert!(app.status_message.is_some());\n        assert!(app\n            .status_message\n            .as_ref()\n            .unwrap()\n            .contains(\"Error listing sessions\"));\n    }\n\n    #[tokio::test]\n    async fn refresh_preview_error_shows_error_message() {\n        let mock = MockSessionManager::new().with_capture_error(\"capture failed\");\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(mock),\n        );\n        app.sessions = vec![make_session(\"s1\", AgentType::Claude)];\n        app.refresh_preview().await;\n        assert_eq!(app.preview, \"[unable to capture pane]\");\n    }\n\n    #[tokio::test]\n    async fn confirm_new_session_error_sets_status_message() {\n        let mock = MockSessionManager::new().with_create_error(\"creation failed\");\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(mock),\n        );\n        app.mode = Mode::NewSessionAgent;\n        app.confirm_new_session().await;\n        assert_eq!(app.mode, Mode::Browse);\n        assert!(app\n            .status_message\n            .as_ref()\n            .unwrap()\n            .contains(\"Failed to create session\"));\n    }\n\n    #[tokio::test]\n    async fn confirm_delete_error_sets_status_message() {\n        let mock = MockSessionManager::new().with_kill_error(\"kill failed\");\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(mock),\n        );\n        app.sessions = vec![make_session(\"s1\", AgentType::Claude)];\n        app.mode = Mode::ConfirmDelete;\n        app.confirm_delete().await;\n        assert_eq!(app.mode, Mode::Browse);\n        assert!(app\n            .status_message\n            .as_ref()\n            .unwrap()\n            .contains(\"Failed to kill session\"));\n    }\n\n    #[tokio::test]\n    async fn confirm_delete_with_no_sessions_returns_to_browse() {\n        let mut app = test_app();\n        app.mode = Mode::ConfirmDelete;\n        app.confirm_delete().await;\n        assert_eq!(app.mode, Mode::Browse);\n    }\n\n    #[tokio::test]\n    async fn refresh_sessions_selected_stays_in_bounds() {\n        let sessions = vec![\n            make_session(\"a\", AgentType::Claude),\n            make_session(\"b\", AgentType::Codex),\n        ];\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(MockSessionManager::with_sessions(sessions)),\n        );\n        app.selected = 99; // out of bounds\n        app.refresh_sessions().await;\n        assert!(\n            app.selected < app.sessions.len(),\n            \"selected should be clamped to valid range\"\n        );\n    }\n\n    #[tokio::test]\n    async fn refresh_sessions_detects_running_status() {\n        // First capture (no prev) → immediately Running (first_capture branch).\n        // Mock returns constant \"mock pane content\" each tick via capture_panes.\n        let sessions = vec![make_session(\"s1\", AgentType::Claude)];\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(MockSessionManager::with_sessions(sessions)),\n        );\n        app.refresh_sessions().await;\n        assert_eq!(\n            app.sessions[0].status,\n            SessionStatus::Running,\n            \"first tick = Running (first capture)\"\n        );\n\n        // With debouncing, need 30 consecutive unchanged ticks (~3s) to become Idle\n        for i in 2..=30 {\n            app.refresh_sessions().await;\n            assert_eq!(\n                app.sessions[0].status,\n                SessionStatus::Running,\n                \"tick {i} still Running\"\n            );\n        }\n        // 31st tick: 30 consecutive unchanged → Idle\n        app.refresh_sessions().await;\n        assert_eq!(\n            app.sessions[0].status,\n            SessionStatus::Idle,\n            \"tick 31 = Idle (30 consecutive unchanged)\"\n        );\n    }\n\n    #[tokio::test]\n    async fn refresh_sessions_sorts_alphabetically() {\n        let sessions = vec![\n            make_session(\"charlie\", AgentType::Claude),\n            make_session(\"alpha\", AgentType::Claude),\n            make_session(\"bravo\", AgentType::Claude),\n        ];\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(MockSessionManager::with_sessions(sessions)),\n        );\n\n        app.refresh_sessions().await;\n\n        let names: Vec<_> = app.sessions.iter().map(|s| s.name.as_str()).collect();\n        assert_eq!(names, vec![\"alpha\", \"bravo\", \"charlie\"]);\n    }\n\n    #[tokio::test]\n    async fn refresh_sessions_preserves_selection_across_sort() {\n        // Manager returns sessions in reverse order of their names\n        let sessions = vec![\n            make_session(\"bravo\", AgentType::Claude),\n            make_session(\"alpha\", AgentType::Claude),\n        ];\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(MockSessionManager::with_sessions(sessions.clone())),\n        );\n        // Pre-set: user has \"bravo\" selected (index 0 before sort)\n        app.sessions = sessions;\n        app.selected = 0; // \"bravo\" selected\n\n        app.refresh_sessions().await;\n\n        // After alphabetical sort, \"alpha\" is 0 and \"bravo\" is 1\n        // Selection should follow \"bravo\" to its new index\n        let selected_name = &app.sessions[app.selected].name;\n        assert_eq!(\n            selected_name, \"bravo\",\n            \"selection should follow session across sort\"\n        );\n    }\n\n    #[tokio::test]\n    async fn refresh_messages_only_runs_every_50_ticks() {\n        let mut app = test_app();\n        // message_tick starts at 0, first call increments to 1\n        app.refresh_messages();\n        // No panic, no messages (no sessions)\n        assert_eq!(app.message_tick, 1);\n    }\n\n    // ── Mouse with last_messages (2-line items) ──────────────────────\n\n    #[test]\n    fn mouse_click_sidebar_with_two_line_items() {\n        let sessions = vec![\n            make_session(\"a\", AgentType::Claude),\n            make_session(\"b\", AgentType::Claude),\n        ];\n        let mut app = test_app_with_sessions(sessions);\n        app.sidebar_area.set(Rect::new(0, 0, 24, 20));\n        app.preview_area.set(Rect::new(24, 0, 56, 20));\n        // First session has a message (2 lines), second doesn't (1 line)\n        app.last_messages\n            .insert(\"hydra-testid-a\".to_string(), \"some msg\".to_string());\n\n        // Rows: header, a, a-msg, b. Session b is at y=4.\n        app.handle_mouse(MouseEvent {\n            kind: MouseEventKind::Down(MouseButton::Left),\n            column: 5,\n            row: 4,\n            modifiers: crossterm::event::KeyModifiers::NONE,\n        });\n        assert_eq!(app.selected, 1);\n    }\n\n    // ── Mouse with tiny sidebar ──────────────────────────────────────\n\n    #[test]\n    fn mouse_click_tiny_sidebar_no_panic() {\n        let mut app = test_app();\n        // Sidebar too small (width < 2)\n        app.sidebar_area.set(Rect::new(0, 0, 1, 1));\n        app.preview_area.set(Rect::new(1, 0, 1, 1));\n\n        app.handle_mouse(MouseEvent {\n            kind: MouseEventKind::Down(MouseButton::Left),\n            column: 0,\n            row: 0,\n            modifiers: crossterm::event::KeyModifiers::NONE,\n        });\n        // Should not panic\n    }\n\n    #[test]\n    fn mouse_move_is_noop() {\n        let sessions = vec![make_session(\"a\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.sidebar_area.set(Rect::new(0, 0, 24, 20));\n        app.preview_area.set(Rect::new(24, 0, 56, 20));\n\n        let old_selected = app.selected;\n        app.handle_mouse(MouseEvent {\n            kind: MouseEventKind::Moved,\n            column: 5,\n            row: 5,\n            modifiers: crossterm::event::KeyModifiers::NONE,\n        });\n        assert_eq!(app.selected, old_selected);\n        assert_eq!(app.mode, Mode::Browse);\n    }\n\n    // ── Mode enum ────────────────────────────────────────────────────\n\n    #[test]\n    fn mode_clone_and_debug() {\n        let mode = Mode::Browse;\n        let cloned = mode.clone();\n        assert_eq!(mode, cloned);\n        let debug = format!(\"{:?}\", mode);\n        assert!(debug.contains(\"Browse\"));\n    }\n\n    // ── revive_sessions tests ────────────────────────────────────────\n    // Each test uses a unique project ID to avoid parallel test interference.\n\n    fn make_manifest_record(name: &str, agent_type: &str) -> crate::manifest::SessionRecord {\n        crate::manifest::SessionRecord {\n            name: name.to_string(),\n            agent_type: agent_type.to_string(),\n            agent_session_id: if agent_type == \"claude\" {\n                Some(\"test-uuid\".to_string())\n            } else {\n                None\n            },\n            cwd: \"/tmp/test\".to_string(),\n            failed_attempts: 0,\n        }\n    }\n\n    #[tokio::test]\n    async fn revive_sessions_empty_manifest_is_noop() {\n        let dir = tempfile::tempdir().unwrap();\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(MockSessionManager::new()),\n        );\n        app.manifest_dir = dir.path().to_path_buf();\n        app.revive_sessions().await;\n        assert!(app.status_message.is_none());\n    }\n\n    #[tokio::test]\n    async fn revive_sessions_creates_dead_sessions() {\n        let dir = tempfile::tempdir().unwrap();\n        let pid = \"testid\";\n        let mut manifest = crate::manifest::Manifest::default();\n        manifest\n            .sessions\n            .insert(\"alpha\".to_string(), make_manifest_record(\"alpha\", \"claude\"));\n        crate::manifest::save_manifest(dir.path(), pid, &manifest)\n            .await\n            .unwrap();\n\n        let mut app = App::new_with_manager(\n            pid.to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(MockSessionManager::new()),\n        );\n        app.manifest_dir = dir.path().to_path_buf();\n        app.revive_sessions().await;\n\n        assert!(app.status_message.is_some());\n        let msg = app.status_message.as_ref().unwrap();\n        assert!(\n            msg.contains(\"Revived 1\"),\n            \"should revive 1 session, got: {msg}\"\n        );\n    }\n\n    #[tokio::test]\n    async fn revive_sessions_skips_live_sessions() {\n        let dir = tempfile::tempdir().unwrap();\n        let pid = \"testid\";\n        let mut manifest = crate::manifest::Manifest::default();\n        manifest\n            .sessions\n            .insert(\"alpha\".to_string(), make_manifest_record(\"alpha\", \"claude\"));\n        crate::manifest::save_manifest(dir.path(), pid, &manifest)\n            .await\n            .unwrap();\n\n        let sessions = vec![Session {\n            name: \"alpha\".to_string(),\n            tmux_name: format!(\"hydra-{pid}-alpha\"),\n            agent_type: AgentType::Claude,\n            status: SessionStatus::Idle,\n            task_elapsed: None,\n            _alive: true,\n        }];\n        let mut app = App::new_with_manager(\n            pid.to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(MockSessionManager::with_sessions(sessions)),\n        );\n        app.manifest_dir = dir.path().to_path_buf();\n        app.revive_sessions().await;\n\n        // No status message because no sessions were revived (all already live)\n        assert!(app.status_message.is_none());\n    }\n\n    #[tokio::test]\n    async fn revive_sessions_invalid_agent_type_counts_as_failed() {\n        let dir = tempfile::tempdir().unwrap();\n        let pid = \"testid\";\n        let mut manifest = crate::manifest::Manifest::default();\n        manifest.sessions.insert(\n            \"bad\".to_string(),\n            make_manifest_record(\"bad\", \"unknown_agent\"),\n        );\n        crate::manifest::save_manifest(dir.path(), pid, &manifest)\n            .await\n            .unwrap();\n\n        let mut app = App::new_with_manager(\n            pid.to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(MockSessionManager::new()),\n        );\n        app.manifest_dir = dir.path().to_path_buf();\n        app.revive_sessions().await;\n\n        assert!(app.status_message.is_some());\n        let msg = app.status_message.as_ref().unwrap();\n        assert!(\n            msg.contains(\"failed 1\"),\n            \"should report 1 failed, got: {msg}\"\n        );\n    }\n\n    #[tokio::test]\n    async fn revive_sessions_create_error_counts_as_failed() {\n        let dir = tempfile::tempdir().unwrap();\n        let pid = \"testid\";\n        let mut manifest = crate::manifest::Manifest::default();\n        manifest\n            .sessions\n            .insert(\"alpha\".to_string(), make_manifest_record(\"alpha\", \"claude\"));\n        crate::manifest::save_manifest(dir.path(), pid, &manifest)\n            .await\n            .unwrap();\n\n        let mock = MockSessionManager::new().with_create_error(\"tmux error\");\n        let mut app =\n            App::new_with_manager(pid.to_string(), \"/tmp/test\".to_string(), Box::new(mock));\n        app.manifest_dir = dir.path().to_path_buf();\n        app.revive_sessions().await;\n\n        assert!(app.status_message.is_some());\n        let msg = app.status_message.as_ref().unwrap();\n        assert!(msg.contains(\"failed 1\"), \"got: {msg}\");\n    }\n\n    #[tokio::test]\n    async fn revive_sessions_prunes_after_max_failed_attempts() {\n        let dir = tempfile::tempdir().unwrap();\n        let pid = \"testid\";\n        let mut manifest = crate::manifest::Manifest::default();\n        let mut record = make_manifest_record(\"doomed\", \"unknown_agent\");\n        // Set failed_attempts to one below the threshold\n        record.failed_attempts = crate::manifest::MAX_FAILED_ATTEMPTS - 1;\n        manifest.sessions.insert(\"doomed\".to_string(), record);\n        crate::manifest::save_manifest(dir.path(), pid, &manifest)\n            .await\n            .unwrap();\n\n        let mut app = App::new_with_manager(\n            pid.to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(MockSessionManager::new()),\n        );\n        app.manifest_dir = dir.path().to_path_buf();\n        app.revive_sessions().await;\n\n        // After this failure, failed_attempts reaches MAX_FAILED_ATTEMPTS and gets pruned\n        let loaded = crate::manifest::load_manifest(dir.path(), pid).await;\n        assert!(\n            !loaded.sessions.contains_key(\"doomed\"),\n            \"session should be pruned after reaching MAX_FAILED_ATTEMPTS\"\n        );\n    }\n\n    // ── Task timer edge cases ───────────────────────────────────────\n\n    #[tokio::test]\n    async fn refresh_sessions_exited_clears_task_timer() {\n        // Create a manager that returns an Exited session\n        let exited_session = vec![Session {\n            name: \"dead\".to_string(),\n            tmux_name: \"hydra-testid-dead\".to_string(),\n            agent_type: AgentType::Claude,\n            status: SessionStatus::Exited,\n            task_elapsed: None,\n            _alive: true,\n        }];\n        let mock = MockSessionManager::with_sessions(exited_session);\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(mock),\n        );\n\n        // Pre-set a task start to verify it gets cleaned up\n        app.task_starts\n            .insert(\"hydra-testid-dead\".to_string(), std::time::Instant::now());\n        app.task_last_active\n            .insert(\"hydra-testid-dead\".to_string(), std::time::Instant::now());\n\n        // Dead-tick debounce requires DEAD_TICK_THRESHOLD consecutive dead ticks\n        for _ in 0..App::DEAD_TICK_THRESHOLD {\n            app.refresh_sessions().await;\n        }\n        assert_eq!(app.sessions[0].status, SessionStatus::Exited);\n        assert!(\n            !app.task_starts.contains_key(\"hydra-testid-dead\"),\n            \"exited session should clear task_starts\"\n        );\n        assert!(\n            !app.task_last_active.contains_key(\"hydra-testid-dead\"),\n            \"exited session should clear task_last_active\"\n        );\n    }\n\n    #[tokio::test]\n    async fn refresh_sessions_idle_after_long_pause_clears_timer() {\n        // In test env, tmux capture returns empty/error → content is static.\n        // Session stays Idle throughout (hysteresis never sees 2 changed ticks).\n        let sessions = vec![make_session(\"worker\", AgentType::Claude)];\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(MockSessionManager::with_sessions(sessions)),\n        );\n\n        // Run enough ticks to stabilize at Idle (1 first-capture + 30 unchanged = 31)\n        for _ in 0..31 {\n            app.refresh_sessions().await;\n        }\n        assert_eq!(app.sessions[0].status, SessionStatus::Idle);\n\n        // Simulate long idle: move task_last_active back >5 seconds\n        let five_secs_ago = std::time::Instant::now() - std::time::Duration::from_secs(6);\n        let key = \"hydra-testid-worker\".to_string();\n        app.task_last_active.insert(key.clone(), five_secs_ago);\n        app.task_starts.insert(\n            key.clone(),\n            five_secs_ago - std::time::Duration::from_secs(10),\n        );\n\n        // Next refresh: still Idle, but last_active > 5s ago = clear timer\n        app.refresh_sessions().await;\n        assert_eq!(app.sessions[0].status, SessionStatus::Idle);\n        assert!(\n            !app.task_starts.contains_key(&key),\n            \"long idle should clear task_starts\"\n        );\n    }\n\n    // ── confirm_new_session with Codex agent ────────────────────────\n\n    #[tokio::test]\n    async fn confirm_new_session_with_codex() {\n        let mut app = test_app();\n        app.mode = Mode::NewSessionAgent;\n        app.agent_selection = 1; // Codex\n\n        app.confirm_new_session().await;\n\n        assert_eq!(app.mode, Mode::Browse);\n        assert!(app.status_message.is_some());\n        let msg = app.status_message.as_ref().unwrap();\n        assert!(\n            msg.contains(\"Codex\"),\n            \"status should mention Codex: got {msg}\"\n        );\n    }\n\n    // ── confirm_new_session selects newly created session ────────────\n\n    #[tokio::test]\n    async fn confirm_new_session_selects_new_session() {\n        let sessions = vec![make_session(\"alpha\", AgentType::Claude)];\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(MockSessionManager::with_sessions(sessions)),\n        );\n        // Pre-populate sessions\n        app.sessions = vec![make_session(\"alpha\", AgentType::Claude)];\n        app.mode = Mode::NewSessionAgent;\n        app.agent_selection = 0;\n\n        app.confirm_new_session().await;\n\n        assert_eq!(app.mode, Mode::Browse);\n        // The new session name would be \"bravo\" (since \"alpha\" exists)\n        assert!(app.status_message.as_ref().unwrap().contains(\"bravo\"));\n    }\n\n    // ── Key handler tests ───────────────────────────────────────────\n\n    use crossterm::event::{KeyCode, KeyEvent, KeyEventKind, KeyEventState, KeyModifiers};\n\n    fn make_key(code: KeyCode) -> KeyEvent {\n        KeyEvent {\n            code,\n            modifiers: KeyModifiers::NONE,\n            kind: KeyEventKind::Press,\n            state: KeyEventState::NONE,\n        }\n    }\n\n    fn make_key_with_mods(code: KeyCode, modifiers: KeyModifiers) -> KeyEvent {\n        KeyEvent {\n            code,\n            modifiers,\n            kind: KeyEventKind::Press,\n            state: KeyEventState::NONE,\n        }\n    }\n\n    // ── Browse mode key handler ─────────────────────────────────────\n\n    #[test]\n    fn browse_key_q_sets_quit() {\n        let mut app = test_app();\n        app.handle_browse_key(KeyCode::Char('q'));\n        assert!(app.should_quit);\n    }\n\n    #[test]\n    fn browse_key_j_selects_next() {\n        let sessions = vec![\n            make_session(\"a\", AgentType::Claude),\n            make_session(\"b\", AgentType::Claude),\n        ];\n        let mut app = test_app_with_sessions(sessions);\n        app.handle_browse_key(KeyCode::Char('j'));\n        assert_eq!(app.selected, 1);\n    }\n\n    #[test]\n    fn browse_key_down_selects_next() {\n        let sessions = vec![\n            make_session(\"a\", AgentType::Claude),\n            make_session(\"b\", AgentType::Claude),\n        ];\n        let mut app = test_app_with_sessions(sessions);\n        app.handle_browse_key(KeyCode::Down);\n        assert_eq!(app.selected, 1);\n    }\n\n    #[test]\n    fn browse_key_k_selects_prev() {\n        let sessions = vec![\n            make_session(\"a\", AgentType::Claude),\n            make_session(\"b\", AgentType::Claude),\n        ];\n        let mut app = test_app_with_sessions(sessions);\n        app.selected = 1;\n        app.handle_browse_key(KeyCode::Char('k'));\n        assert_eq!(app.selected, 0);\n    }\n\n    #[test]\n    fn browse_key_up_selects_prev() {\n        let sessions = vec![\n            make_session(\"a\", AgentType::Claude),\n            make_session(\"b\", AgentType::Claude),\n        ];\n        let mut app = test_app_with_sessions(sessions);\n        app.selected = 1;\n        app.handle_browse_key(KeyCode::Up);\n        assert_eq!(app.selected, 0);\n    }\n\n    #[test]\n    fn browse_key_enter_attaches() {\n        let sessions = vec![make_session(\"a\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.handle_browse_key(KeyCode::Enter);\n        assert_eq!(app.mode, Mode::Attached);\n    }\n\n    #[test]\n    fn browse_key_n_starts_new_session() {\n        let mut app = test_app();\n        app.handle_browse_key(KeyCode::Char('n'));\n        assert_eq!(app.mode, Mode::NewSessionAgent);\n    }\n\n    #[test]\n    fn browse_key_d_requests_delete() {\n        let sessions = vec![make_session(\"a\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.handle_browse_key(KeyCode::Char('d'));\n        assert_eq!(app.mode, Mode::ConfirmDelete);\n    }\n\n    #[test]\n    fn browse_key_unknown_is_noop() {\n        let mut app = test_app();\n        app.handle_browse_key(KeyCode::Char('x'));\n        assert_eq!(app.mode, Mode::Browse);\n        assert!(!app.should_quit);\n    }\n\n    // ── Attached mode key handler ───────────────────────────────────\n\n    #[tokio::test]\n    async fn attached_key_esc_detaches() {\n        let sessions = vec![make_session(\"a\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.mode = Mode::Attached;\n        app.handle_attached_key(make_key(KeyCode::Esc)).await;\n        assert_eq!(app.mode, Mode::Browse);\n    }\n\n    #[tokio::test]\n    async fn attached_key_sends_to_tmux() {\n        use std::sync::{Arc, Mutex};\n\n        let sent_keys = Arc::new(Mutex::new(Vec::new()));\n        let mut manager = MockSessionManager::new();\n        manager.sent_keys = sent_keys.clone();\n\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(manager),\n        );\n        app.sessions = vec![make_session(\"worker\", AgentType::Claude)];\n        app.mode = Mode::Attached;\n\n        // Send 'a' key\n        app.handle_attached_key(make_key(KeyCode::Char('a'))).await;\n\n        let keys = sent_keys.lock().unwrap();\n        assert_eq!(keys.len(), 1);\n        assert_eq!(keys[0].0, \"hydra-testid-worker\");\n        assert_eq!(keys[0].1, \"a\");\n    }\n\n    #[tokio::test]\n    async fn attached_key_ctrl_c_sends_ctrl_key() {\n        use std::sync::{Arc, Mutex};\n\n        let sent_keys = Arc::new(Mutex::new(Vec::new()));\n        let mut manager = MockSessionManager::new();\n        manager.sent_keys = sent_keys.clone();\n\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(manager),\n        );\n        app.sessions = vec![make_session(\"worker\", AgentType::Claude)];\n        app.mode = Mode::Attached;\n\n        // Send Ctrl+C\n        app.handle_attached_key(make_key_with_mods(\n            KeyCode::Char('c'),\n            KeyModifiers::CONTROL,\n        ))\n        .await;\n\n        let keys = sent_keys.lock().unwrap();\n        assert_eq!(keys.len(), 1);\n        assert_eq!(keys[0].1, \"C-c\");\n    }\n\n    #[tokio::test]\n    async fn attached_key_no_session_is_noop() {\n        let mut app = test_app();\n        app.mode = Mode::Attached;\n        // No sessions, should not panic\n        app.handle_attached_key(make_key(KeyCode::Char('a'))).await;\n        assert_eq!(app.mode, Mode::Attached);\n    }\n\n    // ── Agent select mode key handler ───────────────────────────────\n\n    #[tokio::test]\n    async fn agent_select_key_enter_confirms() {\n        let mut app = test_app();\n        app.mode = Mode::NewSessionAgent;\n        app.agent_selection = 0;\n        app.handle_agent_select_key(KeyCode::Enter).await;\n        assert_eq!(app.mode, Mode::Browse);\n        assert!(app.status_message.is_some());\n    }\n\n    #[tokio::test]\n    async fn agent_select_key_esc_cancels() {\n        let mut app = test_app();\n        app.mode = Mode::NewSessionAgent;\n        app.handle_agent_select_key(KeyCode::Esc).await;\n        assert_eq!(app.mode, Mode::Browse);\n    }\n\n    #[tokio::test]\n    async fn agent_select_key_j_moves_down() {\n        let mut app = test_app();\n        app.mode = Mode::NewSessionAgent;\n        app.agent_selection = 0;\n        app.handle_agent_select_key(KeyCode::Char('j')).await;\n        assert_eq!(app.agent_selection, 1);\n    }\n\n    #[tokio::test]\n    async fn agent_select_key_k_moves_up() {\n        let mut app = test_app();\n        app.mode = Mode::NewSessionAgent;\n        app.agent_selection = 1;\n        app.handle_agent_select_key(KeyCode::Char('k')).await;\n        assert_eq!(app.agent_selection, 0);\n    }\n\n    #[tokio::test]\n    async fn agent_select_key_unknown_is_noop() {\n        let mut app = test_app();\n        app.mode = Mode::NewSessionAgent;\n        app.agent_selection = 0;\n        app.handle_agent_select_key(KeyCode::Char('x')).await;\n        assert_eq!(app.agent_selection, 0);\n        assert_eq!(app.mode, Mode::NewSessionAgent);\n    }\n\n    // ── Confirm delete mode key handler ─────────────────────────────\n\n    #[tokio::test]\n    async fn confirm_delete_key_y_confirms() {\n        let sessions = vec![make_session(\"doomed\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.mode = Mode::ConfirmDelete;\n        app.handle_confirm_delete_key(KeyCode::Char('y')).await;\n        assert_eq!(app.mode, Mode::Browse);\n        assert!(app.status_message.as_ref().unwrap().contains(\"Killed\"));\n    }\n\n    #[tokio::test]\n    async fn confirm_delete_key_esc_cancels() {\n        let sessions = vec![make_session(\"safe\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.mode = Mode::ConfirmDelete;\n        app.handle_confirm_delete_key(KeyCode::Esc).await;\n        assert_eq!(app.mode, Mode::Browse);\n    }\n\n    #[tokio::test]\n    async fn confirm_delete_key_n_cancels() {\n        let sessions = vec![make_session(\"safe\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.mode = Mode::ConfirmDelete;\n        app.handle_confirm_delete_key(KeyCode::Char('n')).await;\n        assert_eq!(app.mode, Mode::Browse);\n    }\n\n    #[tokio::test]\n    async fn confirm_delete_key_unknown_is_noop() {\n        let sessions = vec![make_session(\"safe\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.mode = Mode::ConfirmDelete;\n        app.handle_confirm_delete_key(KeyCode::Char('x')).await;\n        assert_eq!(app.mode, Mode::ConfirmDelete);\n    }\n\n    // ── handle_key dispatch tests ───────────────────────────────────\n\n    #[tokio::test]\n    async fn handle_key_dispatches_browse_mode() {\n        let mut app = test_app();\n        app.mode = Mode::Browse;\n        app.handle_key(make_key(KeyCode::Char('q'))).await;\n        assert!(app.should_quit);\n    }\n\n    #[tokio::test]\n    async fn handle_key_dispatches_attached_mode() {\n        let sessions = vec![make_session(\"a\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.mode = Mode::Attached;\n        app.handle_key(make_key(KeyCode::Esc)).await;\n        assert_eq!(app.mode, Mode::Browse);\n    }\n\n    #[tokio::test]\n    async fn handle_key_dispatches_agent_select_mode() {\n        let mut app = test_app();\n        app.mode = Mode::NewSessionAgent;\n        app.handle_key(make_key(KeyCode::Esc)).await;\n        assert_eq!(app.mode, Mode::Browse);\n    }\n\n    #[tokio::test]\n    async fn handle_key_dispatches_confirm_delete_mode() {\n        let sessions = vec![make_session(\"a\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.mode = Mode::ConfirmDelete;\n        app.handle_key(make_key(KeyCode::Esc)).await;\n        assert_eq!(app.mode, Mode::Browse);\n    }\n\n    // ── Additional coverage tests ────────────────────────────────────\n\n    #[test]\n    fn app_new_creates_instance() {\n        // Covers App::new() which delegates to new_with_manager with TmuxSessionManager\n        let app = App::new(\"testid\".to_string(), \"/tmp/test\".to_string());\n        assert_eq!(app.project_id, \"testid\");\n        assert_eq!(app.cwd, \"/tmp/test\");\n        assert_eq!(app.mode, Mode::Browse);\n        assert!(app.sessions.is_empty());\n    }\n\n    #[tokio::test]\n    async fn attached_key_unmappable_key_is_noop() {\n        // Keys that keycode_to_tmux returns None for (e.g., CapsLock, Null)\n        // should not panic or send anything\n        use std::sync::{Arc, Mutex};\n\n        let sent_keys = Arc::new(Mutex::new(Vec::new()));\n        let mut manager = MockSessionManager::new();\n        manager.sent_keys = sent_keys.clone();\n\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(manager),\n        );\n        app.sessions = vec![make_session(\"worker\", AgentType::Claude)];\n        app.mode = Mode::Attached;\n\n        // Send a key that doesn't map to tmux (e.g., CapsLock)\n        app.handle_attached_key(make_key(KeyCode::CapsLock)).await;\n\n        let keys = sent_keys.lock().unwrap();\n        assert!(keys.is_empty(), \"unmappable key should not send anything\");\n    }\n\n    #[test]\n    fn mouse_click_already_selected_session_stays() {\n        let sessions = vec![\n            make_session(\"a\", AgentType::Claude),\n            make_session(\"b\", AgentType::Claude),\n        ];\n        let mut app = test_app_with_sessions(sessions);\n        app.sidebar_area.set(Rect::new(0, 0, 24, 20));\n        app.preview_area.set(Rect::new(24, 0, 56, 20));\n        app.selected = 0;\n        app.preview_scroll_offset = 5; // non-zero offset\n\n        // Click on first session (already selected)\n        app.handle_mouse(MouseEvent {\n            kind: MouseEventKind::Down(MouseButton::Left),\n            column: 5,\n            row: 1, // inner area row 0 = first session\n            modifiers: crossterm::event::KeyModifiers::NONE,\n        });\n        assert_eq!(app.selected, 0);\n        // Scroll offset should NOT reset since session didn't change\n        assert_eq!(app.preview_scroll_offset, 5);\n    }\n\n    #[test]\n    fn mouse_attached_scroll_outside_preview_is_noop() {\n        let sessions = vec![make_session(\"a\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.mode = Mode::Attached;\n        app.sidebar_area.set(Rect::new(0, 0, 24, 20));\n        app.preview_area.set(Rect::new(24, 0, 56, 20));\n\n        // Scroll up outside the preview area (in sidebar)\n        app.handle_mouse(MouseEvent {\n            kind: MouseEventKind::ScrollUp,\n            column: 5,\n            row: 5,\n            modifiers: crossterm::event::KeyModifiers::NONE,\n        });\n        assert_eq!(\n            app.preview_scroll_offset, 0,\n            \"scroll outside preview should be noop\"\n        );\n        assert_eq!(app.mode, Mode::Attached);\n    }\n\n    #[test]\n    fn parse_diff_numstat_empty_path_skipped() {\n        // A line with insertions/deletions but empty path should be skipped\n        let out = \"10\\t5\\t\\n\";\n        let files = super::parse_diff_numstat(out);\n        assert!(files.is_empty());\n    }\n\n    #[test]\n    fn parse_diff_numstat_malformed_line() {\n        // Lines without enough tab-separated parts\n        let out = \"only_one_column\\n\";\n        let files = super::parse_diff_numstat(out);\n        assert!(files.is_empty());\n    }\n\n    #[test]\n    fn parse_diff_numstat_untracked_field_is_false() {\n        let out = \"10\\t5\\tsrc/main.rs\\n\";\n        let files = super::parse_diff_numstat(out);\n        assert_eq!(files.len(), 1);\n        assert!(!files[0].untracked, \"parsed files should not be untracked\");\n    }\n\n    #[tokio::test]\n    async fn refresh_messages_runs_on_50th_tick() {\n        let mut app = test_app();\n        // Start at tick 49 so the next call (tick 50) triggers the inner loop\n        app.message_tick = 49;\n        app.refresh_messages();\n        assert_eq!(app.message_tick, 50);\n        // No panic and no sessions to process — this just covers the tick check\n    }\n\n    #[tokio::test]\n    async fn refresh_messages_applies_completed_bg_result() {\n        let mut app = test_app();\n\n        // Create a completed oneshot with a MessageRefreshResult\n        let (tx, rx) = tokio::sync::oneshot::channel();\n        let mut result = MessageRefreshResult {\n            log_uuids: std::collections::HashMap::new(),\n            uuid_retry_cooldowns: std::collections::HashMap::new(),\n            last_messages: std::collections::HashMap::new(),\n            session_stats: std::collections::HashMap::new(),\n            global_stats: crate::logs::GlobalStats::default(),\n            diff_files: vec![],\n        };\n        result\n            .last_messages\n            .insert(\"test-session\".to_string(), \"hello world\".to_string());\n        result\n            .uuid_retry_cooldowns\n            .insert(\"test-session\".to_string(), 4);\n        tx.send(result).ok(); // ignore error (can't unwrap without Debug on the error type)\n\n        app.bg_refresh_rx = Some(rx);\n        app.refresh_messages();\n\n        assert_eq!(\n            app.last_messages.get(\"test-session\").map(|s| s.as_str()),\n            Some(\"hello world\"),\n            \"should apply completed background result\"\n        );\n        assert_eq!(\n            app.uuid_retry_cooldowns.get(\"test-session\"),\n            Some(&4),\n            \"should apply cooldown state from background result\"\n        );\n        assert!(app.bg_refresh_rx.is_none(), \"should consume the channel\");\n    }\n\n    #[tokio::test]\n    async fn refresh_messages_keeps_pending_bg_task() {\n        let mut app = test_app();\n\n        // Create a oneshot where we keep the sender (task still running)\n        let (tx, rx) = tokio::sync::oneshot::channel::<MessageRefreshResult>();\n        app.bg_refresh_rx = Some(rx);\n        app.refresh_messages();\n\n        assert!(\n            app.bg_refresh_rx.is_some(),\n            \"should put receiver back when task is still running\"\n        );\n        drop(tx); // cleanup\n    }\n\n    #[tokio::test]\n    async fn refresh_messages_handles_dropped_bg_task() {\n        let mut app = test_app();\n\n        // Create a oneshot and immediately drop the sender (simulates task panic)\n        let (_tx, rx) = tokio::sync::oneshot::channel::<MessageRefreshResult>();\n        drop(_tx);\n        app.bg_refresh_rx = Some(rx);\n        app.refresh_messages();\n\n        assert!(\n            app.bg_refresh_rx.is_none(),\n            \"should clear channel when task was dropped\"\n        );\n    }\n\n    #[tokio::test]\n    async fn refresh_messages_skips_spawn_when_bg_task_running() {\n        let mut app = test_app();\n        // Simulate a running background task with a pending oneshot\n        let (_tx, rx) = tokio::sync::oneshot::channel::<MessageRefreshResult>();\n        app.bg_refresh_rx = Some(rx);\n\n        // Set tick to 19 so next call would normally trigger a new bg task\n        app.message_tick = 19;\n        app.refresh_messages();\n        assert_eq!(app.message_tick, 20);\n        // bg_refresh_rx should still be set (the pending one, not a new one)\n        assert!(\n            app.bg_refresh_rx.is_some(),\n            \"should not start new bg task when one is running\"\n        );\n        drop(_tx);\n    }\n\n    #[tokio::test]\n    async fn refresh_messages_wraps_tick_counter() {\n        let mut app = test_app();\n        app.message_tick = 255; // u8::MAX\n        app.refresh_messages();\n        assert_eq!(app.message_tick, 0, \"tick counter should wrap around\");\n    }\n\n    #[test]\n    fn mouse_attached_click_inside_preview_stays_attached() {\n        let sessions = vec![make_session(\"a\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.mode = Mode::Attached;\n        app.sidebar_area.set(Rect::new(0, 0, 24, 20));\n        app.preview_area.set(Rect::new(24, 0, 56, 20));\n\n        // Click inside the preview inner area (not on border)\n        app.handle_mouse(MouseEvent {\n            kind: MouseEventKind::Down(MouseButton::Left),\n            column: 30,\n            row: 5,\n            modifiers: crossterm::event::KeyModifiers::NONE,\n        });\n        assert_eq!(\n            app.mode,\n            Mode::Attached,\n            \"clicking inside preview should stay attached\"\n        );\n    }\n\n    #[test]\n    fn mouse_attached_click_does_not_forward_to_tmux() {\n        let sessions = vec![make_session(\"a\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.mode = Mode::Attached;\n        app.sidebar_area.set(Rect::new(0, 0, 24, 20));\n        app.preview_area.set(Rect::new(24, 0, 56, 20));\n\n        app.handle_mouse(MouseEvent {\n            kind: MouseEventKind::Down(MouseButton::Left),\n            column: 30,\n            row: 5,\n            modifiers: crossterm::event::KeyModifiers::NONE,\n        });\n\n        assert!(\n            app.pending_literal_keys.is_none(),\n            \"should not forward mouse clicks to agents\"\n        );\n        assert_eq!(app.mode, Mode::Attached);\n    }\n\n    #[test]\n    fn mouse_attached_click_resets_scroll_offset() {\n        let sessions = vec![make_session(\"a\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.mode = Mode::Attached;\n        app.sidebar_area.set(Rect::new(0, 0, 24, 20));\n        app.preview_area.set(Rect::new(24, 0, 56, 20));\n        app.preview_scroll_offset = 10;\n\n        app.handle_mouse(MouseEvent {\n            kind: MouseEventKind::Down(MouseButton::Left),\n            column: 30,\n            row: 5,\n            modifiers: crossterm::event::KeyModifiers::NONE,\n        });\n\n        assert_eq!(\n            app.preview_scroll_offset, 0,\n            \"click should reset scroll to bottom\"\n        );\n    }\n\n    #[test]\n    fn mouse_attached_other_event_is_noop() {\n        let sessions = vec![make_session(\"a\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.mode = Mode::Attached;\n        app.sidebar_area.set(Rect::new(0, 0, 24, 20));\n        app.preview_area.set(Rect::new(24, 0, 56, 20));\n\n        // MouseMove in attached mode\n        app.handle_mouse(MouseEvent {\n            kind: MouseEventKind::Moved,\n            column: 30,\n            row: 5,\n            modifiers: crossterm::event::KeyModifiers::NONE,\n        });\n        assert_eq!(app.mode, Mode::Attached);\n    }\n\n    // ── Resilience: selected resets to 0 when all sessions deleted ──\n\n    #[tokio::test]\n    async fn refresh_sessions_selected_resets_to_zero_when_empty() {\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(MockSessionManager::new()), // returns empty sessions\n        );\n        app.selected = 5; // out-of-bounds for an empty list\n        app.refresh_sessions().await;\n        assert!(app.sessions.is_empty());\n        assert_eq!(\n            app.selected, 0,\n            \"selected should reset to 0 when sessions list is empty\"\n        );\n    }\n\n    // ── Resilience: HashMap pruning removes stale keys ──────────────\n\n    #[tokio::test]\n    async fn refresh_sessions_prunes_stale_hashmap_entries() {\n        let sessions = vec![make_session(\"alpha\", AgentType::Claude)];\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(MockSessionManager::with_sessions(sessions)),\n        );\n\n        // Pre-populate HashMaps with a stale key that won't appear in live sessions\n        let stale = \"hydra-testid-deleted\".to_string();\n        app.prev_captures.insert(stale.clone(), \"old\".into());\n        app.idle_ticks.insert(stale.clone(), 3);\n        app.changed_ticks.insert(stale.clone(), 2);\n        app.task_starts.insert(stale.clone(), Instant::now());\n        app.task_last_active.insert(stale.clone(), Instant::now());\n        app.last_messages.insert(stale.clone(), \"msg\".into());\n        app.session_stats\n            .insert(stale.clone(), SessionStats::default());\n        app.log_uuids.insert(stale.clone(), \"uuid\".into());\n        app.uuid_retry_cooldowns.insert(stale.clone(), 3);\n        app.dead_ticks.insert(stale.clone(), 1);\n\n        app.refresh_sessions().await;\n\n        // Live session key should still exist in prev_captures (inserted during refresh)\n        let live = \"hydra-testid-alpha\".to_string();\n        assert!(\n            app.prev_captures.contains_key(&live),\n            \"live key should remain\"\n        );\n\n        // Stale key should be pruned from all maps\n        assert!(\n            !app.prev_captures.contains_key(&stale),\n            \"stale prev_captures should be pruned\"\n        );\n        assert!(\n            !app.idle_ticks.contains_key(&stale),\n            \"stale idle_ticks should be pruned\"\n        );\n        assert!(\n            !app.changed_ticks.contains_key(&stale),\n            \"stale changed_ticks should be pruned\"\n        );\n        assert!(\n            !app.task_starts.contains_key(&stale),\n            \"stale task_starts should be pruned\"\n        );\n        assert!(\n            !app.task_last_active.contains_key(&stale),\n            \"stale task_last_active should be pruned\"\n        );\n        assert!(\n            !app.last_messages.contains_key(&stale),\n            \"stale last_messages should be pruned\"\n        );\n        assert!(\n            !app.session_stats.contains_key(&stale),\n            \"stale session_stats should be pruned\"\n        );\n        assert!(\n            !app.log_uuids.contains_key(&stale),\n            \"stale log_uuids should be pruned\"\n        );\n        assert!(\n            !app.uuid_retry_cooldowns.contains_key(&stale),\n            \"stale uuid_retry_cooldowns should be pruned\"\n        );\n        assert!(\n            !app.dead_ticks.contains_key(&stale),\n            \"stale dead_ticks should be pruned\"\n        );\n    }\n\n    // ── Revival: success resets failed_attempts ──────────────────\n\n    #[tokio::test]\n    async fn revive_sessions_success_resets_failed_attempts() {\n        let dir = tempfile::tempdir().unwrap();\n        let pid = \"testid\";\n        let mut manifest = crate::manifest::Manifest::default();\n        let mut record = make_manifest_record(\"alpha\", \"claude\");\n        record.failed_attempts = 2; // Previously failed twice\n        manifest.sessions.insert(\"alpha\".to_string(), record);\n        crate::manifest::save_manifest(dir.path(), pid, &manifest)\n            .await\n            .unwrap();\n\n        let mut app = App::new_with_manager(\n            pid.to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(MockSessionManager::new()),\n        );\n        app.manifest_dir = dir.path().to_path_buf();\n        app.revive_sessions().await;\n\n        // Verify failed_attempts was reset to 0\n        let loaded = crate::manifest::load_manifest(dir.path(), pid).await;\n        assert_eq!(\n            loaded.sessions[\"alpha\"].failed_attempts, 0,\n            \"successful revival should reset failed_attempts\"\n        );\n    }\n\n    // ── confirm_new_session success path ──────────────────────────\n\n    #[tokio::test]\n    async fn confirm_new_session_success_saves_manifest() {\n        let dir = tempfile::tempdir().unwrap();\n        let pid = \"testid\";\n\n        let mut app = App::new_with_manager(\n            pid.to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(MockSessionManager::new()),\n        );\n        app.manifest_dir = dir.path().to_path_buf();\n        app.mode = Mode::NewSessionAgent;\n        app.confirm_new_session().await;\n\n        assert_eq!(app.mode, Mode::Browse);\n        assert!(app\n            .status_message\n            .as_ref()\n            .unwrap()\n            .contains(\"Created session\"));\n\n        // Verify manifest was saved (name is auto-generated)\n        let loaded = crate::manifest::load_manifest(dir.path(), pid).await;\n        assert!(\n            !loaded.sessions.is_empty(),\n            \"manifest should have the new session\"\n        );\n    }\n\n    // ── confirm_delete success path ──────────────────────────────\n\n    #[tokio::test]\n    async fn confirm_delete_success_updates_manifest() {\n        let dir = tempfile::tempdir().unwrap();\n        let pid = \"testid\";\n\n        // Pre-populate manifest with a session\n        let mut manifest = crate::manifest::Manifest::default();\n        manifest\n            .sessions\n            .insert(\"s1\".to_string(), make_manifest_record(\"s1\", \"claude\"));\n        crate::manifest::save_manifest(dir.path(), pid, &manifest)\n            .await\n            .unwrap();\n\n        let sessions = vec![make_session(\"s1\", AgentType::Claude)];\n        let mut app = App::new_with_manager(\n            pid.to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(MockSessionManager::with_sessions(sessions.clone())),\n        );\n        app.manifest_dir = dir.path().to_path_buf();\n        app.sessions = sessions;\n        app.mode = Mode::ConfirmDelete;\n        app.confirm_delete().await;\n\n        assert_eq!(app.mode, Mode::Browse);\n        assert!(app\n            .status_message\n            .as_ref()\n            .unwrap()\n            .contains(\"Killed session\"));\n\n        // Verify manifest entry was removed\n        let loaded = crate::manifest::load_manifest(dir.path(), pid).await;\n        assert!(\n            !loaded.sessions.contains_key(\"s1\"),\n            \"session should be removed from manifest\"\n        );\n    }\n\n    // ── Mouse: scroll in preview scrolls viewport ────────────────\n\n    #[test]\n    fn mouse_scroll_preview_changes_offset() {\n        use crossterm::event::{MouseEvent, MouseEventKind};\n\n        let sessions = vec![make_session(\"a\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.sidebar_area.set(Rect::new(0, 0, 24, 20));\n        app.preview_area.set(Rect::new(24, 0, 56, 20));\n        assert_eq!(app.preview_scroll_offset, 0);\n\n        // Scroll up in preview\n        app.handle_mouse(MouseEvent {\n            kind: MouseEventKind::ScrollUp,\n            column: 40,\n            row: 10,\n            modifiers: crossterm::event::KeyModifiers::NONE,\n        });\n        assert!(app.preview_scroll_offset > 0);\n\n        let offset = app.preview_scroll_offset;\n\n        // Scroll down should decrease offset\n        app.handle_mouse(MouseEvent {\n            kind: MouseEventKind::ScrollDown,\n            column: 40,\n            row: 10,\n            modifiers: crossterm::event::KeyModifiers::NONE,\n        });\n        assert!(app.preview_scroll_offset < offset);\n    }\n\n    // ── Task timer: Running starts clock ─────────────────────────\n\n    #[tokio::test]\n    async fn refresh_sessions_running_starts_task_timer() {\n        let running_sessions = vec![Session {\n            name: \"worker\".to_string(),\n            tmux_name: \"hydra-testid-worker\".to_string(),\n            agent_type: AgentType::Claude,\n            status: SessionStatus::Running,\n            task_elapsed: None,\n            _alive: true,\n        }];\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(MockSessionManager::with_sessions(running_sessions)),\n        );\n        app.refresh_sessions().await;\n\n        let key = \"hydra-testid-worker\";\n        assert!(\n            app.task_starts.contains_key(key),\n            \"Running session should start task timer\"\n        );\n        assert!(\n            app.task_last_active.contains_key(key),\n            \"Running session should set last_active\"\n        );\n    }\n\n    // ── Task timer: Idle with recent activity keeps frozen timer ──\n\n    #[tokio::test]\n    async fn refresh_sessions_idle_recent_keeps_frozen_timer() {\n        let idle_sessions = vec![Session {\n            name: \"worker\".to_string(),\n            tmux_name: \"hydra-testid-worker\".to_string(),\n            agent_type: AgentType::Claude,\n            status: SessionStatus::Idle,\n            task_elapsed: None,\n            _alive: true,\n        }];\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(MockSessionManager::with_sessions(idle_sessions)),\n        );\n\n        let key = \"hydra-testid-worker\".to_string();\n        // Pre-populate task_starts and task_last_active with recent timestamps\n        let now = Instant::now();\n        app.task_starts.insert(key.clone(), now);\n        app.task_last_active.insert(key.clone(), now);\n\n        app.refresh_sessions().await;\n\n        // Timer should still be set (within 5s window)\n        assert!(\n            app.task_starts.contains_key(&key),\n            \"recent idle should keep task timer\"\n        );\n        // Session should have a task_elapsed value\n        assert!(\n            app.sessions[0].task_elapsed.is_some(),\n            \"idle within 5s should show frozen timer\"\n        );\n    }\n\n    // ── normalize_capture tests ─────────────────────────────────────\n\n    #[test]\n    fn normalize_capture_strips_braille_spinners() {\n        let input = \"Loading \\u{280B}\\u{2819}\\u{2839} done\";\n        let result = super::normalize_capture(input);\n        assert_eq!(result, \"Loading  done\");\n    }\n\n    #[test]\n    fn normalize_capture_strips_ansi_escapes() {\n        let input = \"hello \\x1b[31mred\\x1b[0m world\";\n        let result = super::normalize_capture(input);\n        assert_eq!(result, \"hello red world\");\n    }\n\n    #[test]\n    fn normalize_capture_trims_trailing_whitespace() {\n        let input = \"line one   \\nline two  \\n\";\n        let result = super::normalize_capture(input);\n        // lines() drops the trailing \\n, join produces no trailing newline\n        assert_eq!(result, \"line one\\nline two\");\n    }\n\n    #[test]\n    fn normalize_capture_preserves_normal_content() {\n        let input = \"$ claude\\nHello, how can I help?\";\n        let result = super::normalize_capture(input);\n        assert_eq!(result, input);\n    }\n\n    #[test]\n    fn normalize_capture_empty_string() {\n        assert_eq!(super::normalize_capture(\"\"), \"\");\n    }\n\n    #[test]\n    fn normalize_capture_combined_noise() {\n        // ANSI cursor move + braille spinner + trailing spaces\n        let input = \"\\x1b[2Kworking \\u{2807}   \";\n        let result = super::normalize_capture(input);\n        assert_eq!(result, \"working\");\n    }\n\n    // ── log-based idle acceleration tests ──────────────────────────\n\n    #[tokio::test]\n    async fn refresh_sessions_log_idle_accelerates_idle_detection() {\n        // When the log confirms the agent is idle (assistant replied),\n        // the idle threshold drops from 30 to 8 ticks for faster detection.\n        let sessions = vec![make_session(\"s1\", AgentType::Claude)];\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(MockSessionManager::with_sessions(sessions)),\n        );\n\n        // Inject stats where assistant has replied (task_elapsed = None = idle)\n        let mut stats = crate::logs::SessionStats::default();\n        let now = chrono::Utc::now();\n        stats.last_user_ts = Some(\n            (now - chrono::Duration::seconds(30))\n                .to_rfc3339_opts(chrono::SecondsFormat::Millis, true),\n        );\n        stats.last_assistant_ts = Some(\n            (now - chrono::Duration::seconds(10))\n                .to_rfc3339_opts(chrono::SecondsFormat::Millis, true),\n        );\n        app.session_stats\n            .insert(\"hydra-testid-s1\".to_string(), stats);\n\n        // First tick: first_capture → Running\n        app.refresh_sessions().await;\n        assert_eq!(app.sessions[0].status, SessionStatus::Running, \"tick 1\");\n\n        // Ticks 2-8: unchanged, but idle_ticks < 8\n        for i in 2..=8 {\n            app.refresh_sessions().await;\n            assert_eq!(app.sessions[0].status, SessionStatus::Running, \"tick {i}\");\n        }\n\n        // Tick 9: idle_ticks reaches 8, accelerated threshold met → Idle\n        app.refresh_sessions().await;\n        assert_eq!(\n            app.sessions[0].status,\n            SessionStatus::Idle,\n            \"tick 9: log_idle should accelerate to Idle at 8 ticks\"\n        );\n    }\n\n    #[tokio::test]\n    async fn refresh_sessions_no_log_uses_full_threshold() {\n        // Without log data, the full 30-tick threshold applies.\n        let sessions = vec![make_session(\"s1\", AgentType::Claude)];\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(MockSessionManager::with_sessions(sessions)),\n        );\n\n        // No session_stats → log_idle is false → threshold is 30\n\n        // First tick: first_capture → Running\n        app.refresh_sessions().await;\n        assert_eq!(app.sessions[0].status, SessionStatus::Running);\n\n        // At tick 9, should still be Running (threshold is 30, not 8)\n        for _ in 2..=9 {\n            app.refresh_sessions().await;\n        }\n        assert_eq!(\n            app.sessions[0].status,\n            SessionStatus::Running,\n            \"tick 9: without log data, still Running (need 30 ticks)\"\n        );\n\n        // At tick 31, should be Idle\n        for _ in 10..=31 {\n            app.refresh_sessions().await;\n        }\n        assert_eq!(\n            app.sessions[0].status,\n            SessionStatus::Idle,\n            \"tick 31: Idle after 30 unchanged\"\n        );\n    }\n\n    // ── changed_ticks → Running transition (Idle→Running needs 5 changed ticks) ──\n\n    #[tokio::test]\n    async fn refresh_sessions_changed_content_triggers_running_after_five_ticks() {\n        let sessions = vec![make_session(\"s1\", AgentType::Claude)];\n        let manager =\n            MockSessionManager::with_sessions(sessions).with_capture_fn(|n| format!(\"output {n}\"));\n\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(manager),\n        );\n\n        // First tick: first_capture → Running\n        app.refresh_sessions().await;\n        assert_eq!(\n            app.sessions[0].status,\n            SessionStatus::Running,\n            \"tick 1: first capture = Running\"\n        );\n\n        // Ticks 2-5: content changed, changed_ticks < 5 → keep Running (already Running from first capture)\n        for i in 2..=5 {\n            app.refresh_sessions().await;\n            assert_eq!(\n                app.sessions[0].status,\n                SessionStatus::Running,\n                \"tick {i}: keep current\"\n            );\n        }\n\n        // Tick 6: content changed again, changed_ticks=5 → Running confirmed\n        app.refresh_sessions().await;\n        assert_eq!(\n            app.sessions[0].status,\n            SessionStatus::Running,\n            \"tick 6: 5 changed ticks → Running\"\n        );\n    }\n\n    // ── changed_ticks resets idle_ticks and vice versa ──\n\n    #[tokio::test]\n    async fn refresh_sessions_changed_after_idle_resets_idle_ticks() {\n        let sessions = vec![make_session(\"s1\", AgentType::Claude)];\n        // First 32 calls return same content (to get to Idle),\n        // then alternate to trigger changed_ticks\n        let manager = MockSessionManager::with_sessions(sessions).with_capture_fn(|n| {\n            if n < 32 {\n                \"stable\".to_string()\n            } else {\n                format!(\"changing {n}\")\n            }\n        });\n\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(manager),\n        );\n\n        // Run 32 ticks to get to Idle (first capture = Running, then 30 unchanged = Idle)\n        for _ in 0..32 {\n            app.refresh_sessions().await;\n        }\n        assert_eq!(\n            app.sessions[0].status,\n            SessionStatus::Idle,\n            \"should be Idle after 32 ticks\"\n        );\n\n        // Now content changes — ticks 1-4: changed_ticks < 5, keep Idle (hysteresis)\n        for _ in 0..4 {\n            app.refresh_sessions().await;\n        }\n        assert_eq!(\n            app.sessions[0].status,\n            SessionStatus::Idle,\n            \"4 changed ticks: still Idle\"\n        );\n\n        // 5th consecutive change: changed_ticks=5 → Running\n        app.refresh_sessions().await;\n        assert_eq!(\n            app.sessions[0].status,\n            SessionStatus::Running,\n            \"5 changed ticks: flips to Running\"\n        );\n    }\n\n    #[tokio::test]\n    async fn refresh_sessions_codex_spinner_only_updates_stay_running() {\n        let sessions = vec![make_session(\"s1\", AgentType::Codex)];\n        let frames = [\n            \"\\u{280b}\", \"\\u{2819}\", \"\\u{2839}\", \"\\u{2838}\", \"\\u{283c}\", \"\\u{2834}\", \"\\u{2826}\",\n            \"\\u{2827}\", \"\\u{2807}\", \"\\u{280f}\",\n        ];\n        let manager = MockSessionManager::with_sessions(sessions)\n            .with_capture_fn(move |n| format!(\"thinking {}\", frames[n % frames.len()]));\n\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(manager),\n        );\n\n        for _ in 0..40 {\n            app.refresh_sessions().await;\n        }\n\n        assert_eq!(\n            app.sessions[0].status,\n            SessionStatus::Running,\n            \"Codex spinner-only activity should keep session Running\"\n        );\n    }\n\n    #[tokio::test]\n    async fn refresh_sessions_claude_spinner_only_updates_can_set_idle() {\n        let sessions = vec![make_session(\"s1\", AgentType::Claude)];\n        let frames = [\n            \"\\u{280b}\", \"\\u{2819}\", \"\\u{2839}\", \"\\u{2838}\", \"\\u{283c}\", \"\\u{2834}\", \"\\u{2826}\",\n            \"\\u{2827}\", \"\\u{2807}\", \"\\u{280f}\",\n        ];\n        let manager = MockSessionManager::with_sessions(sessions)\n            .with_capture_fn(move |n| format!(\"thinking {}\", frames[n % frames.len()]));\n\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(manager),\n        );\n\n        for _ in 0..31 {\n            app.refresh_sessions().await;\n        }\n\n        assert_eq!(\n            app.sessions[0].status,\n            SessionStatus::Idle,\n            \"Claude spinner-only noise remains ignored for Idle detection\"\n        );\n    }\n\n    // ── Preview skip optimization ──\n\n    #[tokio::test]\n    async fn refresh_preview_skips_when_idle_and_same_session() {\n        let sessions = vec![make_session(\"s1\", AgentType::Claude)];\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(MockSessionManager::with_sessions(sessions.clone())),\n        );\n        app.sessions = sessions;\n\n        // First call — captures preview\n        app.refresh_preview().await;\n        assert_eq!(app.preview_session.as_deref(), Some(\"hydra-testid-s1\"));\n        // Simulate idle_ticks >= 1 for the session\n        app.idle_ticks.insert(\"hydra-testid-s1\".to_string(), 1);\n\n        // Second call — should skip (same session, idle_ticks >= 1)\n        app.set_preview_text(\"modified\".to_string());\n        app.refresh_preview().await;\n        // If it skipped, preview remains \"modified\" (wasn't overwritten)\n        assert_eq!(\n            app.preview, \"modified\",\n            \"should skip capture when idle and same session\"\n        );\n\n        // Change selected session — should NOT skip\n        app.sessions.push(make_session(\"s2\", AgentType::Claude));\n        app.selected = 1;\n        app.refresh_preview().await;\n        assert_eq!(app.preview_session.as_deref(), Some(\"hydra-testid-s2\"));\n    }\n\n    // ── Preview skip does NOT skip when idle_ticks = 0 ──\n\n    #[tokio::test]\n    async fn refresh_preview_does_not_skip_when_idle_ticks_zero() {\n        let sessions = vec![make_session(\"s1\", AgentType::Claude)];\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(MockSessionManager::with_sessions(sessions.clone())),\n        );\n        app.sessions = sessions;\n\n        app.refresh_preview().await;\n        // idle_ticks = 0 (default), same session\n        app.set_preview_text(\"modified\".to_string());\n        app.refresh_preview().await;\n        // Should NOT skip, so preview is overwritten\n        assert_ne!(\n            app.preview, \"modified\",\n            \"should not skip when idle_ticks = 0\"\n        );\n    }\n\n    #[tokio::test]\n    async fn refresh_preview_uses_cached_pane_capture_from_refresh_sessions() {\n        use std::sync::atomic::Ordering;\n\n        let sessions = vec![make_session(\"s1\", AgentType::Claude)];\n        let manager = MockSessionManager::with_sessions(sessions)\n            .with_capture_fn(|_| \"pane-capture\".to_string());\n        let pane_calls = manager.capture_count.clone();\n        let scrollback_calls = manager.scrollback_count.clone();\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(manager),\n        );\n\n        app.refresh_sessions().await;\n        assert_eq!(\n            pane_calls.load(Ordering::SeqCst),\n            1,\n            \"refresh_sessions should capture pane once\"\n        );\n\n        app.refresh_preview().await;\n        assert_eq!(app.preview, \"pane-capture\");\n        assert_eq!(\n            pane_calls.load(Ordering::SeqCst),\n            1,\n            \"refresh_preview should reuse cached pane capture (no extra tmux call)\"\n        );\n        assert_eq!(\n            scrollback_calls.load(Ordering::SeqCst),\n            0,\n            \"live preview should not use scrollback capture\"\n        );\n    }\n\n    #[tokio::test]\n    async fn refresh_preview_scrollback_captured_once_while_scrolled() {\n        use std::sync::atomic::Ordering;\n\n        let sessions = vec![make_session(\"s1\", AgentType::Claude)];\n        let manager = MockSessionManager::with_sessions(sessions)\n            .with_capture_fn(|_| \"pane-capture\".to_string());\n        let pane_calls = manager.capture_count.clone();\n        let scrollback_calls = manager.scrollback_count.clone();\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(manager),\n        );\n\n        app.refresh_sessions().await;\n        app.refresh_preview().await;\n        assert_eq!(app.preview, \"pane-capture\");\n\n        app.preview_scroll_offset = 1;\n        app.refresh_preview().await;\n        assert_eq!(app.preview, \"mock pane content\"); // scrollback returns default\n        assert_eq!(\n            scrollback_calls.load(Ordering::SeqCst),\n            1,\n            \"first scroll-up should fetch scrollback once\"\n        );\n\n        // While still scrolled up in same session, preview should stay frozen.\n        app.set_preview_text(\"frozen\".to_string());\n        app.refresh_preview().await;\n        assert_eq!(\n            app.preview, \"frozen\",\n            \"scrolled history should not recapture every tick\"\n        );\n        assert_eq!(\n            scrollback_calls.load(Ordering::SeqCst),\n            1,\n            \"no extra scrollback captures while inspecting history\"\n        );\n\n        // Returning to bottom should switch back to live pane path.\n        app.preview_scroll_offset = 0;\n        app.refresh_preview().await;\n        assert_eq!(app.preview, \"pane-capture\");\n        assert_eq!(\n            pane_calls.load(Ordering::SeqCst),\n            1,\n            \"should reuse cached pane capture when returning to live view\"\n        );\n    }\n\n    // ── flush_pending_keys ──\n\n    #[tokio::test]\n    async fn flush_pending_keys_sends_and_clears() {\n        let manager = MockSessionManager::new();\n        let sent = manager.sent_literals.clone();\n\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(manager),\n        );\n\n        // Queue pending keys\n        app.pending_literal_keys = Some((\"hydra-testid-s1\".to_string(), \"hello\".to_string()));\n        app.flush_pending_keys().await;\n\n        let calls = sent.lock().unwrap();\n        assert_eq!(calls.len(), 1);\n        assert_eq!(calls[0].0, \"hydra-testid-s1\");\n        assert_eq!(calls[0].1, \"hello\");\n        drop(calls);\n\n        // Should be cleared after flush\n        assert!(app.pending_literal_keys.is_none());\n    }\n\n    #[tokio::test]\n    async fn flush_pending_keys_noop_when_empty() {\n        let mut app = test_app();\n        // No pending keys — should not panic\n        app.flush_pending_keys().await;\n        assert!(app.pending_literal_keys.is_none());\n    }\n\n    // ── Mouse events in Attached mode ──\n\n    #[test]\n    fn mouse_right_click_outside_preview_detaches() {\n        let sessions = vec![make_session(\"s1\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.mode = Mode::Attached;\n\n        app.sidebar_area.set(Rect::new(0, 0, 30, 24));\n        app.preview_area.set(Rect::new(30, 0, 50, 24));\n\n        // Right-click in sidebar (outside preview) — triggers Down(_) catch-all\n        let mouse = MouseEvent {\n            kind: MouseEventKind::Down(MouseButton::Right),\n            column: 5,\n            row: 5,\n            modifiers: crossterm::event::KeyModifiers::NONE,\n        };\n        app.handle_mouse(mouse);\n        assert_eq!(\n            app.mode,\n            Mode::Browse,\n            \"right-click outside preview should detach\"\n        );\n    }\n\n    #[test]\n    fn mouse_left_click_outside_preview_detaches() {\n        let sessions = vec![make_session(\"s1\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.mode = Mode::Attached;\n\n        app.sidebar_area.set(Rect::new(0, 0, 30, 24));\n        app.preview_area.set(Rect::new(30, 0, 50, 24));\n\n        // Left-click in sidebar (outside preview inner) — triggers detach\n        let mouse = MouseEvent {\n            kind: MouseEventKind::Down(MouseButton::Left),\n            column: 5,\n            row: 5,\n            modifiers: crossterm::event::KeyModifiers::NONE,\n        };\n        app.handle_mouse(mouse);\n        assert_eq!(\n            app.mode,\n            Mode::Browse,\n            \"left-click outside preview should detach\"\n        );\n    }\n\n    #[test]\n    fn mouse_left_click_inside_preview_does_not_forward() {\n        let sessions = vec![make_session(\"s1\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.mode = Mode::Attached;\n\n        app.sidebar_area.set(Rect::new(0, 0, 30, 24));\n        app.preview_area.set(Rect::new(30, 0, 50, 24));\n\n        let mouse = MouseEvent {\n            kind: MouseEventKind::Down(MouseButton::Left),\n            column: 40, // inside inner preview\n            row: 5,\n            modifiers: crossterm::event::KeyModifiers::NONE,\n        };\n        app.handle_mouse(mouse);\n        assert_eq!(\n            app.mode,\n            Mode::Attached,\n            \"left-click inside preview stays attached\"\n        );\n        assert!(\n            app.pending_literal_keys.is_none(),\n            \"should not forward mouse clicks to agents\"\n        );\n        assert_eq!(\n            app.preview_scroll_offset, 0,\n            \"should reset scroll to bottom\"\n        );\n    }\n\n    #[test]\n    fn mouse_right_click_inside_preview_stays_attached() {\n        let sessions = vec![make_session(\"s1\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.mode = Mode::Attached;\n\n        app.sidebar_area.set(Rect::new(0, 0, 30, 24));\n        app.preview_area.set(Rect::new(30, 0, 50, 24));\n\n        // Right-click inside preview inner — Down(_) catch-all, inner.contains(pos) = true → no detach\n        let mouse = MouseEvent {\n            kind: MouseEventKind::Down(MouseButton::Right),\n            column: 40,\n            row: 5,\n            modifiers: crossterm::event::KeyModifiers::NONE,\n        };\n        app.handle_mouse(mouse);\n        assert_eq!(\n            app.mode,\n            Mode::Attached,\n            \"right-click inside preview stays attached\"\n        );\n    }\n\n    // ── log_elapsed used in Idle status when log says working ──\n\n    #[tokio::test]\n    async fn refresh_sessions_log_elapsed_used_in_idle_status() {\n        let sessions = vec![make_session(\"s1\", AgentType::Claude)];\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(MockSessionManager::with_sessions(sessions)),\n        );\n\n        // Set up stats where user asked something recently but no assistant reply yet\n        // (task_elapsed() returns Some when last_user > last_assistant)\n        let mut stats = crate::logs::SessionStats::default();\n        let now = chrono::Utc::now();\n        stats.last_user_ts = Some(\n            (now - chrono::Duration::seconds(5))\n                .to_rfc3339_opts(chrono::SecondsFormat::Millis, true),\n        );\n        // No assistant reply → task_elapsed() returns Some(duration)\n        app.session_stats\n            .insert(\"hydra-testid-s1\".to_string(), stats);\n\n        // Run enough ticks to get to Idle (32 ticks: 1 first_capture + 30 unchanged + 1 to cross threshold)\n        // Because stats say log_idle=false (task_elapsed is Some), threshold is 30\n        for _ in 0..32 {\n            app.refresh_sessions().await;\n        }\n\n        // Session should be Idle now (pane is unchanged)\n        assert_eq!(app.sessions[0].status, SessionStatus::Idle);\n\n        // But since log_elapsed is Some, the task_elapsed should reflect log data\n        // (The session has task_elapsed = log_elapsed because the log says agent is working)\n        assert!(\n            app.sessions[0].task_elapsed.is_some(),\n            \"log_elapsed should be used for Idle status\"\n        );\n    }\n\n    // ── normalize_capture: ESC without bracket ──\n\n    #[test]\n    fn normalize_capture_bare_esc_skipped() {\n        // ESC not followed by '[' — should skip just the ESC\n        let input = \"\\x1bother text\";\n        let result = super::normalize_capture(input);\n        assert_eq!(result, \"other text\");\n    }\n\n    // ── parse_diff_numstat: tab in path ─────────────────────────────\n\n    #[test]\n    fn parse_diff_numstat_tab_in_path() {\n        // git numstat uses tabs to separate fields; a tab inside the path\n        // would split incorrectly. We only take the first field after the\n        // second tab, so the rest is lost. This test documents the behavior.\n        let out = \"10\\t5\\tpath\\twith\\ttabs\\n\";\n        let files = super::parse_diff_numstat(out);\n        // The parser splits on \\t and takes .next() for path, so it gets \"path\"\n        assert_eq!(files.len(), 1);\n        assert_eq!(files[0].path, \"path\");\n    }\n\n    // ── MAX_DIFF_FILES constant ─────────────────────────────────────\n\n    #[test]\n    fn max_diff_files_constant_is_200() {\n        assert_eq!(super::MAX_DIFF_FILES, 200);\n    }\n\n    // ── confirm_new_session: manifest save warning ──────────────────\n\n    #[tokio::test]\n    async fn confirm_new_session_manifest_save_failure_shows_warning() {\n        // Use a path where the manifest dir is inside a file (not a dir) to force save error\n        let dir = tempfile::tempdir().unwrap();\n        let blocking_file = dir.path().join(\"blockerdir\");\n        std::fs::write(&blocking_file, \"I am a file, not a dir\").unwrap();\n\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(MockSessionManager::new()),\n        );\n        // manifest_dir points to a file → mkdir_all will fail → add_session returns Err\n        app.manifest_dir = blocking_file;\n        app.mode = Mode::NewSessionAgent;\n        app.confirm_new_session().await;\n\n        assert_eq!(app.mode, Mode::Browse);\n        let msg = app.status_message.as_ref().unwrap();\n        assert!(\n            msg.contains(\"Created session\"),\n            \"should still report creation: {msg}\"\n        );\n        assert!(\n            msg.contains(\"warning: manifest save failed\"),\n            \"should include warning: {msg}\"\n        );\n    }\n\n    // ── confirm_delete: manifest removal warning ────────────────────\n\n    #[tokio::test]\n    async fn confirm_delete_manifest_removal_failure_shows_warning() {\n        // manifest_dir points to a file → manifest operations will fail\n        let dir = tempfile::tempdir().unwrap();\n        let blocking_file = dir.path().join(\"blockerdir\");\n        std::fs::write(&blocking_file, \"I am a file\").unwrap();\n\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(MockSessionManager::new()),\n        );\n        app.manifest_dir = blocking_file;\n        app.sessions = vec![make_session(\"s1\", AgentType::Claude)];\n        app.mode = Mode::ConfirmDelete;\n        app.confirm_delete().await;\n\n        assert_eq!(app.mode, Mode::Browse);\n        let msg = app.status_message.as_ref().unwrap();\n        assert!(msg.contains(\"Killed session\"), \"should report kill: {msg}\");\n        assert!(\n            msg.contains(\"warning: manifest update failed\"),\n            \"should include warning: {msg}\"\n        );\n    }\n\n    // ── Browse key 'c' toggles mouse_captured ──\n\n    #[test]\n    fn browse_key_c_toggles_mouse_capture() {\n        let mut app = test_app();\n        assert!(app.mouse_captured, \"default should be true\");\n        app.handle_browse_key(KeyCode::Char('c'));\n        assert!(!app.mouse_captured, \"first 'c' should disable capture\");\n        app.handle_browse_key(KeyCode::Char('c'));\n        assert!(app.mouse_captured, \"second 'c' should re-enable capture\");\n    }\n\n    // ── confirm_new_session selects the newly created session by index ──\n\n    #[tokio::test]\n    async fn confirm_new_session_sets_selected_to_new_session_index() {\n        // Pre-populate mock with both \"alpha\" and \"bravo\" so that after\n        // create + refresh_sessions, the new session \"bravo\" is found in the list.\n        let sessions = vec![\n            make_session(\"alpha\", AgentType::Claude),\n            make_session(\"bravo\", AgentType::Claude),\n        ];\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(MockSessionManager::with_sessions(sessions)),\n        );\n        app.manifest_dir = std::env::temp_dir()\n            .join(\"hydra-test\")\n            .join(format!(\"{:?}\", std::thread::current().id()));\n        // app.sessions only has \"alpha\" → generate_name picks \"bravo\"\n        app.sessions = vec![make_session(\"alpha\", AgentType::Claude)];\n        app.mode = Mode::NewSessionAgent;\n        app.agent_selection = 0;\n\n        app.confirm_new_session().await;\n\n        assert_eq!(app.mode, Mode::Browse);\n        // After refresh_sessions, sessions = [\"alpha\", \"bravo\"].\n        // \"bravo\" is at index 1, so selected should be 1.\n        assert_eq!(\n            app.selected, 1,\n            \"selected should point to newly created session\"\n        );\n    }\n\n    // ── refresh_preview scrollback error shows error message ──\n\n    #[tokio::test]\n    async fn refresh_preview_scrollback_error_shows_error() {\n        let mut mock = MockSessionManager::new();\n        mock.scrollback_result = Some(Err(\"scrollback failed\".to_string()));\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(mock),\n        );\n        app.sessions = vec![make_session(\"s1\", AgentType::Claude)];\n        app.preview_scroll_offset = 5; // trigger scrollback path\n        app.refresh_preview().await;\n        assert_eq!(app.preview, \"[unable to capture pane]\");\n    }\n\n    // ── Dead-tick debounce tests ─────────────────────────────────────\n\n    #[tokio::test]\n    async fn refresh_sessions_single_dead_tick_does_not_mark_exited() {\n        let exited = make_session_with_status(\"s1\", AgentType::Claude, SessionStatus::Exited);\n        let manager = MockSessionManager::with_sessions(vec![exited]);\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(manager),\n        );\n\n        // Single dead tick should NOT mark Exited (debounce threshold = 3)\n        app.refresh_sessions().await;\n        assert_ne!(\n            app.sessions[0].status,\n            SessionStatus::Exited,\n            \"single dead tick should not mark Exited\"\n        );\n    }\n\n    #[tokio::test]\n    async fn refresh_sessions_consecutive_dead_ticks_marks_exited() {\n        let exited = make_session_with_status(\"s1\", AgentType::Claude, SessionStatus::Exited);\n        let manager = MockSessionManager::with_sessions(vec![exited]);\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(manager),\n        );\n\n        // Run DEAD_TICK_THRESHOLD consecutive dead ticks → should be Exited\n        for _ in 0..App::DEAD_TICK_THRESHOLD {\n            app.refresh_sessions().await;\n        }\n        assert_eq!(\n            app.sessions[0].status,\n            SessionStatus::Exited,\n            \"consecutive dead ticks at threshold should mark Exited\"\n        );\n    }\n\n    #[tokio::test]\n    async fn refresh_sessions_dead_ticks_reset_on_alive() {\n        // Session starts as Exited for 2 ticks, then becomes alive, then dead again\n        let exited = make_session_with_status(\"s1\", AgentType::Claude, SessionStatus::Exited);\n        let alive = make_session_with_status(\"s1\", AgentType::Claude, SessionStatus::Idle);\n        let manager = MockSessionManager::new().with_list_fn(move |n| match n {\n            0 | 1 => vec![exited.clone()],\n            2 => vec![alive.clone()],\n            _ => vec![exited.clone()],\n        });\n\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(manager),\n        );\n\n        // 2 dead ticks (below threshold)\n        app.refresh_sessions().await;\n        app.refresh_sessions().await;\n        assert_ne!(app.sessions[0].status, SessionStatus::Exited);\n\n        // 1 alive tick — resets dead_ticks counter\n        app.refresh_sessions().await;\n        assert_eq!(\n            app.dead_ticks\n                .get(\"hydra-testid-s1\")\n                .copied()\n                .unwrap_or(0),\n            0,\n            \"alive tick should reset dead_ticks counter\"\n        );\n\n        // 1 dead tick after reset — should NOT be Exited\n        app.refresh_sessions().await;\n        assert_ne!(\n            app.sessions[0].status,\n            SessionStatus::Exited,\n            \"single dead tick after reset should not mark Exited\"\n        );\n    }\n\n    #[tokio::test]\n    async fn refresh_sessions_exited_recovery_clears_caches() {\n        // Session starts as Exited (passed debounce), then becomes alive\n        let exited = make_session_with_status(\"s1\", AgentType::Claude, SessionStatus::Exited);\n        let alive = make_session_with_status(\"s1\", AgentType::Claude, SessionStatus::Idle);\n        let manager = MockSessionManager::new().with_list_fn({\n            let threshold = App::DEAD_TICK_THRESHOLD as usize;\n            move |n| {\n                if n < threshold {\n                    vec![exited.clone()]\n                } else {\n                    vec![alive.clone()]\n                }\n            }\n        });\n\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(manager),\n        );\n\n        // Pass debounce threshold to confirm Exited\n        for _ in 0..App::DEAD_TICK_THRESHOLD {\n            app.refresh_sessions().await;\n        }\n        assert_eq!(app.sessions[0].status, SessionStatus::Exited);\n\n        // Pre-populate caches to verify they get cleared on recovery\n        let key = \"hydra-testid-s1\".to_string();\n        app.prev_captures.insert(key.clone(), \"old\".into());\n        app.raw_captures.insert(key.clone(), \"old\".into());\n        app.idle_ticks.insert(key.clone(), 10);\n        app.changed_ticks.insert(key.clone(), 5);\n\n        // Session comes back alive — Exited→alive transition should clear caches\n        app.refresh_sessions().await;\n        assert_ne!(\n            app.sessions[0].status,\n            SessionStatus::Exited,\n            \"session should recover from Exited\"\n        );\n        // First capture on recovery should set Running\n        assert_eq!(\n            app.sessions[0].status,\n            SessionStatus::Running,\n            \"first capture after recovery should be Running\"\n        );\n    }\n\n    #[tokio::test]\n    async fn refresh_sessions_active_subagents_forces_running_when_idle() {\n        let sessions = vec![make_session(\"s1\", AgentType::Claude)];\n        let manager = MockSessionManager::with_sessions(sessions);\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(manager),\n        );\n\n        // Inject active subagents into session stats\n        let key = \"hydra-testid-s1\".to_string();\n        let mut stats = SessionStats::default();\n        stats.active_subagents = 2;\n        app.session_stats.insert(key.clone(), stats);\n\n        // Run enough ticks to normally trigger Idle (1 first-capture + 30 unchanged)\n        for _ in 0..40 {\n            app.refresh_sessions().await;\n        }\n\n        // With active subagents, session should stay Running despite unchanged content\n        assert_eq!(\n            app.sessions[0].status,\n            SessionStatus::Running,\n            \"active subagents should force Running even with unchanged content\"\n        );\n    }\n\n    #[tokio::test]\n    async fn refresh_sessions_active_subagents_extends_dead_threshold() {\n        let exited = make_session_with_status(\"s1\", AgentType::Claude, SessionStatus::Exited);\n        let manager = MockSessionManager::with_sessions(vec![exited]);\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(manager),\n        );\n\n        // Inject active subagents\n        let key = \"hydra-testid-s1\".to_string();\n        let mut stats = SessionStats::default();\n        stats.active_subagents = 1;\n        app.session_stats.insert(key, stats);\n\n        // Run up to normal threshold — should NOT be Exited due to subagent extension\n        for _ in 0..App::DEAD_TICK_THRESHOLD {\n            app.refresh_sessions().await;\n        }\n        assert_ne!(\n            app.sessions[0].status,\n            SessionStatus::Exited,\n            \"active subagents should extend dead threshold\"\n        );\n\n        // Run up to subagent threshold → should be Exited\n        for _ in App::DEAD_TICK_THRESHOLD..App::DEAD_TICK_SUBAGENT_THRESHOLD {\n            app.refresh_sessions().await;\n        }\n        assert_eq!(\n            app.sessions[0].status,\n            SessionStatus::Exited,\n            \"should mark Exited after extended subagent threshold\"\n        );\n    }\n}\n","traces":[{"line":93,"address":[],"length":0,"stats":{"Line":1}},{"line":94,"address":[],"length":0,"stats":{"Line":4}},{"line":97,"address":[],"length":0,"stats":{"Line":168}},{"line":103,"address":[],"length":0,"stats":{"Line":336}},{"line":105,"address":[],"length":0,"stats":{"Line":336}},{"line":114,"address":[],"length":0,"stats":{"Line":504}},{"line":115,"address":[],"length":0,"stats":{"Line":504}},{"line":117,"address":[],"length":0,"stats":{"Line":336}},{"line":118,"address":[],"length":0,"stats":{"Line":336}},{"line":119,"address":[],"length":0,"stats":{"Line":336}},{"line":120,"address":[],"length":0,"stats":{"Line":336}},{"line":121,"address":[],"length":0,"stats":{"Line":336}},{"line":122,"address":[],"length":0,"stats":{"Line":336}},{"line":123,"address":[],"length":0,"stats":{"Line":336}},{"line":124,"address":[],"length":0,"stats":{"Line":336}},{"line":125,"address":[],"length":0,"stats":{"Line":336}},{"line":126,"address":[],"length":0,"stats":{"Line":336}},{"line":127,"address":[],"length":0,"stats":{"Line":336}},{"line":128,"address":[],"length":0,"stats":{"Line":336}},{"line":129,"address":[],"length":0,"stats":{"Line":336}},{"line":130,"address":[],"length":0,"stats":{"Line":336}},{"line":132,"address":[],"length":0,"stats":{"Line":336}},{"line":137,"address":[],"length":0,"stats":{"Line":336}},{"line":142,"address":[],"length":0,"stats":{"Line":12}},{"line":143,"address":[],"length":0,"stats":{"Line":12}},{"line":144,"address":[],"length":0,"stats":{"Line":24}},{"line":145,"address":[],"length":0,"stats":{"Line":12}},{"line":149,"address":[],"length":0,"stats":{"Line":15}},{"line":150,"address":[],"length":0,"stats":{"Line":15}},{"line":151,"address":[],"length":0,"stats":{"Line":30}},{"line":154,"address":[],"length":0,"stats":{"Line":686}},{"line":155,"address":[],"length":0,"stats":{"Line":1029}},{"line":156,"address":[],"length":0,"stats":{"Line":1372}},{"line":157,"address":[],"length":0,"stats":{"Line":343}},{"line":158,"address":[],"length":0,"stats":{"Line":342}},{"line":159,"address":[],"length":0,"stats":{"Line":684}},{"line":160,"address":[],"length":0,"stats":{"Line":1026}},{"line":161,"address":[],"length":0,"stats":{"Line":342}},{"line":163,"address":[],"length":0,"stats":{"Line":1590}},{"line":168,"address":[],"length":0,"stats":{"Line":1026}},{"line":170,"address":[],"length":0,"stats":{"Line":1020}},{"line":171,"address":[],"length":0,"stats":{"Line":964}},{"line":173,"address":[],"length":0,"stats":{"Line":1368}},{"line":174,"address":[],"length":0,"stats":{"Line":1026}},{"line":176,"address":[],"length":0,"stats":{"Line":684}},{"line":177,"address":[],"length":0,"stats":{"Line":1275}},{"line":180,"address":[],"length":0,"stats":{"Line":681}},{"line":181,"address":[],"length":0,"stats":{"Line":1017}},{"line":183,"address":[],"length":0,"stats":{"Line":678}},{"line":184,"address":[],"length":0,"stats":{"Line":339}},{"line":185,"address":[],"length":0,"stats":{"Line":678}},{"line":186,"address":[],"length":0,"stats":{"Line":435}},{"line":192,"address":[],"length":0,"stats":{"Line":339}},{"line":193,"address":[],"length":0,"stats":{"Line":168}},{"line":194,"address":[],"length":0,"stats":{"Line":28}},{"line":195,"address":[],"length":0,"stats":{"Line":56}},{"line":196,"address":[],"length":0,"stats":{"Line":15}},{"line":198,"address":[],"length":0,"stats":{"Line":13}},{"line":200,"address":[],"length":0,"stats":{"Line":28}},{"line":202,"address":[],"length":0,"stats":{"Line":24}},{"line":203,"address":[],"length":0,"stats":{"Line":48}},{"line":204,"address":[],"length":0,"stats":{"Line":60}},{"line":205,"address":[],"length":0,"stats":{"Line":24}},{"line":206,"address":[],"length":0,"stats":{"Line":48}},{"line":209,"address":[],"length":0,"stats":{"Line":933}},{"line":215,"address":[],"length":0,"stats":{"Line":988}},{"line":216,"address":[],"length":0,"stats":{"Line":314}},{"line":218,"address":[],"length":0,"stats":{"Line":311}},{"line":220,"address":[],"length":0,"stats":{"Line":4}},{"line":221,"address":[],"length":0,"stats":{"Line":4}},{"line":222,"address":[],"length":0,"stats":{"Line":4}},{"line":223,"address":[],"length":0,"stats":{"Line":2}},{"line":228,"address":[],"length":0,"stats":{"Line":305}},{"line":248,"address":[],"length":0,"stats":{"Line":678}},{"line":249,"address":[],"length":0,"stats":{"Line":339}},{"line":250,"address":[],"length":0,"stats":{"Line":678}},{"line":251,"address":[],"length":0,"stats":{"Line":531}},{"line":253,"address":[],"length":0,"stats":{"Line":1356}},{"line":255,"address":[],"length":0,"stats":{"Line":989}},{"line":256,"address":[],"length":0,"stats":{"Line":1244}},{"line":257,"address":[],"length":0,"stats":{"Line":933}},{"line":258,"address":[],"length":0,"stats":{"Line":901}},{"line":259,"address":[],"length":0,"stats":{"Line":1866}},{"line":263,"address":[],"length":0,"stats":{"Line":933}},{"line":264,"address":[],"length":0,"stats":{"Line":200}},{"line":266,"address":[],"length":0,"stats":{"Line":333}},{"line":267,"address":[],"length":0,"stats":{"Line":444}},{"line":268,"address":[],"length":0,"stats":{"Line":491}},{"line":269,"address":[],"length":0,"stats":{"Line":555}},{"line":270,"address":[],"length":0,"stats":{"Line":111}},{"line":276,"address":[],"length":0,"stats":{"Line":622}},{"line":277,"address":[],"length":0,"stats":{"Line":269}},{"line":278,"address":[],"length":0,"stats":{"Line":39}},{"line":280,"address":[],"length":0,"stats":{"Line":343}},{"line":282,"address":[],"length":0,"stats":{"Line":32}},{"line":283,"address":[],"length":0,"stats":{"Line":311}},{"line":284,"address":[],"length":0,"stats":{"Line":1380}},{"line":285,"address":[],"length":0,"stats":{"Line":230}},{"line":286,"address":[],"length":0,"stats":{"Line":920}},{"line":288,"address":[],"length":0,"stats":{"Line":269}},{"line":289,"address":[],"length":0,"stats":{"Line":39}},{"line":290,"address":[],"length":0,"stats":{"Line":240}},{"line":291,"address":[],"length":0,"stats":{"Line":10}},{"line":295,"address":[],"length":0,"stats":{"Line":294}},{"line":296,"address":[],"length":0,"stats":{"Line":49}},{"line":297,"address":[],"length":0,"stats":{"Line":196}},{"line":299,"address":[],"length":0,"stats":{"Line":86}},{"line":300,"address":[],"length":0,"stats":{"Line":37}},{"line":309,"address":[],"length":0,"stats":{"Line":678}},{"line":310,"address":[],"length":0,"stats":{"Line":339}},{"line":311,"address":[],"length":0,"stats":{"Line":678}},{"line":312,"address":[],"length":0,"stats":{"Line":531}},{"line":314,"address":[],"length":0,"stats":{"Line":339}},{"line":316,"address":[],"length":0,"stats":{"Line":1788}},{"line":317,"address":[],"length":0,"stats":{"Line":1490}},{"line":319,"address":[],"length":0,"stats":{"Line":864}},{"line":320,"address":[],"length":0,"stats":{"Line":536}},{"line":321,"address":[],"length":0,"stats":{"Line":536}},{"line":326,"address":[],"length":0,"stats":{"Line":76}},{"line":327,"address":[],"length":0,"stats":{"Line":2}},{"line":328,"address":[],"length":0,"stats":{"Line":30}},{"line":329,"address":[],"length":0,"stats":{"Line":105}},{"line":330,"address":[],"length":0,"stats":{"Line":105}},{"line":332,"address":[],"length":0,"stats":{"Line":41}},{"line":333,"address":[],"length":0,"stats":{"Line":26}},{"line":335,"address":[],"length":0,"stats":{"Line":4}},{"line":336,"address":[],"length":0,"stats":{"Line":2}},{"line":340,"address":[],"length":0,"stats":{"Line":4}},{"line":341,"address":[],"length":0,"stats":{"Line":16}},{"line":342,"address":[],"length":0,"stats":{"Line":8}},{"line":347,"address":[],"length":0,"stats":{"Line":1026}},{"line":348,"address":[],"length":0,"stats":{"Line":684}},{"line":349,"address":[],"length":0,"stats":{"Line":342}},{"line":350,"address":[],"length":0,"stats":{"Line":964}},{"line":355,"address":[],"length":0,"stats":{"Line":691}},{"line":356,"address":[],"length":0,"stats":{"Line":7}},{"line":357,"address":[],"length":0,"stats":{"Line":7}},{"line":358,"address":[],"length":0,"stats":{"Line":14}},{"line":359,"address":[],"length":0,"stats":{"Line":28}},{"line":363,"address":[],"length":0,"stats":{"Line":684}},{"line":364,"address":[],"length":0,"stats":{"Line":684}},{"line":367,"address":[],"length":0,"stats":{"Line":653}},{"line":368,"address":[],"length":0,"stats":{"Line":1860}},{"line":369,"address":[],"length":0,"stats":{"Line":309}},{"line":373,"address":[],"length":0,"stats":{"Line":2}},{"line":374,"address":[],"length":0,"stats":{"Line":3}},{"line":375,"address":[],"length":0,"stats":{"Line":1}},{"line":381,"address":[],"length":0,"stats":{"Line":686}},{"line":382,"address":[],"length":0,"stats":{"Line":1029}},{"line":383,"address":[],"length":0,"stats":{"Line":1625}},{"line":384,"address":[],"length":0,"stats":{"Line":1622}},{"line":385,"address":[],"length":0,"stats":{"Line":1526}},{"line":386,"address":[],"length":0,"stats":{"Line":1526}},{"line":387,"address":[],"length":0,"stats":{"Line":1706}},{"line":388,"address":[],"length":0,"stats":{"Line":1628}},{"line":389,"address":[],"length":0,"stats":{"Line":1628}},{"line":390,"address":[],"length":0,"stats":{"Line":689}},{"line":391,"address":[],"length":0,"stats":{"Line":977}},{"line":392,"address":[],"length":0,"stats":{"Line":689}},{"line":393,"address":[],"length":0,"stats":{"Line":689}},{"line":394,"address":[],"length":0,"stats":{"Line":343}},{"line":395,"address":[],"length":0,"stats":{"Line":1276}},{"line":399,"address":[],"length":0,"stats":{"Line":696}},{"line":400,"address":[],"length":0,"stats":{"Line":10}},{"line":401,"address":[],"length":0,"stats":{"Line":677}},{"line":402,"address":[],"length":0,"stats":{"Line":1}},{"line":406,"address":[],"length":0,"stats":{"Line":28}},{"line":407,"address":[],"length":0,"stats":{"Line":42}},{"line":408,"address":[],"length":0,"stats":{"Line":28}},{"line":409,"address":[],"length":0,"stats":{"Line":14}},{"line":410,"address":[],"length":0,"stats":{"Line":40}},{"line":411,"address":[],"length":0,"stats":{"Line":27}},{"line":412,"address":[],"length":0,"stats":{"Line":26}},{"line":413,"address":[],"length":0,"stats":{"Line":26}},{"line":417,"address":[],"length":0,"stats":{"Line":20}},{"line":418,"address":[],"length":0,"stats":{"Line":1}},{"line":422,"address":[],"length":0,"stats":{"Line":12}},{"line":423,"address":[],"length":0,"stats":{"Line":4}},{"line":424,"address":[],"length":0,"stats":{"Line":3}},{"line":425,"address":[],"length":0,"stats":{"Line":8}},{"line":427,"address":[],"length":0,"stats":{"Line":1}},{"line":430,"address":[],"length":0,"stats":{"Line":11}},{"line":431,"address":[],"length":0,"stats":{"Line":8}},{"line":432,"address":[],"length":0,"stats":{"Line":2}},{"line":433,"address":[],"length":0,"stats":{"Line":4}},{"line":435,"address":[],"length":0,"stats":{"Line":3}},{"line":438,"address":[],"length":0,"stats":{"Line":24}},{"line":439,"address":[],"length":0,"stats":{"Line":9}},{"line":441,"address":[],"length":0,"stats":{"Line":24}},{"line":442,"address":[],"length":0,"stats":{"Line":6}},{"line":443,"address":[],"length":0,"stats":{"Line":20}},{"line":445,"address":[],"length":0,"stats":{"Line":3}},{"line":449,"address":[],"length":0,"stats":{"Line":22}},{"line":451,"address":[],"length":0,"stats":{"Line":4}},{"line":452,"address":[],"length":0,"stats":{"Line":1}},{"line":459,"address":[],"length":0,"stats":{"Line":7}},{"line":461,"address":[],"length":0,"stats":{"Line":11}},{"line":462,"address":[],"length":0,"stats":{"Line":8}},{"line":463,"address":[],"length":0,"stats":{"Line":2}},{"line":464,"address":[],"length":0,"stats":{"Line":4}},{"line":465,"address":[],"length":0,"stats":{"Line":3}},{"line":466,"address":[],"length":0,"stats":{"Line":4}},{"line":467,"address":[],"length":0,"stats":{"Line":3}},{"line":468,"address":[],"length":0,"stats":{"Line":3}},{"line":469,"address":[],"length":0,"stats":{"Line":1}},{"line":471,"address":[],"length":0,"stats":{"Line":2}},{"line":473,"address":[],"length":0,"stats":{"Line":2}},{"line":475,"address":[],"length":0,"stats":{"Line":1}},{"line":481,"address":[],"length":0,"stats":{"Line":7}},{"line":483,"address":[],"length":0,"stats":{"Line":7}},{"line":484,"address":[],"length":0,"stats":{"Line":5}},{"line":488,"address":[],"length":0,"stats":{"Line":4}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":10}},{"line":494,"address":[],"length":0,"stats":{"Line":6}},{"line":495,"address":[],"length":0,"stats":{"Line":6}},{"line":496,"address":[],"length":0,"stats":{"Line":6}},{"line":497,"address":[],"length":0,"stats":{"Line":6}},{"line":498,"address":[],"length":0,"stats":{"Line":6}},{"line":500,"address":[],"length":0,"stats":{"Line":6}},{"line":501,"address":[],"length":0,"stats":{"Line":4}},{"line":503,"address":[],"length":0,"stats":{"Line":2}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":10}},{"line":519,"address":[],"length":0,"stats":{"Line":18}},{"line":520,"address":[],"length":0,"stats":{"Line":24}},{"line":521,"address":[],"length":0,"stats":{"Line":16}},{"line":522,"address":[],"length":0,"stats":{"Line":16}},{"line":523,"address":[],"length":0,"stats":{"Line":8}},{"line":527,"address":[],"length":0,"stats":{"Line":9}},{"line":528,"address":[],"length":0,"stats":{"Line":9}},{"line":529,"address":[],"length":0,"stats":{"Line":8}},{"line":530,"address":[],"length":0,"stats":{"Line":2}},{"line":532,"address":[],"length":0,"stats":{"Line":6}},{"line":534,"address":[],"length":0,"stats":{"Line":8}},{"line":535,"address":[],"length":0,"stats":{"Line":16}},{"line":536,"address":[],"length":0,"stats":{"Line":8}},{"line":540,"address":[],"length":0,"stats":{"Line":6}},{"line":541,"address":[],"length":0,"stats":{"Line":6}},{"line":544,"address":[],"length":0,"stats":{"Line":6}},{"line":545,"address":[],"length":0,"stats":{"Line":6}},{"line":548,"address":[],"length":0,"stats":{"Line":4}},{"line":549,"address":[],"length":0,"stats":{"Line":7}},{"line":550,"address":[],"length":0,"stats":{"Line":3}},{"line":554,"address":[],"length":0,"stats":{"Line":7}},{"line":555,"address":[],"length":0,"stats":{"Line":7}},{"line":558,"address":[],"length":0,"stats":{"Line":3}},{"line":559,"address":[],"length":0,"stats":{"Line":3}},{"line":560,"address":[],"length":0,"stats":{"Line":3}},{"line":561,"address":[],"length":0,"stats":{"Line":6}},{"line":564,"address":[],"length":0,"stats":{"Line":16}},{"line":565,"address":[],"length":0,"stats":{"Line":16}},{"line":566,"address":[],"length":0,"stats":{"Line":24}},{"line":567,"address":[],"length":0,"stats":{"Line":44}},{"line":568,"address":[],"length":0,"stats":{"Line":24}},{"line":569,"address":[],"length":0,"stats":{"Line":24}},{"line":570,"address":[],"length":0,"stats":{"Line":24}},{"line":571,"address":[],"length":0,"stats":{"Line":24}},{"line":573,"address":[],"length":0,"stats":{"Line":40}},{"line":574,"address":[],"length":0,"stats":{"Line":24}},{"line":576,"address":[],"length":0,"stats":{"Line":24}},{"line":577,"address":[],"length":0,"stats":{"Line":16}},{"line":578,"address":[],"length":0,"stats":{"Line":48}},{"line":579,"address":[],"length":0,"stats":{"Line":8}},{"line":580,"address":[],"length":0,"stats":{"Line":8}},{"line":582,"address":[],"length":0,"stats":{"Line":14}},{"line":583,"address":[],"length":0,"stats":{"Line":37}},{"line":584,"address":[],"length":0,"stats":{"Line":2}},{"line":586,"address":[],"length":0,"stats":{"Line":14}},{"line":587,"address":[],"length":0,"stats":{"Line":14}},{"line":588,"address":[],"length":0,"stats":{"Line":22}},{"line":589,"address":[],"length":0,"stats":{"Line":1}},{"line":592,"address":[],"length":0,"stats":{"Line":2}},{"line":593,"address":[],"length":0,"stats":{"Line":1}},{"line":596,"address":[],"length":0,"stats":{"Line":8}},{"line":599,"address":[],"length":0,"stats":{"Line":6}},{"line":600,"address":[],"length":0,"stats":{"Line":11}},{"line":601,"address":[],"length":0,"stats":{"Line":10}},{"line":602,"address":[],"length":0,"stats":{"Line":5}},{"line":606,"address":[],"length":0,"stats":{"Line":12}},{"line":607,"address":[],"length":0,"stats":{"Line":17}},{"line":608,"address":[],"length":0,"stats":{"Line":15}},{"line":609,"address":[],"length":0,"stats":{"Line":15}},{"line":610,"address":[],"length":0,"stats":{"Line":15}},{"line":611,"address":[],"length":0,"stats":{"Line":15}},{"line":612,"address":[],"length":0,"stats":{"Line":20}},{"line":613,"address":[],"length":0,"stats":{"Line":5}},{"line":615,"address":[],"length":0,"stats":{"Line":8}},{"line":616,"address":[],"length":0,"stats":{"Line":1}},{"line":617,"address":[],"length":0,"stats":{"Line":20}},{"line":619,"address":[],"length":0,"stats":{"Line":2}},{"line":621,"address":[],"length":0,"stats":{"Line":8}},{"line":623,"address":[],"length":0,"stats":{"Line":2}},{"line":624,"address":[],"length":0,"stats":{"Line":1}},{"line":628,"address":[],"length":0,"stats":{"Line":6}},{"line":629,"address":[],"length":0,"stats":{"Line":12}},{"line":632,"address":[],"length":0,"stats":{"Line":14}},{"line":633,"address":[],"length":0,"stats":{"Line":21}},{"line":634,"address":[],"length":0,"stats":{"Line":21}},{"line":635,"address":[],"length":0,"stats":{"Line":28}},{"line":637,"address":[],"length":0,"stats":{"Line":14}},{"line":638,"address":[],"length":0,"stats":{"Line":1}},{"line":642,"address":[],"length":0,"stats":{"Line":30}},{"line":643,"address":[],"length":0,"stats":{"Line":12}},{"line":644,"address":[],"length":0,"stats":{"Line":20}},{"line":646,"address":[],"length":0,"stats":{"Line":12}},{"line":647,"address":[],"length":0,"stats":{"Line":12}},{"line":648,"address":[],"length":0,"stats":{"Line":12}},{"line":650,"address":[],"length":0,"stats":{"Line":36}},{"line":651,"address":[],"length":0,"stats":{"Line":12}},{"line":652,"address":[],"length":0,"stats":{"Line":18}},{"line":653,"address":[],"length":0,"stats":{"Line":1}},{"line":656,"address":[],"length":0,"stats":{"Line":15}},{"line":658,"address":[],"length":0,"stats":{"Line":10}},{"line":659,"address":[],"length":0,"stats":{"Line":3}},{"line":660,"address":[],"length":0,"stats":{"Line":9}},{"line":661,"address":[],"length":0,"stats":{"Line":3}},{"line":662,"address":[],"length":0,"stats":{"Line":18}},{"line":663,"address":[],"length":0,"stats":{"Line":3}},{"line":666,"address":[],"length":0,"stats":{"Line":2}},{"line":669,"address":[],"length":0,"stats":{"Line":5}},{"line":670,"address":[],"length":0,"stats":{"Line":6}},{"line":671,"address":[],"length":0,"stats":{"Line":3}},{"line":672,"address":[],"length":0,"stats":{"Line":1}},{"line":673,"address":[],"length":0,"stats":{"Line":1}},{"line":676,"address":[],"length":0,"stats":{"Line":2}},{"line":678,"address":[],"length":0,"stats":{"Line":3}},{"line":679,"address":[],"length":0,"stats":{"Line":3}},{"line":680,"address":[],"length":0,"stats":{"Line":18}},{"line":681,"address":[],"length":0,"stats":{"Line":3}},{"line":682,"address":[],"length":0,"stats":{"Line":3}},{"line":684,"address":[],"length":0,"stats":{"Line":4}},{"line":685,"address":[],"length":0,"stats":{"Line":2}},{"line":690,"address":[],"length":0,"stats":{"Line":6}},{"line":691,"address":[],"length":0,"stats":{"Line":20}},{"line":694,"address":[],"length":0,"stats":{"Line":10}},{"line":695,"address":[],"length":0,"stats":{"Line":10}},{"line":696,"address":[],"length":0,"stats":{"Line":2}},{"line":698,"address":[],"length":0,"stats":{"Line":3}},{"line":700,"address":[],"length":0,"stats":{"Line":10}},{"line":704,"address":[],"length":0,"stats":{"Line":10}},{"line":705,"address":[],"length":0,"stats":{"Line":10}},{"line":706,"address":[],"length":0,"stats":{"Line":20}},{"line":710,"address":[],"length":0,"stats":{"Line":4}},{"line":711,"address":[],"length":0,"stats":{"Line":4}},{"line":712,"address":[],"length":0,"stats":{"Line":5}},{"line":716,"address":[],"length":0,"stats":{"Line":27}},{"line":717,"address":[],"length":0,"stats":{"Line":108}},{"line":718,"address":[],"length":0,"stats":{"Line":81}},{"line":719,"address":[],"length":0,"stats":{"Line":81}},{"line":721,"address":[],"length":0,"stats":{"Line":15}},{"line":722,"address":[],"length":0,"stats":{"Line":29}},{"line":723,"address":[],"length":0,"stats":{"Line":1}},{"line":725,"address":[],"length":0,"stats":{"Line":70}},{"line":729,"address":[],"length":0,"stats":{"Line":27}},{"line":730,"address":[],"length":0,"stats":{"Line":14}},{"line":732,"address":[],"length":0,"stats":{"Line":21}},{"line":733,"address":[],"length":0,"stats":{"Line":21}},{"line":734,"address":[],"length":0,"stats":{"Line":10}},{"line":735,"address":[],"length":0,"stats":{"Line":10}},{"line":736,"address":[],"length":0,"stats":{"Line":10}},{"line":737,"address":[],"length":0,"stats":{"Line":15}},{"line":738,"address":[],"length":0,"stats":{"Line":26}},{"line":739,"address":[],"length":0,"stats":{"Line":24}},{"line":740,"address":[],"length":0,"stats":{"Line":8}},{"line":741,"address":[],"length":0,"stats":{"Line":6}},{"line":743,"address":[],"length":0,"stats":{"Line":6}},{"line":744,"address":[],"length":0,"stats":{"Line":2}},{"line":746,"address":[],"length":0,"stats":{"Line":4}},{"line":748,"address":[],"length":0,"stats":{"Line":24}},{"line":750,"address":[],"length":0,"stats":{"Line":1}},{"line":752,"address":[],"length":0,"stats":{"Line":5}},{"line":754,"address":[],"length":0,"stats":{"Line":12}},{"line":755,"address":[],"length":0,"stats":{"Line":3}},{"line":756,"address":[],"length":0,"stats":{"Line":3}},{"line":758,"address":[],"length":0,"stats":{"Line":3}},{"line":760,"address":[],"length":0,"stats":{"Line":8}},{"line":761,"address":[],"length":0,"stats":{"Line":6}},{"line":762,"address":[],"length":0,"stats":{"Line":6}},{"line":763,"address":[],"length":0,"stats":{"Line":6}},{"line":764,"address":[],"length":0,"stats":{"Line":6}},{"line":765,"address":[],"length":0,"stats":{"Line":3}},{"line":768,"address":[],"length":0,"stats":{"Line":7}},{"line":769,"address":[],"length":0,"stats":{"Line":1}},{"line":773,"address":[],"length":0,"stats":{"Line":11}},{"line":774,"address":[],"length":0,"stats":{"Line":2}},{"line":775,"address":[],"length":0,"stats":{"Line":6}},{"line":776,"address":[],"length":0,"stats":{"Line":1}},{"line":780,"address":[],"length":0,"stats":{"Line":11}},{"line":781,"address":[],"length":0,"stats":{"Line":2}},{"line":782,"address":[],"length":0,"stats":{"Line":6}},{"line":783,"address":[],"length":0,"stats":{"Line":1}},{"line":786,"address":[],"length":0,"stats":{"Line":1}},{"line":788,"address":[],"length":0,"stats":{"Line":8}},{"line":790,"address":[],"length":0,"stats":{"Line":7}},{"line":791,"address":[],"length":0,"stats":{"Line":1}},{"line":795,"address":[],"length":0,"stats":{"Line":4}},{"line":796,"address":[],"length":0,"stats":{"Line":1}},{"line":800,"address":[],"length":0,"stats":{"Line":28}},{"line":802,"address":[],"length":0,"stats":{"Line":4}},{"line":804,"address":[],"length":0,"stats":{"Line":2}},{"line":808,"address":[],"length":0,"stats":{"Line":7}},{"line":809,"address":[],"length":0,"stats":{"Line":1}},{"line":812,"address":[],"length":0,"stats":{"Line":1}},{"line":814,"address":[],"length":0,"stats":{"Line":1}},{"line":818,"address":[],"length":0,"stats":{"Line":4}},{"line":819,"address":[],"length":0,"stats":{"Line":12}},{"line":820,"address":[],"length":0,"stats":{"Line":4}},{"line":823,"address":[],"length":0,"stats":{"Line":3}},{"line":824,"address":[],"length":0,"stats":{"Line":9}},{"line":825,"address":[],"length":0,"stats":{"Line":3}},{"line":826,"address":[],"length":0,"stats":{"Line":1}},{"line":828,"address":[],"length":0,"stats":{"Line":2}},{"line":832,"address":[],"length":0,"stats":{"Line":8}},{"line":833,"address":[],"length":0,"stats":{"Line":4}},{"line":834,"address":[],"length":0,"stats":{"Line":3}},{"line":835,"address":[],"length":0,"stats":{"Line":3}},{"line":836,"address":[],"length":0,"stats":{"Line":3}},{"line":837,"address":[],"length":0,"stats":{"Line":3}},{"line":841,"address":[],"length":0,"stats":{"Line":12}},{"line":842,"address":[],"length":0,"stats":{"Line":12}},{"line":843,"address":[],"length":0,"stats":{"Line":2}},{"line":844,"address":[],"length":0,"stats":{"Line":4}},{"line":845,"address":[],"length":0,"stats":{"Line":4}},{"line":846,"address":[],"length":0,"stats":{"Line":2}},{"line":847,"address":[],"length":0,"stats":{"Line":2}},{"line":848,"address":[],"length":0,"stats":{"Line":2}},{"line":849,"address":[],"length":0,"stats":{"Line":2}},{"line":850,"address":[],"length":0,"stats":{"Line":1}},{"line":854,"address":[],"length":0,"stats":{"Line":12}},{"line":855,"address":[],"length":0,"stats":{"Line":6}},{"line":856,"address":[],"length":0,"stats":{"Line":4}},{"line":857,"address":[],"length":0,"stats":{"Line":2}},{"line":860,"address":[],"length":0,"stats":{"Line":11}},{"line":861,"address":[],"length":0,"stats":{"Line":8}},{"line":862,"address":[],"length":0,"stats":{"Line":6}},{"line":863,"address":[],"length":0,"stats":{"Line":10}},{"line":868,"address":[],"length":0,"stats":{"Line":12}},{"line":869,"address":[],"length":0,"stats":{"Line":6}},{"line":870,"address":[],"length":0,"stats":{"Line":2}},{"line":871,"address":[],"length":0,"stats":{"Line":4}},{"line":872,"address":[],"length":0,"stats":{"Line":2}},{"line":873,"address":[],"length":0,"stats":{"Line":2}},{"line":874,"address":[],"length":0,"stats":{"Line":1}},{"line":878,"address":[],"length":0,"stats":{"Line":10}},{"line":879,"address":[],"length":0,"stats":{"Line":5}},{"line":880,"address":[],"length":0,"stats":{"Line":2}},{"line":881,"address":[],"length":0,"stats":{"Line":6}},{"line":882,"address":[],"length":0,"stats":{"Line":1}},{"line":898,"address":[],"length":0,"stats":{"Line":0}},{"line":909,"address":[],"length":0,"stats":{"Line":0}},{"line":911,"address":[],"length":0,"stats":{"Line":0}},{"line":913,"address":[],"length":0,"stats":{"Line":0}},{"line":914,"address":[],"length":0,"stats":{"Line":0}},{"line":915,"address":[],"length":0,"stats":{"Line":0}},{"line":916,"address":[],"length":0,"stats":{"Line":0}},{"line":917,"address":[],"length":0,"stats":{"Line":0}},{"line":919,"address":[],"length":0,"stats":{"Line":0}},{"line":922,"address":[],"length":0,"stats":{"Line":0}},{"line":923,"address":[],"length":0,"stats":{"Line":0}},{"line":924,"address":[],"length":0,"stats":{"Line":0}},{"line":925,"address":[],"length":0,"stats":{"Line":0}},{"line":927,"address":[],"length":0,"stats":{"Line":0}},{"line":928,"address":[],"length":0,"stats":{"Line":0}},{"line":934,"address":[],"length":0,"stats":{"Line":0}},{"line":935,"address":[],"length":0,"stats":{"Line":0}},{"line":936,"address":[],"length":0,"stats":{"Line":0}},{"line":937,"address":[],"length":0,"stats":{"Line":0}},{"line":938,"address":[],"length":0,"stats":{"Line":0}},{"line":940,"address":[],"length":0,"stats":{"Line":0}},{"line":946,"address":[],"length":0,"stats":{"Line":0}},{"line":949,"address":[],"length":0,"stats":{"Line":0}},{"line":961,"address":[],"length":0,"stats":{"Line":27}},{"line":962,"address":[],"length":0,"stats":{"Line":108}},{"line":969,"address":[],"length":0,"stats":{"Line":118}},{"line":970,"address":[],"length":0,"stats":{"Line":472}},{"line":971,"address":[],"length":0,"stats":{"Line":472}},{"line":972,"address":[],"length":0,"stats":{"Line":2910}},{"line":974,"address":[],"length":0,"stats":{"Line":1396}},{"line":975,"address":[],"length":0,"stats":{"Line":4}},{"line":976,"address":[],"length":0,"stats":{"Line":6}},{"line":978,"address":[],"length":0,"stats":{"Line":14}},{"line":979,"address":[],"length":0,"stats":{"Line":14}},{"line":980,"address":[],"length":0,"stats":{"Line":14}},{"line":981,"address":[],"length":0,"stats":{"Line":3}},{"line":985,"address":[],"length":0,"stats":{"Line":4}},{"line":988,"address":[],"length":0,"stats":{"Line":4176}},{"line":989,"address":[],"length":0,"stats":{"Line":75}},{"line":991,"address":[],"length":0,"stats":{"Line":3951}},{"line":994,"address":[],"length":0,"stats":{"Line":118}},{"line":996,"address":[],"length":0,"stats":{"Line":356}},{"line":1004,"address":[],"length":0,"stats":{"Line":8}},{"line":1005,"address":[],"length":0,"stats":{"Line":8}},{"line":1007,"address":[],"length":0,"stats":{"Line":18}},{"line":1008,"address":[],"length":0,"stats":{"Line":30}},{"line":1009,"address":[],"length":0,"stats":{"Line":30}},{"line":1010,"address":[],"length":0,"stats":{"Line":30}},{"line":1011,"address":[],"length":0,"stats":{"Line":32}},{"line":1012,"address":[],"length":0,"stats":{"Line":16}},{"line":1013,"address":[],"length":0,"stats":{"Line":1}},{"line":1015,"address":[],"length":0,"stats":{"Line":28}},{"line":1016,"address":[],"length":0,"stats":{"Line":24}},{"line":1017,"address":[],"length":0,"stats":{"Line":6}},{"line":1018,"address":[],"length":0,"stats":{"Line":12}},{"line":1019,"address":[],"length":0,"stats":{"Line":6}},{"line":1020,"address":[],"length":0,"stats":{"Line":6}},{"line":1021,"address":[],"length":0,"stats":{"Line":6}},{"line":1031,"address":[],"length":0,"stats":{"Line":0}},{"line":1032,"address":[],"length":0,"stats":{"Line":0}},{"line":1033,"address":[],"length":0,"stats":{"Line":0}},{"line":1034,"address":[],"length":0,"stats":{"Line":0}},{"line":1035,"address":[],"length":0,"stats":{"Line":0}},{"line":1036,"address":[],"length":0,"stats":{"Line":0}},{"line":1037,"address":[],"length":0,"stats":{"Line":0}},{"line":1038,"address":[],"length":0,"stats":{"Line":0}},{"line":1039,"address":[],"length":0,"stats":{"Line":0}},{"line":1040,"address":[],"length":0,"stats":{"Line":0}},{"line":1041,"address":[],"length":0,"stats":{"Line":0}},{"line":1045,"address":[],"length":0,"stats":{"Line":0}},{"line":1046,"address":[],"length":0,"stats":{"Line":0}},{"line":1047,"address":[],"length":0,"stats":{"Line":0}},{"line":1048,"address":[],"length":0,"stats":{"Line":0}},{"line":1051,"address":[],"length":0,"stats":{"Line":0}},{"line":1052,"address":[],"length":0,"stats":{"Line":0}},{"line":1053,"address":[],"length":0,"stats":{"Line":0}},{"line":1056,"address":[],"length":0,"stats":{"Line":0}},{"line":1057,"address":[],"length":0,"stats":{"Line":0}},{"line":1058,"address":[],"length":0,"stats":{"Line":0}},{"line":1059,"address":[],"length":0,"stats":{"Line":0}},{"line":1060,"address":[],"length":0,"stats":{"Line":0}},{"line":1061,"address":[],"length":0,"stats":{"Line":0}},{"line":1062,"address":[],"length":0,"stats":{"Line":0}},{"line":1063,"address":[],"length":0,"stats":{"Line":0}},{"line":1064,"address":[],"length":0,"stats":{"Line":0}},{"line":1065,"address":[],"length":0,"stats":{"Line":0}},{"line":1072,"address":[],"length":0,"stats":{"Line":0}},{"line":1073,"address":[],"length":0,"stats":{"Line":0}}],"covered":482,"coverable":546},{"path":["/","Users","cat","hydra","src","event.rs"],"content":"use crossterm::event::{Event as CrosstermEvent, EventStream, KeyEvent, MouseEvent};\nuse futures::{Stream, StreamExt};\nuse std::time::Duration;\nuse tokio::sync::mpsc;\n\n/// Bounded event queue capacity.\n/// Large enough to buffer bursty input while preventing unbounded memory growth.\nconst EVENT_CHANNEL_CAPACITY: usize = 2048;\n\n#[derive(Debug)]\npub enum Event {\n    Key(KeyEvent),\n    Mouse(MouseEvent),\n    Tick,\n    Resize,\n}\n\npub struct EventHandler {\n    rx: mpsc::Receiver<Event>,\n    _task: tokio::task::JoinHandle<()>,\n}\n\nimpl EventHandler {\n    pub fn new(tick_rate: Duration) -> Self {\n        Self::from_stream(EventStream::new(), tick_rate)\n    }\n\n    /// Build an EventHandler from any crossterm-compatible event stream.\n    /// Production code uses `EventStream::new()`; tests inject a fake stream.\n    pub fn from_stream<S>(stream: S, tick_rate: Duration) -> Self\n    where\n        S: Stream<Item = Result<CrosstermEvent, std::io::Error>> + Send + Unpin + 'static,\n    {\n        let (tx, rx) = mpsc::channel(EVENT_CHANNEL_CAPACITY);\n\n        let task = tokio::spawn(async move {\n            let mut reader = stream;\n            let mut tick = tokio::time::interval(tick_rate);\n\n            loop {\n                tokio::select! {\n                    _ = tick.tick() => {\n                        // Coalesce ticks when the queue is full.\n                        match tx.try_send(Event::Tick) {\n                            Ok(()) | Err(mpsc::error::TrySendError::Full(_)) => {}\n                            Err(mpsc::error::TrySendError::Closed(_)) => break,\n                        }\n                    }\n                    event = reader.next() => {\n                        match event {\n                            Some(Ok(CrosstermEvent::Key(key))) => {\n                                if tx.send(Event::Key(key)).await.is_err() {\n                                    break;\n                                }\n                            }\n                            Some(Ok(CrosstermEvent::Mouse(mouse))) => {\n                                if tx.send(Event::Mouse(mouse)).await.is_err() {\n                                    break;\n                                }\n                            }\n                            Some(Ok(CrosstermEvent::Resize(_, _))) => {\n                                if tx.send(Event::Resize).await.is_err() {\n                                    break;\n                                }\n                            }\n                            Some(Err(_)) | None => break,\n                            _ => {}\n                        }\n                    }\n                }\n            }\n        });\n\n        Self { rx, _task: task }\n    }\n\n    pub async fn next(&mut self) -> Option<Event> {\n        self.rx.recv().await\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crossterm::event::{KeyCode, KeyModifiers, MouseButton, MouseEventKind};\n\n    /// Create a fake stream from a vec of crossterm results.\n    fn fake_stream(\n        events: Vec<Result<CrosstermEvent, std::io::Error>>,\n    ) -> impl Stream<Item = Result<CrosstermEvent, std::io::Error>> + Send + Unpin {\n        futures::stream::iter(events)\n    }\n\n    fn key_event(code: KeyCode) -> CrosstermEvent {\n        CrosstermEvent::Key(KeyEvent::new(code, KeyModifiers::NONE))\n    }\n\n    fn mouse_event() -> CrosstermEvent {\n        CrosstermEvent::Mouse(MouseEvent {\n            kind: MouseEventKind::Down(MouseButton::Left),\n            column: 10,\n            row: 5,\n            modifiers: KeyModifiers::NONE,\n        })\n    }\n\n    #[tokio::test]\n    async fn forwards_key_events() {\n        let stream = fake_stream(vec![\n            Ok(key_event(KeyCode::Char('j'))),\n            Ok(key_event(KeyCode::Enter)),\n        ]);\n        let mut handler = EventHandler::from_stream(stream, Duration::from_secs(60));\n\n        let e1 = handler.next().await.unwrap();\n        assert!(matches!(e1, Event::Key(k) if k.code == KeyCode::Char('j')));\n\n        let e2 = handler.next().await.unwrap();\n        assert!(matches!(e2, Event::Key(k) if k.code == KeyCode::Enter));\n    }\n\n    #[tokio::test]\n    async fn forwards_mouse_events() {\n        let stream = fake_stream(vec![Ok(mouse_event())]);\n        let mut handler = EventHandler::from_stream(stream, Duration::from_secs(60));\n\n        let e = handler.next().await.unwrap();\n        assert!(matches!(e, Event::Mouse(m) if m.column == 10 && m.row == 5));\n    }\n\n    #[tokio::test]\n    async fn forwards_resize_events() {\n        let stream = fake_stream(vec![Ok(CrosstermEvent::Resize(120, 40))]);\n        let mut handler = EventHandler::from_stream(stream, Duration::from_secs(60));\n\n        let e = handler.next().await.unwrap();\n        assert!(matches!(e, Event::Resize));\n    }\n\n    #[tokio::test]\n    async fn tick_fires_on_interval() {\n        // Empty stream that never yields — only ticks will arrive\n        let stream = futures::stream::pending();\n        let mut handler = EventHandler::from_stream(stream, Duration::from_millis(10));\n\n        let e = handler.next().await.unwrap();\n        assert!(matches!(e, Event::Tick));\n    }\n\n    #[tokio::test]\n    async fn stream_error_ends_loop() {\n        let stream = fake_stream(vec![\n            Ok(key_event(KeyCode::Char('a'))),\n            Err(std::io::Error::new(std::io::ErrorKind::Other, \"fail\")),\n        ]);\n        let mut handler = EventHandler::from_stream(stream, Duration::from_secs(60));\n\n        // First event should arrive\n        let e = handler.next().await.unwrap();\n        assert!(matches!(e, Event::Key(_)));\n\n        // After error, channel closes → next() returns None\n        // (may get a tick before closure, so drain any ticks)\n        loop {\n            match handler.next().await {\n                Some(Event::Tick) => continue,\n                None => break,\n                other => panic!(\"expected None or Tick, got {other:?}\"),\n            }\n        }\n    }\n\n    #[tokio::test]\n    async fn stream_none_ends_loop() {\n        // Stream that yields one event then ends (None)\n        let stream = fake_stream(vec![Ok(key_event(KeyCode::Char('z')))]);\n        let mut handler = EventHandler::from_stream(stream, Duration::from_secs(60));\n\n        let e = handler.next().await.unwrap();\n        assert!(matches!(e, Event::Key(k) if k.code == KeyCode::Char('z')));\n\n        // Stream ended → loop exits → channel closes\n        loop {\n            match handler.next().await {\n                Some(Event::Tick) => continue,\n                None => break,\n                other => panic!(\"expected None or Tick, got {other:?}\"),\n            }\n        }\n    }\n\n    #[tokio::test]\n    async fn ignores_unknown_crossterm_events() {\n        let stream = fake_stream(vec![\n            Ok(CrosstermEvent::FocusGained), // unknown variant — should be ignored\n            Ok(key_event(KeyCode::Char('x'))),\n        ]);\n        let mut handler = EventHandler::from_stream(stream, Duration::from_secs(60));\n\n        // FocusGained is silently dropped, next event is the key\n        let e = handler.next().await.unwrap();\n        assert!(matches!(e, Event::Key(k) if k.code == KeyCode::Char('x')));\n    }\n\n    #[tokio::test]\n    async fn mixed_event_types() {\n        let stream = fake_stream(vec![\n            Ok(key_event(KeyCode::Char('a'))),\n            Ok(mouse_event()),\n            Ok(CrosstermEvent::Resize(80, 24)),\n            Ok(key_event(KeyCode::Esc)),\n        ]);\n        let mut handler = EventHandler::from_stream(stream, Duration::from_secs(60));\n\n        assert!(matches!(handler.next().await.unwrap(), Event::Key(_)));\n        assert!(matches!(handler.next().await.unwrap(), Event::Mouse(_)));\n        assert!(matches!(handler.next().await.unwrap(), Event::Resize));\n        assert!(matches!(handler.next().await.unwrap(), Event::Key(k) if k.code == KeyCode::Esc));\n    }\n\n    #[tokio::test]\n    async fn drop_handler_stops_task() {\n        let stream = futures::stream::pending::<Result<CrosstermEvent, std::io::Error>>();\n        let handler = EventHandler::from_stream(stream, Duration::from_millis(10));\n        let task = &handler._task;\n        assert!(!task.is_finished());\n        drop(handler);\n        // Task should finish shortly after rx is dropped\n        tokio::time::sleep(Duration::from_millis(50)).await;\n        // Can't check task.is_finished() after drop, but no panic = success\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":9}},{"line":34,"address":[],"length":0,"stats":{"Line":27}},{"line":36,"address":[],"length":0,"stats":{"Line":27}},{"line":37,"address":[],"length":0,"stats":{"Line":18}},{"line":38,"address":[],"length":0,"stats":{"Line":27}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":22}},{"line":42,"address":[],"length":0,"stats":{"Line":44}},{"line":44,"address":[],"length":0,"stats":{"Line":6}},{"line":45,"address":[],"length":0,"stats":{"Line":1}},{"line":46,"address":[],"length":0,"stats":{"Line":1}},{"line":49,"address":[],"length":0,"stats":{"Line":63}},{"line":50,"address":[],"length":0,"stats":{"Line":12}},{"line":51,"address":[],"length":0,"stats":{"Line":7}},{"line":52,"address":[],"length":0,"stats":{"Line":35}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":2}},{"line":57,"address":[],"length":0,"stats":{"Line":10}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":10}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":7}},{"line":67,"address":[],"length":0,"stats":{"Line":1}},{"line":77,"address":[],"length":0,"stats":{"Line":28}},{"line":78,"address":[],"length":0,"stats":{"Line":28}}],"covered":21,"coverable":28},{"path":["/","Users","cat","hydra","src","logs.rs"],"content":"use std::collections::{HashMap, HashSet};\nuse std::io::{Read, Seek, SeekFrom};\nuse std::path::PathBuf;\nuse std::time::Duration;\n\nuse anyhow::{bail, Context, Result as AnyhowResult};\nuse tokio::process::Command;\n\n/// Default timeout for subprocess calls in log resolution (5 seconds).\nconst CMD_TIMEOUT: Duration = Duration::from_secs(5);\n\n/// Maximum depth for process tree walks (tmux shell → agent → subprocesses).\nconst MAX_TREE_DEPTH: usize = 5;\n\n/// Maximum total PIDs collected during a process tree walk.\nconst MAX_TREE_PIDS: usize = 100;\n\n/// Run a Command with a timeout, returning its Output.\nasync fn run_cmd_timeout(cmd: &mut Command) -> AnyhowResult<std::process::Output> {\n    match tokio::time::timeout(CMD_TIMEOUT, cmd.output()).await {\n        Ok(result) => result.context(\"subprocess failed to execute\"),\n        Err(_) => bail!(\"subprocess timed out after {}s\", CMD_TIMEOUT.as_secs()),\n    }\n}\n\n/// Per-session stats aggregated from Claude Code JSONL logs.\n/// Updated incrementally — only new bytes are parsed on each refresh.\n#[derive(Debug, Default, Clone)]\npub struct SessionStats {\n    pub turns: u32,\n    pub tokens_in: u64,\n    pub tokens_out: u64,\n    pub tokens_cache_read: u64,\n    pub tokens_cache_write: u64,\n    pub edits: u16,\n    pub bash_cmds: u16,\n    pub files: HashSet<String>,\n    /// Files in order of most recent edit (last = most recent).\n    /// Deduplicated: each path appears at most once.\n    pub recent_files: Vec<String>,\n    /// ISO 8601 timestamp of the most recent user message (task start).\n    pub last_user_ts: Option<String>,\n    /// ISO 8601 timestamp of the most recent assistant message (task end).\n    pub last_assistant_ts: Option<String>,\n    pub read_offset: u64,\n    /// Active subagent count (from queue-operation enqueue/remove entries).\n    pub active_subagents: u16,\n}\n\n/// Upper bound for per-session touched file history.\n/// Keeps enough history for real projects while preventing unbounded growth.\nconst MAX_SESSION_TRACKED_FILES: usize = 4096;\n\nimpl SessionStats {\n    #[cfg(test)]\n    pub fn cost_usd(&self) -> f64 {\n        let input = self.tokens_in as f64 * 3.0 / 1_000_000.0;\n        let output = self.tokens_out as f64 * 15.0 / 1_000_000.0;\n        let cache_read = self.tokens_cache_read as f64 * 0.30 / 1_000_000.0;\n        let cache_write = self.tokens_cache_write as f64 * 3.75 / 1_000_000.0;\n        input + output + cache_read + cache_write\n    }\n\n    #[cfg(test)]\n    pub fn file_count(&self) -> usize {\n        self.files.len()\n    }\n\n    /// Compute task elapsed duration from log timestamps.\n    /// Returns Some if the agent appears to be working (last user msg > last assistant msg,\n    /// or no assistant response yet). Returns None if idle or no data.\n    pub fn task_elapsed(&self) -> Option<std::time::Duration> {\n        let user_ts = parse_iso_timestamp(self.last_user_ts.as_deref()?)?;\n        let now = chrono::Utc::now();\n\n        match &self.last_assistant_ts {\n            Some(ast_str) => {\n                let ast_ts = parse_iso_timestamp(ast_str)?;\n                if user_ts > ast_ts {\n                    // User sent a message after the last assistant reply — agent is working\n                    Some((now - user_ts).to_std().unwrap_or_default())\n                } else {\n                    // Assistant replied after user — task complete, no elapsed\n                    None\n                }\n            }\n            None => {\n                // No assistant response yet — agent is working on first message\n                Some((now - user_ts).to_std().unwrap_or_default())\n            }\n        }\n    }\n\n    /// Record a file touch, updating both the dedup set and recency order.\n    pub fn touch_file(&mut self, path: String) {\n        // Existing path: move it to the end (most recent).\n        if let Some(pos) = self.recent_files.iter().position(|f| f == &path) {\n            self.recent_files.remove(pos);\n            self.recent_files.push(path);\n            return;\n        }\n\n        // New path: evict oldest entries when at capacity.\n        while self.recent_files.len() >= MAX_SESSION_TRACKED_FILES {\n            if let Some(evicted) = self.recent_files.first().cloned() {\n                self.recent_files.remove(0);\n                self.files.remove(&evicted);\n            } else {\n                break;\n            }\n        }\n\n        self.files.insert(path.clone());\n        self.recent_files.push(path);\n    }\n}\n\n/// Parse an ISO 8601 timestamp string into a chrono DateTime.\nfn parse_iso_timestamp(s: &str) -> Option<chrono::DateTime<chrono::Utc>> {\n    s.parse::<chrono::DateTime<chrono::Utc>>().ok()\n}\n\n/// Format a token count compactly: 1234 → \"1.2k\", 1234567 → \"1.2M\"\npub fn format_tokens(n: u64) -> String {\n    if n >= 1_000_000 {\n        format!(\"{:.1}M\", n as f64 / 1_000_000.0)\n    } else if n >= 1_000 {\n        format!(\"{:.1}k\", n as f64 / 1_000.0)\n    } else {\n        format!(\"{n}\")\n    }\n}\n\n/// Format cost in USD compactly.\npub fn format_cost(usd: f64) -> String {\n    if usd < 0.005 {\n        \"$0.00\".to_string()\n    } else if usd < 10.0 {\n        format!(\"${:.2}\", usd)\n    } else {\n        format!(\"${:.0}\", usd)\n    }\n}\n\n/// Incrementally update stats from a Claude JSONL log file.\n/// Only reads bytes after `stats.read_offset`, making repeated calls cheap.\n#[allow(dead_code)]\npub fn update_session_stats(cwd: &str, uuid: &str, stats: &mut SessionStats) {\n    let _ = update_session_stats_and_last_message(cwd, uuid, stats);\n}\n\n/// Incrementally update stats and return the most recent assistant text seen\n/// in newly-read bytes (if any).\npub fn update_session_stats_and_last_message(\n    cwd: &str,\n    uuid: &str,\n    stats: &mut SessionStats,\n) -> Option<String> {\n    let escaped = escape_project_path(cwd);\n    let home = match std::env::var(\"HOME\") {\n        Ok(h) => h,\n        Err(_) => return None,\n    };\n    let path = PathBuf::from(&home)\n        .join(\".claude\")\n        .join(\"projects\")\n        .join(&escaped)\n        .join(format!(\"{uuid}.jsonl\"));\n\n    update_session_stats_from_path_and_last_message(&path, stats)\n}\n\n/// Core stats parser — reads from a specific file path.\n/// Separated from `update_session_stats` for testability (avoids HOME env var).\n#[allow(dead_code)]\nfn update_session_stats_from_path(path: &std::path::Path, stats: &mut SessionStats) {\n    let _ = update_session_stats_from_path_and_last_message(path, stats);\n}\n\nfn update_session_stats_from_path_and_last_message(\n    path: &std::path::Path,\n    stats: &mut SessionStats,\n) -> Option<String> {\n    let mut file = match std::fs::File::open(path) {\n        Ok(f) => f,\n        Err(_) => return None,\n    };\n    let file_len = match file.metadata() {\n        Ok(m) => m.len(),\n        Err(_) => return None,\n    };\n\n    // Nothing new to read\n    if file_len <= stats.read_offset {\n        return None;\n    }\n\n    // Seek to where we left off\n    if stats.read_offset > 0 {\n        if file.seek(SeekFrom::Start(stats.read_offset)).is_err() {\n            return None;\n        }\n    }\n\n    let mut buf = Vec::new();\n    if file.read_to_end(&mut buf).is_err() {\n        return None;\n    }\n    let text = String::from_utf8_lossy(&buf);\n    let mut last_text: Option<String> = None;\n\n    for line in text.lines() {\n        // Skip empty lines\n        if line.len() < 10 {\n            continue;\n        }\n\n        // Fast path: assistant messages. Parse once and update both stats + last text.\n        if line.contains(\"\\\"assistant\\\"\") {\n            if let Ok(v) = serde_json::from_str::<serde_json::Value>(line) {\n                if v.get(\"type\").and_then(|t| t.as_str()) == Some(\"assistant\") {\n                    if let Some(ts) = v.get(\"timestamp\").and_then(|t| t.as_str()) {\n                        stats.last_assistant_ts = Some(ts.to_string());\n                    }\n\n                    if let Some(text) = extract_assistant_message_text(&v) {\n                        last_text = Some(text);\n                    }\n\n                    // Extract token usage\n                    if let Some(usage) = v.get(\"message\").and_then(|m| m.get(\"usage\")) {\n                        stats.turns += 1;\n                        stats.tokens_in += usage\n                            .get(\"input_tokens\")\n                            .and_then(|t| t.as_u64())\n                            .unwrap_or(0);\n                        stats.tokens_out += usage\n                            .get(\"output_tokens\")\n                            .and_then(|t| t.as_u64())\n                            .unwrap_or(0);\n                        stats.tokens_cache_read += usage\n                            .get(\"cache_read_input_tokens\")\n                            .and_then(|t| t.as_u64())\n                            .unwrap_or(0);\n                        stats.tokens_cache_write += usage\n                            .get(\"cache_creation_input_tokens\")\n                            .and_then(|t| t.as_u64())\n                            .unwrap_or(0);\n                    }\n\n                    // Count tool calls from content array\n                    if let Some(content) = v\n                        .get(\"message\")\n                        .and_then(|m| m.get(\"content\"))\n                        .and_then(|c| c.as_array())\n                    {\n                        for item in content {\n                            if item.get(\"type\").and_then(|t| t.as_str()) == Some(\"tool_use\") {\n                                if let Some(name) = item.get(\"name\").and_then(|n| n.as_str()) {\n                                    match name {\n                                        \"Write\" | \"Edit\" => stats.edits += 1,\n                                        \"Bash\" => stats.bash_cmds += 1,\n                                        _ => {}\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            continue;\n        }\n\n        // Fast path: user messages — track timestamp for task-start timing\n        if line.contains(\"\\\"user\\\"\")\n            && line.contains(\"\\\"timestamp\\\"\")\n            && !line.contains(\"\\\"usage\\\"\")\n        {\n            if let Ok(v) = serde_json::from_str::<serde_json::Value>(line) {\n                if v.get(\"type\").and_then(|t| t.as_str()) == Some(\"user\") {\n                    if let Some(ts) = v.get(\"timestamp\").and_then(|t| t.as_str()) {\n                        stats.last_user_ts = Some(ts.to_string());\n                    }\n                }\n            }\n            continue;\n        }\n\n        // Fast path: tool results with filenames\n        if line.contains(\"\\\"filenames\\\"\") && line.contains(\"\\\"toolUseResult\\\"\") {\n            if let Ok(v) = serde_json::from_str::<serde_json::Value>(line) {\n                if let Some(filenames) = v\n                    .get(\"toolUseResult\")\n                    .and_then(|r| r.get(\"filenames\"))\n                    .and_then(|f| f.as_array())\n                {\n                    for fname in filenames {\n                        if let Some(s) = fname.as_str() {\n                            stats.touch_file(s.to_string());\n                        }\n                    }\n                }\n            }\n            continue;\n        }\n\n        // Fast path: queue-operation entries for subagent tracking\n        if line.contains(\"\\\"queue-operation\\\"\") {\n            if let Ok(v) = serde_json::from_str::<serde_json::Value>(line) {\n                if v.get(\"type\").and_then(|t| t.as_str()) == Some(\"queue-operation\") {\n                    match v.get(\"operation\").and_then(|o| o.as_str()) {\n                        Some(\"enqueue\") => {\n                            stats.active_subagents = stats.active_subagents.saturating_add(1);\n                        }\n                        Some(\"remove\") => {\n                            stats.active_subagents = stats.active_subagents.saturating_sub(1);\n                        }\n                        _ => {}\n                    }\n                }\n            }\n        }\n    }\n\n    stats.read_offset = file_len;\n    last_text\n}\n\nconst FILE_DISCOVERY_INTERVAL_SECS: i64 = 30;\n\n// Uses OpenAI's published GPT-5 Codex token pricing as an estimate.\nconst CODEX_INPUT_USD_PER_MTOK: f64 = 1.25;\nconst CODEX_OUTPUT_USD_PER_MTOK: f64 = 10.0;\nconst CODEX_CACHE_READ_USD_PER_MTOK: f64 = 0.125;\n\n#[derive(Debug, Clone, Default)]\nstruct CodexFileState {\n    read_offset: u64,\n    last_total_tokens: u64,\n    last_input_tokens: u64,\n    last_output_tokens: u64,\n    last_cached_input_tokens: u64,\n}\n\n/// Machine-wide stats for today, aggregated across Claude and Codex logs.\n/// Updated incrementally — only new bytes are parsed on each refresh.\n#[derive(Debug, Clone)]\npub struct GlobalStats {\n    // Aggregate totals displayed in the UI.\n    pub tokens_in: u64,\n    pub tokens_out: u64,\n    pub tokens_cache_read: u64,\n    pub tokens_cache_write: u64,\n    // Provider breakdown used for cost calculations.\n    pub claude_tokens_in: u64,\n    pub claude_tokens_out: u64,\n    pub claude_tokens_cache_read: u64,\n    pub claude_tokens_cache_write: u64,\n    pub codex_tokens_in: u64,\n    pub codex_tokens_out: u64,\n    pub codex_tokens_cache_read: u64,\n    /// Per-file read offsets for incremental Claude log reading.\n    file_offsets: HashMap<PathBuf, u64>,\n    /// Per-file incremental state for Codex token_count parsing.\n    codex_file_states: HashMap<PathBuf, CodexFileState>,\n    /// Cached file list to avoid recursive scans on every refresh.\n    known_claude_files: Vec<PathBuf>,\n    /// Cached file list to avoid recursive scans on every refresh.\n    known_codex_files: Vec<PathBuf>,\n    /// Unix timestamp of last recursive file discovery.\n    last_file_discovery_ts: i64,\n    /// Date string (YYYY-MM-DD) these stats are for; reset when date changes.\n    date: String,\n}\n\nimpl Default for GlobalStats {\n    fn default() -> Self {\n        Self {\n            tokens_in: 0,\n            tokens_out: 0,\n            tokens_cache_read: 0,\n            tokens_cache_write: 0,\n            claude_tokens_in: 0,\n            claude_tokens_out: 0,\n            claude_tokens_cache_read: 0,\n            claude_tokens_cache_write: 0,\n            codex_tokens_in: 0,\n            codex_tokens_out: 0,\n            codex_tokens_cache_read: 0,\n            file_offsets: HashMap::new(),\n            codex_file_states: HashMap::new(),\n            known_claude_files: Vec::new(),\n            known_codex_files: Vec::new(),\n            last_file_discovery_ts: 0,\n            date: String::new(),\n        }\n    }\n}\n\nimpl GlobalStats {\n    /// Estimated cost in USD using provider-specific pricing.\n    /// Claude: Sonnet ($3 in / $15 out / $0.30 cache-read / $3.75 cache-write per MTok).\n    /// Codex: GPT-5 Codex estimate ($1.25 in / $10 out / $0.125 cache-read per MTok).\n    pub fn cost_usd(&self) -> f64 {\n        let has_breakdown = self.claude_tokens_in > 0\n            || self.claude_tokens_out > 0\n            || self.claude_tokens_cache_read > 0\n            || self.claude_tokens_cache_write > 0\n            || self.codex_tokens_in > 0\n            || self.codex_tokens_out > 0\n            || self.codex_tokens_cache_read > 0;\n\n        // Backward compatibility for tests/older state that only set aggregate fields.\n        if !has_breakdown {\n            let input = self.tokens_in as f64 * 3.0 / 1_000_000.0;\n            let output = self.tokens_out as f64 * 15.0 / 1_000_000.0;\n            let cache_read = self.tokens_cache_read as f64 * 0.30 / 1_000_000.0;\n            let cache_write = self.tokens_cache_write as f64 * 3.75 / 1_000_000.0;\n            return input + output + cache_read + cache_write;\n        }\n\n        let claude_input = self.claude_tokens_in as f64 * 3.0 / 1_000_000.0;\n        let claude_output = self.claude_tokens_out as f64 * 15.0 / 1_000_000.0;\n        let claude_cache_read = self.claude_tokens_cache_read as f64 * 0.30 / 1_000_000.0;\n        let claude_cache_write = self.claude_tokens_cache_write as f64 * 3.75 / 1_000_000.0;\n\n        let codex_uncached_input_tokens = self\n            .codex_tokens_in\n            .saturating_sub(self.codex_tokens_cache_read);\n        let codex_input =\n            codex_uncached_input_tokens as f64 * CODEX_INPUT_USD_PER_MTOK / 1_000_000.0;\n        let codex_output = self.codex_tokens_out as f64 * CODEX_OUTPUT_USD_PER_MTOK / 1_000_000.0;\n        let codex_cache_read =\n            self.codex_tokens_cache_read as f64 * CODEX_CACHE_READ_USD_PER_MTOK / 1_000_000.0;\n\n        claude_input\n            + claude_output\n            + claude_cache_read\n            + claude_cache_write\n            + codex_input\n            + codex_output\n            + codex_cache_read\n    }\n}\n\n/// Scan Claude + Codex logs and sum today's token usage.\n/// Incremental: only reads new bytes per file after the first call.\n/// Resets at midnight (date change).\npub fn update_global_stats(stats: &mut GlobalStats) {\n    let today = chrono::Local::now().format(\"%Y-%m-%d\").to_string();\n\n    // Reset on date change\n    if stats.date != today {\n        stats.tokens_in = 0;\n        stats.tokens_out = 0;\n        stats.tokens_cache_read = 0;\n        stats.tokens_cache_write = 0;\n        stats.claude_tokens_in = 0;\n        stats.claude_tokens_out = 0;\n        stats.claude_tokens_cache_read = 0;\n        stats.claude_tokens_cache_write = 0;\n        stats.codex_tokens_in = 0;\n        stats.codex_tokens_out = 0;\n        stats.codex_tokens_cache_read = 0;\n        stats.file_offsets.clear();\n        stats.codex_file_states.clear();\n        stats.known_claude_files.clear();\n        stats.known_codex_files.clear();\n        stats.last_file_discovery_ts = 0;\n        stats.date = today.clone();\n    }\n\n    update_global_stats_inner(stats, &today, None);\n}\n\n/// Inner implementation that accepts an optional base_dir for testability.\nfn update_global_stats_inner(\n    stats: &mut GlobalStats,\n    today: &str,\n    base_dir: Option<&std::path::Path>,\n) {\n    let (claude_projects_dir, codex_sessions_dir) = match base_dir {\n        Some(dir) => (dir.to_path_buf(), dir.join(\".codex\").join(\"sessions\")),\n        None => {\n            let home = match std::env::var(\"HOME\") {\n                Ok(h) => h,\n                Err(_) => return,\n            };\n            (\n                PathBuf::from(&home).join(\".claude\").join(\"projects\"),\n                PathBuf::from(&home).join(\".codex\").join(\"sessions\"),\n            )\n        }\n    };\n\n    let now_ts = chrono::Utc::now().timestamp();\n    let needs_discovery = stats.last_file_discovery_ts == 0\n        || now_ts - stats.last_file_discovery_ts >= FILE_DISCOVERY_INTERVAL_SECS;\n\n    if needs_discovery {\n        let mut claude_files = Vec::new();\n        collect_jsonl_files(&claude_projects_dir, &mut claude_files, 0);\n        stats.known_claude_files = claude_files;\n\n        let mut codex_files = Vec::new();\n        collect_jsonl_files(&codex_sessions_dir, &mut codex_files, 0);\n        stats.known_codex_files = codex_files;\n\n        let claude_file_set: HashSet<PathBuf> = stats.known_claude_files.iter().cloned().collect();\n        stats\n            .file_offsets\n            .retain(|p, _| claude_file_set.contains(p));\n\n        let codex_file_set: HashSet<PathBuf> = stats.known_codex_files.iter().cloned().collect();\n        stats\n            .codex_file_states\n            .retain(|p, _| codex_file_set.contains(p));\n\n        stats.last_file_discovery_ts = now_ts;\n    }\n\n    // Process Claude files incrementally.\n    let claude_files = stats.known_claude_files.clone();\n    for path in claude_files {\n        process_claude_global_file(&path, stats, today);\n    }\n\n    // Process Codex files incrementally.\n    let codex_files = stats.known_codex_files.clone();\n    for path in codex_files {\n        process_codex_global_file(&path, stats, today);\n    }\n}\n\nfn add_claude_usage(\n    stats: &mut GlobalStats,\n    input_tokens: u64,\n    output_tokens: u64,\n    cache_read_tokens: u64,\n    cache_write_tokens: u64,\n) {\n    stats.tokens_in += input_tokens;\n    stats.tokens_out += output_tokens;\n    stats.tokens_cache_read += cache_read_tokens;\n    stats.tokens_cache_write += cache_write_tokens;\n\n    stats.claude_tokens_in += input_tokens;\n    stats.claude_tokens_out += output_tokens;\n    stats.claude_tokens_cache_read += cache_read_tokens;\n    stats.claude_tokens_cache_write += cache_write_tokens;\n}\n\nfn add_codex_usage(\n    stats: &mut GlobalStats,\n    input_tokens: u64,\n    output_tokens: u64,\n    cache_read_tokens: u64,\n) {\n    stats.tokens_in += input_tokens;\n    stats.tokens_out += output_tokens;\n    stats.tokens_cache_read += cache_read_tokens;\n\n    stats.codex_tokens_in += input_tokens;\n    stats.codex_tokens_out += output_tokens;\n    stats.codex_tokens_cache_read += cache_read_tokens;\n}\n\nfn process_claude_global_file(path: &PathBuf, stats: &mut GlobalStats, today: &str) {\n    let mut file = match std::fs::File::open(path) {\n        Ok(f) => f,\n        Err(_) => return,\n    };\n    let file_len = match file.metadata() {\n        Ok(m) => m.len(),\n        Err(_) => return,\n    };\n\n    let offset = stats.file_offsets.get(path).copied().unwrap_or(0);\n    if file_len <= offset {\n        return;\n    }\n\n    if offset > 0 && file.seek(SeekFrom::Start(offset)).is_err() {\n        return;\n    }\n\n    let mut buf = Vec::new();\n    if file.read_to_end(&mut buf).is_err() {\n        return;\n    }\n    let text = String::from_utf8_lossy(&buf);\n\n    for line in text.lines() {\n        if line.len() < 10 {\n            continue;\n        }\n        if !line.contains(today) || !line.contains(\"\\\"assistant\\\"\") || !line.contains(\"\\\"usage\\\"\") {\n            continue;\n        }\n        if let Ok(v) = serde_json::from_str::<serde_json::Value>(line) {\n            if v.get(\"type\").and_then(|t| t.as_str()) != Some(\"assistant\") {\n                continue;\n            }\n            if let Some(usage) = v.get(\"message\").and_then(|m| m.get(\"usage\")) {\n                add_claude_usage(\n                    stats,\n                    usage\n                        .get(\"input_tokens\")\n                        .and_then(|t| t.as_u64())\n                        .unwrap_or(0),\n                    usage\n                        .get(\"output_tokens\")\n                        .and_then(|t| t.as_u64())\n                        .unwrap_or(0),\n                    usage\n                        .get(\"cache_read_input_tokens\")\n                        .and_then(|t| t.as_u64())\n                        .unwrap_or(0),\n                    usage\n                        .get(\"cache_creation_input_tokens\")\n                        .and_then(|t| t.as_u64())\n                        .unwrap_or(0),\n                );\n            }\n        }\n    }\n\n    stats.file_offsets.insert(path.clone(), file_len);\n}\n\nfn process_codex_global_file(path: &PathBuf, stats: &mut GlobalStats, today: &str) {\n    let mut file = match std::fs::File::open(path) {\n        Ok(f) => f,\n        Err(_) => return,\n    };\n    let file_len = match file.metadata() {\n        Ok(m) => m.len(),\n        Err(_) => return,\n    };\n\n    let mut last_total_tokens = stats\n        .codex_file_states\n        .get(path)\n        .map(|s| s.last_total_tokens)\n        .unwrap_or(0);\n    let mut last_input_tokens = stats\n        .codex_file_states\n        .get(path)\n        .map(|s| s.last_input_tokens)\n        .unwrap_or(0);\n    let mut last_output_tokens = stats\n        .codex_file_states\n        .get(path)\n        .map(|s| s.last_output_tokens)\n        .unwrap_or(0);\n    let mut last_cached_input_tokens = stats\n        .codex_file_states\n        .get(path)\n        .map(|s| s.last_cached_input_tokens)\n        .unwrap_or(0);\n    let offset = stats\n        .codex_file_states\n        .get(path)\n        .map(|s| s.read_offset)\n        .unwrap_or(0);\n\n    if file_len <= offset {\n        return;\n    }\n\n    if offset > 0 && file.seek(SeekFrom::Start(offset)).is_err() {\n        return;\n    }\n\n    let mut buf = Vec::new();\n    if file.read_to_end(&mut buf).is_err() {\n        return;\n    }\n    let text = String::from_utf8_lossy(&buf);\n\n    for line in text.lines() {\n        if line.len() < 20 {\n            continue;\n        }\n        if !line.contains(\"\\\"token_count\\\"\") || !line.contains(\"\\\"total_token_usage\\\"\") {\n            continue;\n        }\n\n        let v = match serde_json::from_str::<serde_json::Value>(line) {\n            Ok(v) => v,\n            Err(_) => continue,\n        };\n\n        if v.get(\"type\").and_then(|t| t.as_str()) != Some(\"event_msg\") {\n            continue;\n        }\n        let payload = match v.get(\"payload\") {\n            Some(p) => p,\n            None => continue,\n        };\n        if payload.get(\"type\").and_then(|t| t.as_str()) != Some(\"token_count\") {\n            continue;\n        }\n\n        let totals = match payload.get(\"info\").and_then(|i| i.get(\"total_token_usage\")) {\n            Some(t) => t,\n            None => continue,\n        };\n\n        let total_input_tokens = totals\n            .get(\"input_tokens\")\n            .and_then(|t| t.as_u64())\n            .unwrap_or(0);\n        let total_output_tokens = totals\n            .get(\"output_tokens\")\n            .and_then(|t| t.as_u64())\n            .unwrap_or(0);\n        let total_cached_input_tokens = totals\n            .get(\"cached_input_tokens\")\n            .and_then(|t| t.as_u64())\n            .unwrap_or(0);\n        let total_tokens = totals\n            .get(\"total_tokens\")\n            .and_then(|t| t.as_u64())\n            .unwrap_or(total_input_tokens.saturating_add(total_output_tokens));\n\n        let is_today = v\n            .get(\"timestamp\")\n            .and_then(|t| t.as_str())\n            .is_some_and(|ts| ts.starts_with(today));\n\n        if total_tokens > last_total_tokens {\n            if is_today {\n                let delta_input = total_input_tokens.saturating_sub(last_input_tokens);\n                let delta_output = total_output_tokens.saturating_sub(last_output_tokens);\n                let delta_cache_read =\n                    total_cached_input_tokens.saturating_sub(last_cached_input_tokens);\n                add_codex_usage(stats, delta_input, delta_output, delta_cache_read);\n            }\n        }\n\n        // Always advance snapshot state; duplicate totals are ignored by the delta check above.\n        last_total_tokens = total_tokens;\n        last_input_tokens = total_input_tokens;\n        last_output_tokens = total_output_tokens;\n        last_cached_input_tokens = total_cached_input_tokens;\n    }\n\n    stats.codex_file_states.insert(\n        path.clone(),\n        CodexFileState {\n            read_offset: file_len,\n            last_total_tokens,\n            last_input_tokens,\n            last_output_tokens,\n            last_cached_input_tokens,\n        },\n    );\n}\n\n/// Recursively collect all `.jsonl` files under a directory.\n/// Bounded to 4 levels deep to avoid runaway walks.\nfn collect_jsonl_files(dir: &std::path::Path, out: &mut Vec<PathBuf>, depth: usize) {\n    if depth > 4 {\n        return;\n    }\n    let entries = match std::fs::read_dir(dir) {\n        Ok(rd) => rd,\n        Err(_) => return,\n    };\n    for entry in entries.flatten() {\n        let path = entry.path();\n        if path.is_dir() {\n            collect_jsonl_files(&path, out, depth + 1);\n        } else if path.extension().and_then(|e| e.to_str()) == Some(\"jsonl\") {\n            out.push(path);\n        }\n    }\n}\n\n/// Get the pane PID for a tmux session.\npub async fn get_pane_pid(tmux_name: &str) -> Option<u32> {\n    let output = run_cmd_timeout(Command::new(\"tmux\").args([\n        \"list-panes\",\n        \"-t\",\n        tmux_name,\n        \"-F\",\n        \"#{pane_pid}\",\n    ]))\n    .await\n    .ok()?;\n\n    if !output.status.success() {\n        return None;\n    }\n\n    String::from_utf8_lossy(&output.stdout).trim().parse().ok()\n}\n\n/// Extract --session-id UUID from a command line string.\n/// Handles both `--session-id <uuid>` and `--session-id=<uuid>` forms.\nfn parse_session_id_from_cmdline(cmdline: &str) -> Option<String> {\n    let mut args = cmdline.split_whitespace();\n    while let Some(arg) = args.next() {\n        if arg == \"--session-id\" {\n            if let Some(value) = args.next() {\n                if is_uuid(value) {\n                    return Some(value.to_string());\n                }\n            }\n        }\n        // Also handle --session-id=<uuid> form\n        if let Some(value) = arg.strip_prefix(\"--session-id=\") {\n            if is_uuid(value) {\n                return Some(value.to_string());\n            }\n        }\n    }\n    None\n}\n\n/// Extract --session-id from a process's command line arguments.\n/// This is the most reliable way to get the Claude session UUID.\nasync fn resolve_uuid_from_cmdline(pid: u32) -> Option<String> {\n    let output =\n        run_cmd_timeout(Command::new(\"ps\").args([\"-p\", &pid.to_string(), \"-o\", \"command=\"]))\n            .await\n            .ok()?;\n\n    if !output.status.success() {\n        return None;\n    }\n\n    let cmdline = String::from_utf8_lossy(&output.stdout);\n    parse_session_id_from_cmdline(&cmdline)\n}\n\n/// Collect all descendant PIDs of a process (children, grandchildren, etc.).\n/// Bounded by `MAX_TREE_DEPTH` levels and `MAX_TREE_PIDS` total to prevent\n/// runaway walks on pathological process trees.\nasync fn collect_descendant_pids(pid: u32) -> Vec<u32> {\n    let mut all_pids = vec![pid];\n    // Process level-by-level for depth tracking\n    let mut current_level = vec![pid];\n    let mut depth = 0;\n\n    while !current_level.is_empty() && depth < MAX_TREE_DEPTH && all_pids.len() < MAX_TREE_PIDS {\n        let mut next_level = Vec::new();\n\n        for parent in &current_level {\n            if all_pids.len() >= MAX_TREE_PIDS {\n                break;\n            }\n            let output =\n                run_cmd_timeout(Command::new(\"pgrep\").args([\"-P\", &parent.to_string()])).await;\n\n            if let Ok(output) = output {\n                let stdout = String::from_utf8_lossy(&output.stdout);\n                for line in stdout.lines() {\n                    if all_pids.len() >= MAX_TREE_PIDS {\n                        break;\n                    }\n                    if let Ok(child_pid) = line.trim().parse::<u32>() {\n                        all_pids.push(child_pid);\n                        next_level.push(child_pid);\n                    }\n                }\n            }\n        }\n\n        current_level = next_level;\n        depth += 1;\n    }\n\n    all_pids\n}\n\n/// Parse lsof output to find a `.claude/tasks/<uuid>/` path.\nfn parse_uuid_from_lsof_output(output: &str) -> Option<String> {\n    for line in output.lines() {\n        if let Some(idx) = line.find(\".claude/tasks/\") {\n            let rest = &line[idx + \".claude/tasks/\".len()..];\n            if rest.len() >= 36 {\n                let candidate = &rest[..36];\n                if is_uuid(candidate) {\n                    return Some(candidate.to_string());\n                }\n            }\n        }\n    }\n    None\n}\n\n/// Use lsof to find the Claude tasks UUID from a set of PIDs.\n/// Fallback method — checks all provided PIDs for open .claude/tasks/ file descriptors.\nasync fn resolve_uuid_from_lsof_pids(pids: &[u32]) -> Option<String> {\n    if pids.is_empty() {\n        return None;\n    }\n\n    let pid_list = pids\n        .iter()\n        .map(|p| p.to_string())\n        .collect::<Vec<_>>()\n        .join(\",\");\n\n    let output = run_cmd_timeout(Command::new(\"lsof\").args([\"-p\", &pid_list]))\n        .await\n        .ok()?;\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    parse_uuid_from_lsof_output(&stdout)\n}\n\nfn is_uuid(s: &str) -> bool {\n    s.len() == 36\n        && s.chars().enumerate().all(|(i, c)| {\n            if i == 8 || i == 13 || i == 18 || i == 23 {\n                c == '-'\n            } else {\n                c.is_ascii_hexdigit()\n            }\n        })\n}\n\n/// Resolve the Claude session UUID for a tmux session.\n/// Tries --session-id from process args first (reliable), then walks the process tree.\npub async fn resolve_session_uuid(tmux_name: &str) -> Option<String> {\n    let pid = get_pane_pid(tmux_name).await?;\n\n    // Try command line --session-id on pane PID and all descendants\n    let all_pids = collect_descendant_pids(pid).await;\n    for &p in &all_pids {\n        if let Some(uuid) = resolve_uuid_from_cmdline(p).await {\n            return Some(uuid);\n        }\n    }\n\n    // Fall back to lsof on the full process tree\n    resolve_uuid_from_lsof_pids(&all_pids).await\n}\n\n/// Convert a CWD path to the Claude projects directory escape format.\n/// e.g. \"/Users/monkey/hydra\" → \"-Users-monkey-hydra\"\nfn escape_project_path(cwd: &str) -> String {\n    cwd.replace('/', \"-\")\n}\n\nfn extract_assistant_message_text(v: &serde_json::Value) -> Option<String> {\n    let content = v\n        .get(\"message\")\n        .and_then(|m| m.get(\"content\"))\n        .and_then(|c| c.as_array())?;\n\n    let mut parts = Vec::new();\n    for item in content {\n        if let Some(text) = item.get(\"text\").and_then(|t| t.as_str()) {\n            parts.push(text);\n        }\n    }\n\n    if parts.is_empty() {\n        None\n    } else {\n        Some(parts.join(\" \"))\n    }\n}\n\n/// Read the last assistant message from a Claude JSONL log file.\n/// Reads only the tail of the file for efficiency on large logs.\n#[allow(dead_code)]\npub fn read_last_assistant_message(cwd: &str, uuid: &str) -> Option<String> {\n    let escaped = escape_project_path(cwd);\n    let home = std::env::var(\"HOME\").ok()?;\n    let path = PathBuf::from(&home)\n        .join(\".claude\")\n        .join(\"projects\")\n        .join(&escaped)\n        .join(format!(\"{uuid}.jsonl\"));\n\n    let mut file = std::fs::File::open(&path).ok()?;\n    let file_len = file.metadata().ok()?.len();\n\n    // Read last 200KB — enough to find the most recent assistant message\n    let chunk_size: u64 = 200 * 1024;\n    let start = file_len.saturating_sub(chunk_size);\n    file.seek(SeekFrom::Start(start)).ok()?;\n\n    let mut buf = Vec::new();\n    file.read_to_end(&mut buf).ok()?;\n    let text = String::from_utf8_lossy(&buf);\n\n    let mut last_text: Option<String> = None;\n\n    for line in text.lines() {\n        // Quick filter before JSON parse\n        if !line.contains(\"\\\"assistant\\\"\") {\n            continue;\n        }\n        let v: serde_json::Value = match serde_json::from_str(line) {\n            Ok(v) => v,\n            Err(_) => continue, // partial line from mid-file seek\n        };\n        if v.get(\"type\").and_then(|t| t.as_str()) != Some(\"assistant\") {\n            continue;\n        }\n        if let Some(text) = extract_assistant_message_text(&v) {\n            last_text = Some(text);\n        }\n    }\n\n    // Condense whitespace for display\n    last_text.map(|t| t.split_whitespace().collect::<Vec<_>>().join(\" \"))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    /// Lock to serialize tests that modify the HOME environment variable.\n    /// HOME is process-global, so parallel tests that set_var(\"HOME\", ...) race.\n    static HOME_LOCK: std::sync::Mutex<()> = std::sync::Mutex::new(());\n\n    /// RAII guard that saves HOME, sets it to a new value, and restores on drop.\n    /// Also acquires HOME_LOCK for thread safety.\n    struct HomeGuard {\n        orig: Option<String>,\n        _lock: std::sync::MutexGuard<'static, ()>,\n    }\n\n    impl HomeGuard {\n        /// Save current HOME, set to new path, and acquire the HOME_LOCK.\n        fn set(path: &std::path::Path) -> Self {\n            let lock = HOME_LOCK.lock().unwrap();\n            let orig = std::env::var(\"HOME\").ok();\n            std::env::set_var(\"HOME\", path);\n            Self { orig, _lock: lock }\n        }\n\n        /// Save current HOME, remove it, and acquire the HOME_LOCK.\n        fn remove() -> Self {\n            let lock = HOME_LOCK.lock().unwrap();\n            let orig = std::env::var(\"HOME\").ok();\n            std::env::remove_var(\"HOME\");\n            Self { orig, _lock: lock }\n        }\n    }\n\n    impl Drop for HomeGuard {\n        fn drop(&mut self) {\n            if let Some(h) = &self.orig {\n                std::env::set_var(\"HOME\", h);\n            }\n        }\n    }\n\n    // ── format_tokens tests ──────────────────────────────────────────\n\n    #[test]\n    fn format_tokens_small() {\n        assert_eq!(format_tokens(0), \"0\");\n        assert_eq!(format_tokens(999), \"999\");\n    }\n\n    #[test]\n    fn format_tokens_thousands() {\n        assert_eq!(format_tokens(1000), \"1.0k\");\n        assert_eq!(format_tokens(1234), \"1.2k\");\n        assert_eq!(format_tokens(45300), \"45.3k\");\n        assert_eq!(format_tokens(999999), \"1000.0k\");\n    }\n\n    #[test]\n    fn format_tokens_millions() {\n        assert_eq!(format_tokens(1_000_000), \"1.0M\");\n        assert_eq!(format_tokens(1_234_567), \"1.2M\");\n    }\n\n    // ── format_cost tests ────────────────────────────────────────────\n\n    #[test]\n    fn format_cost_zero() {\n        assert_eq!(format_cost(0.0), \"$0.00\");\n        assert_eq!(format_cost(0.004), \"$0.00\");\n    }\n\n    #[test]\n    fn format_cost_normal() {\n        assert_eq!(format_cost(0.42), \"$0.42\");\n        assert_eq!(format_cost(1.23), \"$1.23\");\n    }\n\n    #[test]\n    fn format_cost_large() {\n        assert_eq!(format_cost(12.5), \"$12\");\n    }\n\n    // ── SessionStats cost tests ──────────────────────────────────────\n\n    #[test]\n    fn session_stats_cost_empty() {\n        let stats = SessionStats::default();\n        assert!((stats.cost_usd() - 0.0).abs() < f64::EPSILON);\n    }\n\n    #[test]\n    fn session_stats_cost_calculation() {\n        let stats = SessionStats {\n            tokens_in: 1_000_000,        // $3.00\n            tokens_out: 100_000,         // $1.50\n            tokens_cache_read: 500_000,  // $0.15\n            tokens_cache_write: 200_000, // $0.75\n            ..Default::default()\n        };\n        let cost = stats.cost_usd();\n        assert!(\n            (cost - 5.40).abs() < 0.01,\n            \"expected ~$5.40, got ${cost:.2}\"\n        );\n    }\n\n    // ── update_session_stats tests ───────────────────────────────────\n    // Tests use update_session_stats_from_path() directly to avoid\n    // HOME env var races when tests run in parallel.\n\n    fn write_tmp_jsonl(name: &str, lines: &[&str]) -> PathBuf {\n        use std::io::Write;\n        let path = std::env::temp_dir().join(format!(\"hydra_test_{name}.jsonl\"));\n        let mut f = std::fs::File::create(&path).unwrap();\n        for line in lines {\n            writeln!(f, \"{line}\").unwrap();\n        }\n        path\n    }\n\n    #[test]\n    fn update_session_stats_parses_tokens_and_turns() {\n        let path = write_tmp_jsonl(\n            \"stats_tokens\",\n            &[\n                r#\"{\"type\":\"assistant\",\"message\":{\"usage\":{\"input_tokens\":1000,\"output_tokens\":200,\"cache_read_input_tokens\":500,\"cache_creation_input_tokens\":100},\"content\":[{\"type\":\"text\",\"text\":\"hello\"}]}}\"#,\n                r#\"{\"type\":\"assistant\",\"message\":{\"usage\":{\"input_tokens\":2000,\"output_tokens\":300,\"cache_read_input_tokens\":0,\"cache_creation_input_tokens\":0},\"content\":[{\"type\":\"text\",\"text\":\"world\"}]}}\"#,\n            ],\n        );\n\n        let mut stats = SessionStats::default();\n        update_session_stats_from_path(&path, &mut stats);\n\n        assert_eq!(stats.turns, 2);\n        assert_eq!(stats.tokens_in, 3000);\n        assert_eq!(stats.tokens_out, 500);\n        assert_eq!(stats.tokens_cache_read, 500);\n        assert_eq!(stats.tokens_cache_write, 100);\n        let _ = std::fs::remove_file(&path);\n    }\n\n    #[test]\n    fn update_session_stats_counts_tools() {\n        let path = write_tmp_jsonl(\n            \"stats_tools\",\n            &[\n                r#\"{\"type\":\"assistant\",\"message\":{\"usage\":{\"input_tokens\":100,\"output_tokens\":50,\"cache_read_input_tokens\":0,\"cache_creation_input_tokens\":0},\"content\":[{\"type\":\"tool_use\",\"name\":\"Edit\",\"id\":\"t1\",\"input\":{}},{\"type\":\"tool_use\",\"name\":\"Bash\",\"id\":\"t2\",\"input\":{}},{\"type\":\"tool_use\",\"name\":\"Write\",\"id\":\"t3\",\"input\":{}}]}}\"#,\n            ],\n        );\n\n        let mut stats = SessionStats::default();\n        update_session_stats_from_path(&path, &mut stats);\n\n        assert_eq!(stats.edits, 2, \"Edit + Write = 2 edits\");\n        assert_eq!(stats.bash_cmds, 1);\n        let _ = std::fs::remove_file(&path);\n    }\n\n    #[test]\n    fn update_session_stats_tracks_files() {\n        let path = write_tmp_jsonl(\n            \"stats_files\",\n            &[\n                r#\"{\"type\":\"user\",\"toolUseResult\":{\"filenames\":[\"/src/main.rs\",\"/src/app.rs\"]}}\"#,\n                r#\"{\"type\":\"user\",\"toolUseResult\":{\"filenames\":[\"/src/main.rs\"]}}\"#,\n            ],\n        );\n\n        let mut stats = SessionStats::default();\n        update_session_stats_from_path(&path, &mut stats);\n\n        assert_eq!(stats.file_count(), 2, \"should deduplicate filenames\");\n        let _ = std::fs::remove_file(&path);\n    }\n\n    #[test]\n    fn update_session_stats_incremental() {\n        use std::io::Write;\n\n        let path = std::env::temp_dir().join(format!(\n            \"hydra_test_stats_incr_{:?}.jsonl\",\n            std::thread::current().id()\n        ));\n        // Clean up any leftover\n        let _ = std::fs::remove_file(&path);\n\n        let mut f = std::fs::File::create(&path).unwrap();\n        writeln!(f, r#\"{{\"type\":\"assistant\",\"message\":{{\"usage\":{{\"input_tokens\":100,\"output_tokens\":50,\"cache_read_input_tokens\":0,\"cache_creation_input_tokens\":0}},\"content\":[{{\"type\":\"text\",\"text\":\"first\"}}]}}}}\"#).unwrap();\n        drop(f);\n\n        let mut stats = SessionStats::default();\n        update_session_stats_from_path(&path, &mut stats);\n        assert_eq!(stats.turns, 1);\n        let offset_after_first = stats.read_offset;\n        assert!(offset_after_first > 0);\n\n        // Append more data\n        let mut f = std::fs::OpenOptions::new()\n            .append(true)\n            .open(&path)\n            .unwrap();\n        writeln!(f, r#\"{{\"type\":\"assistant\",\"message\":{{\"usage\":{{\"input_tokens\":200,\"output_tokens\":100,\"cache_read_input_tokens\":0,\"cache_creation_input_tokens\":0}},\"content\":[{{\"type\":\"text\",\"text\":\"second\"}}]}}}}\"#).unwrap();\n        drop(f);\n\n        // Second call should only parse new data\n        update_session_stats_from_path(&path, &mut stats);\n        assert_eq!(stats.turns, 2, \"should accumulate from incremental read\");\n        assert_eq!(stats.tokens_in, 300);\n        assert!(stats.read_offset > offset_after_first);\n\n        // Third call with no new data should be a no-op\n        update_session_stats_from_path(&path, &mut stats);\n        assert_eq!(stats.turns, 2, \"no-op when no new data\");\n        let _ = std::fs::remove_file(&path);\n    }\n\n    #[test]\n    fn update_session_stats_no_file() {\n        let mut stats = SessionStats::default();\n        update_session_stats_from_path(std::path::Path::new(\"/nonexistent/file.jsonl\"), &mut stats);\n        assert_eq!(stats.turns, 0);\n    }\n\n    #[test]\n    fn stats_skips_short_lines() {\n        let path = write_tmp_jsonl(\n            \"stats_short\",\n            &[\n                \"short\", // < 10 chars, should be skipped\n                \"\",      // empty, should be skipped\n                r#\"{\"type\":\"assistant\",\"message\":{\"usage\":{\"input_tokens\":100,\"output_tokens\":50,\"cache_read_input_tokens\":0,\"cache_creation_input_tokens\":0},\"content\":[{\"type\":\"text\",\"text\":\"ok\"}]}}\"#,\n            ],\n        );\n\n        let mut stats = SessionStats::default();\n        update_session_stats_from_path(&path, &mut stats);\n        assert_eq!(stats.turns, 1, \"should skip short lines\");\n        let _ = std::fs::remove_file(&path);\n    }\n\n    #[test]\n    fn stats_unknown_tool_name_ignored() {\n        let path = write_tmp_jsonl(\n            \"stats_unknown_tool\",\n            &[\n                r#\"{\"type\":\"assistant\",\"message\":{\"usage\":{\"input_tokens\":100,\"output_tokens\":50,\"cache_read_input_tokens\":0,\"cache_creation_input_tokens\":0},\"content\":[{\"type\":\"tool_use\",\"name\":\"UnknownTool\",\"id\":\"t1\",\"input\":{}}]}}\"#,\n            ],\n        );\n\n        let mut stats = SessionStats::default();\n        update_session_stats_from_path(&path, &mut stats);\n        assert_eq!(stats.turns, 1);\n        assert_eq!(stats.edits, 0);\n        assert_eq!(stats.bash_cmds, 0);\n        let _ = std::fs::remove_file(&path);\n    }\n\n    #[test]\n    fn stats_assistant_without_usage_not_counted() {\n        let path = write_tmp_jsonl(\n            \"stats_no_usage\",\n            &[\n                // \"assistant\" in line but no \"usage\" — won't match fast path\n                r#\"{\"type\":\"assistant\",\"message\":{\"content\":[{\"type\":\"text\",\"text\":\"no usage field here\"}]}}\"#,\n            ],\n        );\n\n        let mut stats = SessionStats::default();\n        update_session_stats_from_path(&path, &mut stats);\n        assert_eq!(stats.turns, 0, \"no usage = not counted as turn\");\n        let _ = std::fs::remove_file(&path);\n    }\n\n    #[test]\n    fn stats_file_count_deduplicates() {\n        let mut stats = SessionStats::default();\n        stats.touch_file(\"/a.rs\".to_string());\n        stats.touch_file(\"/a.rs\".to_string());\n        stats.touch_file(\"/b.rs\".to_string());\n        assert_eq!(stats.file_count(), 2);\n    }\n\n    #[test]\n    fn touch_file_maintains_recency_order() {\n        let mut stats = SessionStats::default();\n        stats.touch_file(\"/a.rs\".to_string());\n        stats.touch_file(\"/b.rs\".to_string());\n        stats.touch_file(\"/c.rs\".to_string());\n        assert_eq!(stats.recent_files, vec![\"/a.rs\", \"/b.rs\", \"/c.rs\"]);\n\n        // Re-touching /a.rs moves it to the end\n        stats.touch_file(\"/a.rs\".to_string());\n        assert_eq!(stats.recent_files, vec![\"/b.rs\", \"/c.rs\", \"/a.rs\"]);\n        assert_eq!(stats.file_count(), 3); // dedup set unchanged\n    }\n\n    #[test]\n    fn touch_file_caps_history_size() {\n        let mut stats = SessionStats::default();\n        let total = MAX_SESSION_TRACKED_FILES + 50;\n        for i in 0..total {\n            stats.touch_file(format!(\"/file-{i}.rs\"));\n        }\n\n        assert_eq!(stats.files.len(), MAX_SESSION_TRACKED_FILES);\n        assert_eq!(stats.recent_files.len(), MAX_SESSION_TRACKED_FILES);\n        assert!(\n            !stats.files.contains(\"/file-0.rs\"),\n            \"oldest files should be evicted at capacity\"\n        );\n        assert!(\n            stats.files.contains(&format!(\"/file-{}.rs\", total - 1)),\n            \"newest file should remain tracked\"\n        );\n    }\n\n    #[test]\n    fn touch_file_retouch_at_capacity_keeps_size_bounded() {\n        let mut stats = SessionStats::default();\n        for i in 0..MAX_SESSION_TRACKED_FILES {\n            stats.touch_file(format!(\"/file-{i}.rs\"));\n        }\n\n        stats.touch_file(\"/file-0.rs\".to_string());\n        assert_eq!(stats.files.len(), MAX_SESSION_TRACKED_FILES);\n        assert_eq!(stats.recent_files.len(), MAX_SESSION_TRACKED_FILES);\n        assert_eq!(\n            stats.recent_files.last().map(|s| s.as_str()),\n            Some(\"/file-0.rs\")\n        );\n    }\n\n    #[test]\n    fn update_session_stats_populates_recent_files() {\n        let path = write_tmp_jsonl(\n            \"stats_recent\",\n            &[\n                r#\"{\"type\":\"user\",\"toolUseResult\":{\"filenames\":[\"/src/main.rs\",\"/src/app.rs\"]}}\"#,\n                r#\"{\"type\":\"user\",\"toolUseResult\":{\"filenames\":[\"/src/main.rs\"]}}\"#,\n            ],\n        );\n\n        let mut stats = SessionStats::default();\n        update_session_stats_from_path(&path, &mut stats);\n\n        // /src/main.rs was touched twice, so it should be last (most recent)\n        assert_eq!(stats.recent_files, vec![\"/src/app.rs\", \"/src/main.rs\"]);\n        let _ = std::fs::remove_file(&path);\n    }\n\n    // ── task_elapsed tests ────────────────────────────────────────\n\n    #[test]\n    fn task_elapsed_no_timestamps() {\n        let stats = SessionStats::default();\n        assert!(stats.task_elapsed().is_none());\n    }\n\n    #[test]\n    fn task_elapsed_user_only_means_working() {\n        let mut stats = SessionStats::default();\n        // User sent a message 30 seconds ago, no response yet\n        let ts = (chrono::Utc::now() - chrono::Duration::seconds(30))\n            .to_rfc3339_opts(chrono::SecondsFormat::Millis, true);\n        stats.last_user_ts = Some(ts);\n\n        let elapsed = stats.task_elapsed().expect(\"should be working\");\n        assert!(elapsed.as_secs() >= 29 && elapsed.as_secs() <= 31);\n    }\n\n    #[test]\n    fn task_elapsed_assistant_replied_means_idle() {\n        let mut stats = SessionStats::default();\n        let now = chrono::Utc::now();\n        stats.last_user_ts = Some(\n            (now - chrono::Duration::seconds(60))\n                .to_rfc3339_opts(chrono::SecondsFormat::Millis, true),\n        );\n        stats.last_assistant_ts = Some(\n            (now - chrono::Duration::seconds(30))\n                .to_rfc3339_opts(chrono::SecondsFormat::Millis, true),\n        );\n\n        assert!(\n            stats.task_elapsed().is_none(),\n            \"assistant replied = task done\"\n        );\n    }\n\n    #[test]\n    fn task_elapsed_new_user_msg_after_assistant() {\n        let mut stats = SessionStats::default();\n        let now = chrono::Utc::now();\n        // Assistant replied 60s ago, user sent new msg 10s ago\n        stats.last_assistant_ts = Some(\n            (now - chrono::Duration::seconds(60))\n                .to_rfc3339_opts(chrono::SecondsFormat::Millis, true),\n        );\n        stats.last_user_ts = Some(\n            (now - chrono::Duration::seconds(10))\n                .to_rfc3339_opts(chrono::SecondsFormat::Millis, true),\n        );\n\n        let elapsed = stats.task_elapsed().expect(\"new user msg = working\");\n        assert!(elapsed.as_secs() >= 9 && elapsed.as_secs() <= 11);\n    }\n\n    #[test]\n    fn task_elapsed_from_jsonl_parsing() {\n        let path = write_tmp_jsonl(\n            \"stats_timestamps\",\n            &[\n                r#\"{\"type\":\"user\",\"timestamp\":\"2026-01-15T10:00:00.000Z\",\"message\":{\"role\":\"user\",\"content\":\"do something\"}}\"#,\n                r#\"{\"type\":\"assistant\",\"timestamp\":\"2026-01-15T10:00:30.000Z\",\"message\":{\"role\":\"assistant\",\"usage\":{\"input_tokens\":100,\"output_tokens\":50,\"cache_read_input_tokens\":0,\"cache_creation_input_tokens\":0},\"content\":[{\"type\":\"text\",\"text\":\"done\"}]}}\"#,\n                r#\"{\"type\":\"user\",\"timestamp\":\"2026-01-15T10:01:00.000Z\",\"message\":{\"role\":\"user\",\"content\":\"now do this\"}}\"#,\n            ],\n        );\n\n        let mut stats = SessionStats::default();\n        update_session_stats_from_path(&path, &mut stats);\n\n        assert_eq!(\n            stats.last_user_ts.as_deref(),\n            Some(\"2026-01-15T10:01:00.000Z\")\n        );\n        assert_eq!(\n            stats.last_assistant_ts.as_deref(),\n            Some(\"2026-01-15T10:00:30.000Z\")\n        );\n        // User message is after assistant → agent should be working\n        assert!(stats.task_elapsed().is_some());\n        let _ = std::fs::remove_file(&path);\n    }\n\n    // ── parse_session_id_from_cmdline tests ────────────────────────\n\n    #[test]\n    fn parse_cmdline_separate_args() {\n        let cmdline = \"claude --dangerously-skip-permissions --session-id 7c04c22f-796f-403a-9521-d83ad13fd60d\";\n        assert_eq!(\n            parse_session_id_from_cmdline(cmdline),\n            Some(\"7c04c22f-796f-403a-9521-d83ad13fd60d\".to_string())\n        );\n    }\n\n    #[test]\n    fn parse_cmdline_equals_form() {\n        let cmdline = \"claude --session-id=7c04c22f-796f-403a-9521-d83ad13fd60d --other-flag\";\n        assert_eq!(\n            parse_session_id_from_cmdline(cmdline),\n            Some(\"7c04c22f-796f-403a-9521-d83ad13fd60d\".to_string())\n        );\n    }\n\n    #[test]\n    fn parse_cmdline_no_session_id() {\n        let cmdline = \"claude --dangerously-skip-permissions\";\n        assert_eq!(parse_session_id_from_cmdline(cmdline), None);\n    }\n\n    #[test]\n    fn parse_cmdline_invalid_uuid_after_flag() {\n        let cmdline = \"claude --session-id not-a-uuid\";\n        assert_eq!(parse_session_id_from_cmdline(cmdline), None);\n    }\n\n    #[test]\n    fn parse_cmdline_empty() {\n        assert_eq!(parse_session_id_from_cmdline(\"\"), None);\n    }\n\n    #[test]\n    fn parse_cmdline_session_id_at_end_no_value() {\n        let cmdline = \"claude --session-id\";\n        assert_eq!(parse_session_id_from_cmdline(cmdline), None);\n    }\n\n    // ── parse_uuid_from_lsof_output tests ───────────────────────────\n\n    #[test]\n    fn parse_lsof_finds_uuid() {\n        let output = \"claude  12345  user  cwd  DIR  1,20  640  /Users/test\\n\\\n                       claude  12345  user  txt  REG  1,20  123  /Users/test/.claude/tasks/7c04c22f-796f-403a-9521-d83ad13fd60d/output.jsonl\\n\\\n                       claude  12345  user  3u   REG  1,20  456  /tmp/some-file\";\n        assert_eq!(\n            parse_uuid_from_lsof_output(output),\n            Some(\"7c04c22f-796f-403a-9521-d83ad13fd60d\".to_string())\n        );\n    }\n\n    #[test]\n    fn parse_lsof_no_uuid() {\n        let output = \"claude  12345  user  cwd  DIR  1,20  640  /Users/test\\n\\\n                       claude  12345  user  txt  REG  1,20  123  /usr/bin/claude\";\n        assert_eq!(parse_uuid_from_lsof_output(output), None);\n    }\n\n    #[test]\n    fn parse_lsof_empty() {\n        assert_eq!(parse_uuid_from_lsof_output(\"\"), None);\n    }\n\n    #[test]\n    fn parse_lsof_invalid_uuid_after_tasks() {\n        let output = \"claude  12345  user  txt  REG  1,20  123  /Users/test/.claude/tasks/not-a-valid-uuid/file\";\n        assert_eq!(parse_uuid_from_lsof_output(output), None);\n    }\n\n    // ── is_uuid tests ────────────────────────────────────────────────\n\n    #[test]\n    fn is_uuid_valid() {\n        assert!(is_uuid(\"7c04c22f-796f-403a-9521-d83ad13fd60d\"));\n    }\n\n    #[test]\n    fn is_uuid_invalid_length() {\n        assert!(!is_uuid(\"7c04c22f-796f-403a-9521\"));\n    }\n\n    #[test]\n    fn is_uuid_invalid_chars() {\n        assert!(!is_uuid(\"zzzzzzzz-zzzz-zzzz-zzzz-zzzzzzzzzzzz\"));\n    }\n\n    #[test]\n    fn is_uuid_missing_dashes() {\n        assert!(!is_uuid(\"7c04c22f0796f0403a09521od83ad13fd60d\"));\n    }\n\n    #[test]\n    fn escape_project_path_basic() {\n        assert_eq!(\n            escape_project_path(\"/Users/monkey/hydra\"),\n            \"-Users-monkey-hydra\"\n        );\n    }\n\n    #[test]\n    fn escape_project_path_root() {\n        assert_eq!(escape_project_path(\"/\"), \"-\");\n    }\n\n    #[test]\n    fn escape_project_path_no_slashes() {\n        assert_eq!(escape_project_path(\"projects\"), \"projects\");\n    }\n\n    #[test]\n    fn escape_project_path_nested() {\n        assert_eq!(\n            escape_project_path(\"/Users/cat/code/my-project\"),\n            \"-Users-cat-code-my-project\"\n        );\n    }\n\n    #[test]\n    fn is_uuid_all_zeros() {\n        assert!(is_uuid(\"00000000-0000-0000-0000-000000000000\"));\n    }\n\n    #[test]\n    fn is_uuid_all_f() {\n        assert!(is_uuid(\"ffffffff-ffff-ffff-ffff-ffffffffffff\"));\n    }\n\n    #[test]\n    fn is_uuid_empty() {\n        assert!(!is_uuid(\"\"));\n    }\n\n    #[test]\n    fn is_uuid_too_long() {\n        assert!(!is_uuid(\"7c04c22f-796f-403a-9521-d83ad13fd60d0\"));\n    }\n\n    #[test]\n    fn is_uuid_wrong_dash_positions() {\n        // Dashes at wrong positions\n        assert!(!is_uuid(\"7c04c22f0796f-403a-9521-d83ad13fd60d\"));\n    }\n\n    // ── read_last_assistant_message tests ─────────────────────────────\n\n    #[test]\n    fn read_last_assistant_message_with_valid_jsonl() {\n        use std::io::Write;\n\n        let tmp_dir = std::env::temp_dir().join(\"hydra_test_logs\");\n        let escaped = escape_project_path(\"/tmp/test-project\");\n        let projects_dir = tmp_dir.join(\".claude\").join(\"projects\").join(&escaped);\n        std::fs::create_dir_all(&projects_dir).unwrap();\n\n        let uuid = \"aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee\";\n        let log_file = projects_dir.join(format!(\"{uuid}.jsonl\"));\n\n        let mut f = std::fs::File::create(&log_file).unwrap();\n        // Write some non-assistant lines\n        writeln!(f, r#\"{{\"type\":\"user\",\"message\":{{\"content\":\"hello\"}}}}\"#).unwrap();\n        // Write an assistant message\n        writeln!(\n            f,\n            r#\"{{\"type\":\"assistant\",\"message\":{{\"content\":[{{\"text\":\"I can help with that!\"}}]}}}}\"#\n        )\n        .unwrap();\n        // Write another assistant message (should be the one returned)\n        writeln!(\n            f,\n            r#\"{{\"type\":\"assistant\",\"message\":{{\"content\":[{{\"text\":\"Here is the answer.\"}}]}}}}\"#\n        )\n        .unwrap();\n\n        // Temporarily override HOME\n        let _lock = HOME_LOCK.lock().unwrap();\n        let orig_home = std::env::var(\"HOME\").ok();\n        std::env::set_var(\"HOME\", &tmp_dir);\n\n        let msg = read_last_assistant_message(\"/tmp/test-project\", uuid);\n        assert_eq!(msg, Some(\"Here is the answer.\".to_string()));\n\n        // Cleanup\n        if let Some(home) = orig_home {\n            std::env::set_var(\"HOME\", home);\n        }\n        let _ = std::fs::remove_dir_all(&tmp_dir.join(\".claude\"));\n    }\n\n    #[test]\n    fn read_last_assistant_message_multiple_text_parts() {\n        use std::io::Write;\n\n        let tmp_dir = std::env::temp_dir().join(\"hydra_test_logs_parts\");\n        let escaped = escape_project_path(\"/tmp/parts-project\");\n        let projects_dir = tmp_dir.join(\".claude\").join(\"projects\").join(&escaped);\n        std::fs::create_dir_all(&projects_dir).unwrap();\n\n        let uuid = \"11111111-2222-3333-4444-555555555555\";\n        let log_file = projects_dir.join(format!(\"{uuid}.jsonl\"));\n\n        let mut f = std::fs::File::create(&log_file).unwrap();\n        writeln!(\n            f,\n            r#\"{{\"type\":\"assistant\",\"message\":{{\"content\":[{{\"text\":\"Part one.\"}},{{\"text\":\"Part two.\"}}]}}}}\"#\n        )\n        .unwrap();\n\n        let _lock = HOME_LOCK.lock().unwrap();\n        let orig_home = std::env::var(\"HOME\").ok();\n        std::env::set_var(\"HOME\", &tmp_dir);\n\n        let msg = read_last_assistant_message(\"/tmp/parts-project\", uuid);\n        assert_eq!(msg, Some(\"Part one. Part two.\".to_string()));\n\n        if let Some(home) = orig_home {\n            std::env::set_var(\"HOME\", home);\n        }\n        let _ = std::fs::remove_dir_all(&tmp_dir.join(\".claude\"));\n    }\n\n    #[test]\n    fn read_last_assistant_message_no_file() {\n        let msg = read_last_assistant_message(\n            \"/nonexistent/path\",\n            \"aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee\",\n        );\n        assert_eq!(msg, None);\n    }\n\n    #[test]\n    fn read_last_assistant_message_empty_file() {\n        let tmp_dir = std::env::temp_dir().join(\"hydra_test_logs_empty\");\n        let escaped = escape_project_path(\"/tmp/empty-project\");\n        let projects_dir = tmp_dir.join(\".claude\").join(\"projects\").join(&escaped);\n        std::fs::create_dir_all(&projects_dir).unwrap();\n\n        let uuid = \"cccccccc-dddd-eeee-ffff-000000000000\";\n        let log_file = projects_dir.join(format!(\"{uuid}.jsonl\"));\n        let _ = std::fs::File::create(&log_file).unwrap();\n\n        let _lock = HOME_LOCK.lock().unwrap();\n        let orig_home = std::env::var(\"HOME\").ok();\n        std::env::set_var(\"HOME\", &tmp_dir);\n\n        let msg = read_last_assistant_message(\"/tmp/empty-project\", uuid);\n        assert_eq!(msg, None);\n\n        if let Some(home) = orig_home {\n            std::env::set_var(\"HOME\", home);\n        }\n        let _ = std::fs::remove_dir_all(&tmp_dir.join(\".claude\"));\n    }\n\n    #[test]\n    fn read_last_assistant_message_no_assistant_lines() {\n        use std::io::Write;\n\n        let tmp_dir = std::env::temp_dir().join(\"hydra_test_logs_noassist\");\n        let escaped = escape_project_path(\"/tmp/noassist-project\");\n        let projects_dir = tmp_dir.join(\".claude\").join(\"projects\").join(&escaped);\n        std::fs::create_dir_all(&projects_dir).unwrap();\n\n        let uuid = \"dddddddd-eeee-ffff-0000-111111111111\";\n        let log_file = projects_dir.join(format!(\"{uuid}.jsonl\"));\n\n        let mut f = std::fs::File::create(&log_file).unwrap();\n        writeln!(f, r#\"{{\"type\":\"user\",\"message\":{{\"content\":\"hello\"}}}}\"#).unwrap();\n        writeln!(f, r#\"{{\"type\":\"system\",\"message\":{{\"content\":\"info\"}}}}\"#).unwrap();\n\n        let _lock = HOME_LOCK.lock().unwrap();\n        let orig_home = std::env::var(\"HOME\").ok();\n        std::env::set_var(\"HOME\", &tmp_dir);\n\n        let msg = read_last_assistant_message(\"/tmp/noassist-project\", uuid);\n        assert_eq!(msg, None);\n\n        if let Some(home) = orig_home {\n            std::env::set_var(\"HOME\", home);\n        }\n        let _ = std::fs::remove_dir_all(&tmp_dir.join(\".claude\"));\n    }\n\n    #[test]\n    fn read_last_assistant_message_condenses_whitespace() {\n        use std::io::Write;\n\n        let tmp_dir = std::env::temp_dir().join(\"hydra_test_logs_ws\");\n        let escaped = escape_project_path(\"/tmp/ws-project\");\n        let projects_dir = tmp_dir.join(\".claude\").join(\"projects\").join(&escaped);\n        std::fs::create_dir_all(&projects_dir).unwrap();\n\n        let uuid = \"eeeeeeee-ffff-0000-1111-222222222222\";\n        let log_file = projects_dir.join(format!(\"{uuid}.jsonl\"));\n\n        let mut f = std::fs::File::create(&log_file).unwrap();\n        writeln!(\n            f,\n            r#\"{{\"type\":\"assistant\",\"message\":{{\"content\":[{{\"text\":\"  hello   world  \\n  foo  \"}}]}}}}\"#\n        )\n        .unwrap();\n\n        let _lock = HOME_LOCK.lock().unwrap();\n        let orig_home = std::env::var(\"HOME\").ok();\n        std::env::set_var(\"HOME\", &tmp_dir);\n\n        let msg = read_last_assistant_message(\"/tmp/ws-project\", uuid);\n        assert_eq!(msg, Some(\"hello world foo\".to_string()));\n\n        if let Some(home) = orig_home {\n            std::env::set_var(\"HOME\", home);\n        }\n        let _ = std::fs::remove_dir_all(&tmp_dir.join(\".claude\"));\n    }\n\n    #[test]\n    fn read_last_assistant_message_skips_invalid_json() {\n        use std::io::Write;\n\n        let tmp_dir = std::env::temp_dir().join(\"hydra_test_logs_invalid\");\n        let escaped = escape_project_path(\"/tmp/invalid-project\");\n        let projects_dir = tmp_dir.join(\".claude\").join(\"projects\").join(&escaped);\n        std::fs::create_dir_all(&projects_dir).unwrap();\n\n        let uuid = \"ffffffff-0000-1111-2222-333333333333\";\n        let log_file = projects_dir.join(format!(\"{uuid}.jsonl\"));\n\n        let mut f = std::fs::File::create(&log_file).unwrap();\n        writeln!(f, \"this is not json but contains assistant\").unwrap();\n        writeln!(\n            f,\n            r#\"{{\"type\":\"assistant\",\"message\":{{\"content\":[{{\"text\":\"valid line\"}}]}}}}\"#\n        )\n        .unwrap();\n\n        let _lock = HOME_LOCK.lock().unwrap();\n        let orig_home = std::env::var(\"HOME\").ok();\n        std::env::set_var(\"HOME\", &tmp_dir);\n\n        let msg = read_last_assistant_message(\"/tmp/invalid-project\", uuid);\n        assert_eq!(msg, Some(\"valid line\".to_string()));\n\n        if let Some(home) = orig_home {\n            std::env::set_var(\"HOME\", home);\n        }\n        let _ = std::fs::remove_dir_all(&tmp_dir.join(\".claude\"));\n    }\n\n    #[test]\n    fn read_last_assistant_message_empty_content_array() {\n        use std::io::Write;\n\n        let tmp_dir = std::env::temp_dir().join(\"hydra_test_logs_emptycontent\");\n        let escaped = escape_project_path(\"/tmp/emptycontent-project\");\n        let projects_dir = tmp_dir.join(\".claude\").join(\"projects\").join(&escaped);\n        std::fs::create_dir_all(&projects_dir).unwrap();\n\n        let uuid = \"00000000-1111-2222-3333-444444444444\";\n        let log_file = projects_dir.join(format!(\"{uuid}.jsonl\"));\n\n        let mut f = std::fs::File::create(&log_file).unwrap();\n        // Empty content array — no text items\n        writeln!(f, r#\"{{\"type\":\"assistant\",\"message\":{{\"content\":[]}}}}\"#).unwrap();\n\n        let _lock = HOME_LOCK.lock().unwrap();\n        let orig_home = std::env::var(\"HOME\").ok();\n        std::env::set_var(\"HOME\", &tmp_dir);\n\n        let msg = read_last_assistant_message(\"/tmp/emptycontent-project\", uuid);\n        assert_eq!(msg, None);\n\n        if let Some(home) = orig_home {\n            std::env::set_var(\"HOME\", home);\n        }\n        let _ = std::fs::remove_dir_all(&tmp_dir.join(\".claude\"));\n    }\n\n    // ── update_session_stats (HOME wrapper) tests ──────────────────\n\n    #[test]\n    fn update_session_stats_via_home_env() {\n        use std::io::Write;\n\n        let dir = tempfile::tempdir().unwrap();\n        let _guard = HomeGuard::set(dir.path());\n\n        let escaped = escape_project_path(\"/tmp/stats-home-project\");\n        let projects_dir = dir.path().join(\".claude\").join(\"projects\").join(&escaped);\n        std::fs::create_dir_all(&projects_dir).unwrap();\n\n        let uuid = \"aabbccdd-1122-3344-5566-778899aabbcc\";\n        let log_file = projects_dir.join(format!(\"{uuid}.jsonl\"));\n        let mut f = std::fs::File::create(&log_file).unwrap();\n        writeln!(f, r#\"{{\"type\":\"assistant\",\"message\":{{\"usage\":{{\"input_tokens\":500,\"output_tokens\":100,\"cache_read_input_tokens\":0,\"cache_creation_input_tokens\":0}},\"content\":[{{\"type\":\"text\",\"text\":\"done\"}}]}}}}\"#).unwrap();\n        drop(f);\n\n        let mut stats = SessionStats::default();\n        update_session_stats(\"/tmp/stats-home-project\", uuid, &mut stats);\n        assert_eq!(stats.turns, 1);\n        assert_eq!(stats.tokens_in, 500);\n    }\n\n    #[test]\n    fn update_session_stats_missing_home_is_noop() {\n        let _guard = HomeGuard::remove();\n\n        let mut stats = SessionStats::default();\n        update_session_stats(\n            \"/tmp/whatever\",\n            \"some-uuid-value-here-1234567890ab\",\n            &mut stats,\n        );\n        assert_eq!(stats.turns, 0, \"missing HOME should be no-op\");\n    }\n\n    // ── parse_iso_timestamp tests ─────────────────────────────────\n\n    #[test]\n    fn parse_iso_timestamp_valid() {\n        let ts = parse_iso_timestamp(\"2026-01-15T10:00:00.000Z\");\n        assert!(ts.is_some());\n    }\n\n    #[test]\n    fn parse_iso_timestamp_invalid() {\n        assert!(parse_iso_timestamp(\"not a timestamp\").is_none());\n        assert!(parse_iso_timestamp(\"\").is_none());\n        assert!(parse_iso_timestamp(\"2026-13-45T99:99:99Z\").is_none());\n    }\n\n    // ── JSONL timestamp branch coverage ──────────────────────────\n\n    #[test]\n    fn stats_user_message_without_timestamp_field() {\n        // User message that contains \"user\" but no \"timestamp\" key —\n        // should not match the timestamp fast path\n        let path = write_tmp_jsonl(\n            \"stats_user_no_ts\",\n            &[r#\"{\"type\":\"user\",\"message\":{\"role\":\"user\",\"content\":\"hi\"}}\"#],\n        );\n\n        let mut stats = SessionStats::default();\n        update_session_stats_from_path(&path, &mut stats);\n        assert!(stats.last_user_ts.is_none());\n        let _ = std::fs::remove_file(&path);\n    }\n\n    #[test]\n    fn stats_user_message_with_usage_skips_user_fast_path() {\n        // A line with both \"user\" and \"timestamp\" AND \"usage\" should\n        // not match the user timestamp fast path (line 181 condition)\n        let path = write_tmp_jsonl(\n            \"stats_user_usage\",\n            &[\n                r#\"{\"type\":\"user\",\"timestamp\":\"2026-01-15T10:00:00.000Z\",\"usage\":{\"input_tokens\":100},\"message\":{\"content\":\"hi\"}}\"#,\n            ],\n        );\n\n        let mut stats = SessionStats::default();\n        update_session_stats_from_path(&path, &mut stats);\n        // Should not set last_user_ts because \"usage\" is present\n        assert!(stats.last_user_ts.is_none());\n        let _ = std::fs::remove_file(&path);\n    }\n\n    #[test]\n    fn stats_assistant_timestamp_tracked() {\n        let path = write_tmp_jsonl(\n            \"stats_ast_ts\",\n            &[\n                r#\"{\"type\":\"assistant\",\"timestamp\":\"2026-01-15T10:00:30.000Z\",\"message\":{\"usage\":{\"input_tokens\":100,\"output_tokens\":50,\"cache_read_input_tokens\":0,\"cache_creation_input_tokens\":0},\"content\":[{\"type\":\"text\",\"text\":\"ok\"}]}}\"#,\n            ],\n        );\n\n        let mut stats = SessionStats::default();\n        update_session_stats_from_path(&path, &mut stats);\n        assert_eq!(\n            stats.last_assistant_ts.as_deref(),\n            Some(\"2026-01-15T10:00:30.000Z\")\n        );\n        let _ = std::fs::remove_file(&path);\n    }\n\n    #[test]\n    fn stats_assistant_without_timestamp_field() {\n        let path = write_tmp_jsonl(\n            \"stats_ast_no_ts\",\n            &[\n                r#\"{\"type\":\"assistant\",\"message\":{\"usage\":{\"input_tokens\":100,\"output_tokens\":50,\"cache_read_input_tokens\":0,\"cache_creation_input_tokens\":0},\"content\":[{\"type\":\"text\",\"text\":\"ok\"}]}}\"#,\n            ],\n        );\n\n        let mut stats = SessionStats::default();\n        update_session_stats_from_path(&path, &mut stats);\n        assert!(stats.last_assistant_ts.is_none());\n        assert_eq!(stats.turns, 1); // Still counted as a turn\n        let _ = std::fs::remove_file(&path);\n    }\n\n    #[test]\n    fn stats_tool_result_without_filenames() {\n        // toolUseResult without filenames array — should not crash\n        let path = write_tmp_jsonl(\n            \"stats_tool_no_files\",\n            &[r#\"{\"type\":\"user\",\"toolUseResult\":{\"content\":\"some result\"}}\"#],\n        );\n\n        let mut stats = SessionStats::default();\n        update_session_stats_from_path(&path, &mut stats);\n        assert_eq!(stats.file_count(), 0);\n        let _ = std::fs::remove_file(&path);\n    }\n\n    #[test]\n    fn stats_tool_result_with_non_string_filename() {\n        // filenames array with non-string entries — should skip gracefully\n        let path = write_tmp_jsonl(\n            \"stats_tool_bad_fname\",\n            &[r#\"{\"type\":\"user\",\"toolUseResult\":{\"filenames\":[\"/valid.rs\", 123, null]}}\"#],\n        );\n\n        let mut stats = SessionStats::default();\n        update_session_stats_from_path(&path, &mut stats);\n        assert_eq!(stats.file_count(), 1, \"only string filenames counted\");\n        let _ = std::fs::remove_file(&path);\n    }\n\n    #[test]\n    fn stats_malformed_json_line_skipped() {\n        // Valid assistant + malformed line — should not interfere\n        let path = write_tmp_jsonl(\n            \"stats_malformed\",\n            &[\n                r#\"{\"type\":\"assistant\",\"message\":{\"usage\":{\"input_tokens\":100,\"output_tokens\":50,\"cache_read_input_tokens\":0,\"cache_creation_input_tokens\":0},\"content\":[{\"type\":\"text\",\"text\":\"ok\"}]}}\"#,\n                r#\"{\"type\":\"assistant\",\"usage\" this is broken json\"#,\n            ],\n        );\n\n        let mut stats = SessionStats::default();\n        update_session_stats_from_path(&path, &mut stats);\n        assert_eq!(stats.turns, 1, \"only valid lines counted\");\n        let _ = std::fs::remove_file(&path);\n    }\n\n    #[test]\n    fn stats_mixed_message_types_full_coverage() {\n        // A comprehensive test with user timestamps, assistant timestamps,\n        // tool use results, and file tracking\n        let path = write_tmp_jsonl(\n            \"stats_mixed_full\",\n            &[\n                r#\"{\"type\":\"user\",\"timestamp\":\"2026-01-15T10:00:00.000Z\",\"message\":{\"role\":\"user\",\"content\":\"start\"}}\"#,\n                r#\"{\"type\":\"assistant\",\"timestamp\":\"2026-01-15T10:00:15.000Z\",\"message\":{\"usage\":{\"input_tokens\":1000,\"output_tokens\":200,\"cache_read_input_tokens\":50,\"cache_creation_input_tokens\":25},\"content\":[{\"type\":\"text\",\"text\":\"thinking...\"},{\"type\":\"tool_use\",\"name\":\"Edit\",\"id\":\"t1\",\"input\":{}},{\"type\":\"tool_use\",\"name\":\"Bash\",\"id\":\"t2\",\"input\":{}}]}}\"#,\n                r#\"{\"filenames\":[\"/src/main.rs\"],\"toolUseResult\":{\"filenames\":[\"/src/main.rs\"]}}\"#,\n                r#\"{\"type\":\"user\",\"timestamp\":\"2026-01-15T10:01:00.000Z\",\"message\":{\"role\":\"user\",\"content\":\"next task\"}}\"#,\n                r#\"{\"type\":\"assistant\",\"timestamp\":\"2026-01-15T10:01:30.000Z\",\"message\":{\"usage\":{\"input_tokens\":500,\"output_tokens\":100,\"cache_read_input_tokens\":0,\"cache_creation_input_tokens\":0},\"content\":[{\"type\":\"tool_use\",\"name\":\"Write\",\"id\":\"t3\",\"input\":{}}]}}\"#,\n            ],\n        );\n\n        let mut stats = SessionStats::default();\n        update_session_stats_from_path(&path, &mut stats);\n\n        assert_eq!(stats.turns, 2);\n        assert_eq!(stats.tokens_in, 1500);\n        assert_eq!(stats.tokens_out, 300);\n        assert_eq!(stats.tokens_cache_read, 50);\n        assert_eq!(stats.tokens_cache_write, 25);\n        assert_eq!(stats.edits, 2, \"Edit + Write = 2\");\n        assert_eq!(stats.bash_cmds, 1);\n        assert_eq!(stats.file_count(), 1);\n        assert_eq!(\n            stats.last_user_ts.as_deref(),\n            Some(\"2026-01-15T10:01:00.000Z\")\n        );\n        assert_eq!(\n            stats.last_assistant_ts.as_deref(),\n            Some(\"2026-01-15T10:01:30.000Z\")\n        );\n        let _ = std::fs::remove_file(&path);\n    }\n\n    #[test]\n    fn parse_lsof_uuid_too_short_after_tasks() {\n        let output =\n            \"claude  12345  user  txt  REG  1,20  123  /Users/test/.claude/tasks/short/file\";\n        assert_eq!(parse_uuid_from_lsof_output(output), None);\n    }\n\n    #[test]\n    fn parse_cmdline_equals_invalid_uuid() {\n        let cmdline = \"claude --session-id=not-a-valid-uuid\";\n        assert_eq!(parse_session_id_from_cmdline(cmdline), None);\n    }\n\n    // ── GlobalStats tests ───────────────────────────────────────────\n\n    #[test]\n    fn global_stats_cost_calculation() {\n        let stats = GlobalStats {\n            tokens_in: 1_000_000,\n            tokens_out: 100_000,\n            tokens_cache_read: 500_000,\n            tokens_cache_write: 200_000,\n            ..Default::default()\n        };\n        let cost = stats.cost_usd();\n        assert!(\n            (cost - 5.40).abs() < 0.01,\n            \"expected ~$5.40, got ${cost:.2}\"\n        );\n    }\n\n    #[test]\n    fn global_stats_default_is_zero() {\n        let stats = GlobalStats::default();\n        assert_eq!(stats.tokens_in, 0);\n        assert_eq!(stats.tokens_out, 0);\n        assert!((stats.cost_usd() - 0.0).abs() < f64::EPSILON);\n    }\n\n    #[test]\n    fn global_stats_cost_calculation_with_codex_breakdown() {\n        let stats = GlobalStats {\n            codex_tokens_in: 1_000_000,\n            codex_tokens_out: 100_000,\n            codex_tokens_cache_read: 200_000,\n            ..Default::default()\n        };\n        let cost = stats.cost_usd();\n        assert!(\n            (cost - 2.025).abs() < 0.01,\n            \"expected ~$2.03, got ${cost:.2}\"\n        );\n    }\n\n    #[test]\n    fn global_stats_codex_cost_saturates_when_cache_exceeds_input() {\n        let stats = GlobalStats {\n            codex_tokens_in: 100,\n            codex_tokens_out: 0,\n            codex_tokens_cache_read: 200,\n            ..Default::default()\n        };\n        let cost = stats.cost_usd();\n        // Uncached input should saturate at 0, so only cached pricing applies.\n        let expected = 200.0 * CODEX_CACHE_READ_USD_PER_MTOK / 1_000_000.0;\n        assert!((cost - expected).abs() < f64::EPSILON);\n    }\n\n    #[test]\n    fn update_global_stats_scans_jsonl_files() {\n        use std::io::Write;\n\n        let tmp = tempfile::tempdir().unwrap();\n        let projects = tmp.path().join(\"proj-a\");\n        std::fs::create_dir_all(&projects).unwrap();\n\n        let today = chrono::Local::now().format(\"%Y-%m-%d\").to_string();\n\n        let log = projects.join(\"session1.jsonl\");\n        let mut f = std::fs::File::create(&log).unwrap();\n        writeln!(f,\n            r#\"{{\"type\":\"assistant\",\"timestamp\":\"{today}T10:00:00.000Z\",\"message\":{{\"usage\":{{\"input_tokens\":1000,\"output_tokens\":200,\"cache_read_input_tokens\":50,\"cache_creation_input_tokens\":10}},\"content\":[{{\"type\":\"text\",\"text\":\"hello\"}}]}}}}\"#,\n            today = today\n        ).unwrap();\n        writeln!(f,\n            r#\"{{\"type\":\"assistant\",\"timestamp\":\"{today}T10:01:00.000Z\",\"message\":{{\"usage\":{{\"input_tokens\":2000,\"output_tokens\":300,\"cache_read_input_tokens\":0,\"cache_creation_input_tokens\":0}},\"content\":[{{\"type\":\"text\",\"text\":\"world\"}}]}}}}\"#,\n            today = today\n        ).unwrap();\n        drop(f);\n\n        let mut stats = GlobalStats::default();\n        stats.date = today.clone();\n        update_global_stats_inner(&mut stats, &today, Some(tmp.path()));\n\n        assert_eq!(stats.tokens_in, 3000);\n        assert_eq!(stats.tokens_out, 500);\n        assert_eq!(stats.tokens_cache_read, 50);\n        assert_eq!(stats.tokens_cache_write, 10);\n    }\n\n    #[test]\n    fn update_global_stats_incremental_reads() {\n        use std::io::Write;\n\n        let tmp = tempfile::tempdir().unwrap();\n        let projects = tmp.path().join(\"proj-b\");\n        std::fs::create_dir_all(&projects).unwrap();\n\n        let today = chrono::Local::now().format(\"%Y-%m-%d\").to_string();\n\n        let log = projects.join(\"session2.jsonl\");\n        let mut f = std::fs::File::create(&log).unwrap();\n        writeln!(f,\n            r#\"{{\"type\":\"assistant\",\"timestamp\":\"{today}T10:00:00.000Z\",\"message\":{{\"usage\":{{\"input_tokens\":100,\"output_tokens\":50,\"cache_read_input_tokens\":0,\"cache_creation_input_tokens\":0}},\"content\":[{{\"type\":\"text\",\"text\":\"first\"}}]}}}}\"#,\n            today = today\n        ).unwrap();\n        drop(f);\n\n        let mut stats = GlobalStats::default();\n        stats.date = today.clone();\n        update_global_stats_inner(&mut stats, &today, Some(tmp.path()));\n        assert_eq!(stats.tokens_in, 100);\n\n        // Append more data\n        let mut f = std::fs::OpenOptions::new().append(true).open(&log).unwrap();\n        writeln!(f,\n            r#\"{{\"type\":\"assistant\",\"timestamp\":\"{today}T10:01:00.000Z\",\"message\":{{\"usage\":{{\"input_tokens\":200,\"output_tokens\":100,\"cache_read_input_tokens\":0,\"cache_creation_input_tokens\":0}},\"content\":[{{\"type\":\"text\",\"text\":\"second\"}}]}}}}\"#,\n            today = today\n        ).unwrap();\n        drop(f);\n\n        update_global_stats_inner(&mut stats, &today, Some(tmp.path()));\n        assert_eq!(stats.tokens_in, 300, \"should accumulate incrementally\");\n        assert_eq!(stats.tokens_out, 150);\n    }\n\n    #[test]\n    fn update_global_stats_skips_other_dates() {\n        use std::io::Write;\n\n        let tmp = tempfile::tempdir().unwrap();\n        let projects = tmp.path().join(\"proj-c\");\n        std::fs::create_dir_all(&projects).unwrap();\n\n        let today = chrono::Local::now().format(\"%Y-%m-%d\").to_string();\n\n        let log = projects.join(\"session3.jsonl\");\n        let mut f = std::fs::File::create(&log).unwrap();\n        // Write an entry from a different date — should be skipped\n        writeln!(f,\n            r#\"{{\"type\":\"assistant\",\"timestamp\":\"2020-01-01T10:00:00.000Z\",\"message\":{{\"usage\":{{\"input_tokens\":5000,\"output_tokens\":1000,\"cache_read_input_tokens\":0,\"cache_creation_input_tokens\":0}},\"content\":[{{\"type\":\"text\",\"text\":\"old\"}}]}}}}\"#\n        ).unwrap();\n        // Write an entry from today — should be counted\n        writeln!(f,\n            r#\"{{\"type\":\"assistant\",\"timestamp\":\"{today}T10:00:00.000Z\",\"message\":{{\"usage\":{{\"input_tokens\":100,\"output_tokens\":50,\"cache_read_input_tokens\":0,\"cache_creation_input_tokens\":0}},\"content\":[{{\"type\":\"text\",\"text\":\"new\"}}]}}}}\"#,\n            today = today\n        ).unwrap();\n        drop(f);\n\n        let mut stats = GlobalStats::default();\n        stats.date = today.clone();\n        update_global_stats_inner(&mut stats, &today, Some(tmp.path()));\n\n        assert_eq!(stats.tokens_in, 100, \"should only count today's entries\");\n        assert_eq!(stats.tokens_out, 50);\n    }\n\n    #[test]\n    fn update_global_stats_resets_on_date_change() {\n        let mut stats = GlobalStats::default();\n        stats.tokens_in = 5000;\n        stats.tokens_out = 1000;\n        stats.date = \"2020-01-01\".to_string();\n        stats.file_offsets.insert(PathBuf::from(\"/fake\"), 999);\n\n        let today = chrono::Local::now().format(\"%Y-%m-%d\").to_string();\n\n        // Use a nonexistent base_dir so no real files are scanned.\n        // The date mismatch logic is in update_global_stats (public),\n        // so we replicate the reset check + call inner with empty dir.\n        if stats.date != today {\n            stats.tokens_in = 0;\n            stats.tokens_out = 0;\n            stats.tokens_cache_read = 0;\n            stats.tokens_cache_write = 0;\n            stats.file_offsets.clear();\n            stats.date = today.clone();\n        }\n        update_global_stats_inner(\n            &mut stats,\n            &today,\n            Some(std::path::Path::new(\"/nonexistent/path\")),\n        );\n\n        assert_eq!(stats.date, today);\n        assert_eq!(stats.tokens_in, 0, \"should reset on date change\");\n        assert_eq!(stats.tokens_out, 0);\n        assert!(stats.file_offsets.is_empty());\n    }\n\n    #[test]\n    fn update_global_stats_no_projects_dir() {\n        let mut stats = GlobalStats::default();\n        let today = chrono::Local::now().format(\"%Y-%m-%d\").to_string();\n        stats.date = today.clone();\n        // Point at nonexistent dir — should not panic\n        update_global_stats_inner(\n            &mut stats,\n            &today,\n            Some(std::path::Path::new(\"/nonexistent/path\")),\n        );\n        assert_eq!(stats.tokens_in, 0);\n    }\n\n    #[test]\n    fn update_global_stats_includes_nested_subagent_files() {\n        use std::io::Write;\n\n        let tmp = tempfile::tempdir().unwrap();\n        let today = chrono::Local::now().format(\"%Y-%m-%d\").to_string();\n\n        // Direct JSONL under project dir\n        let project = tmp.path().join(\"proj-x\");\n        std::fs::create_dir_all(&project).unwrap();\n        let mut f = std::fs::File::create(project.join(\"main.jsonl\")).unwrap();\n        writeln!(f,\n            r#\"{{\"type\":\"assistant\",\"timestamp\":\"{today}T10:00:00.000Z\",\"message\":{{\"usage\":{{\"input_tokens\":100,\"output_tokens\":50,\"cache_read_input_tokens\":0,\"cache_creation_input_tokens\":0}},\"content\":[{{\"type\":\"text\",\"text\":\"main\"}}]}}}}\"#,\n            today = today\n        ).unwrap();\n        drop(f);\n\n        // Nested subagent JSONL (simulating <project>/<uuid>/subagents/<agent>.jsonl)\n        let subagents = project.join(\"some-uuid\").join(\"subagents\");\n        std::fs::create_dir_all(&subagents).unwrap();\n        let mut f = std::fs::File::create(subagents.join(\"agent-1.jsonl\")).unwrap();\n        writeln!(f,\n            r#\"{{\"type\":\"assistant\",\"timestamp\":\"{today}T10:01:00.000Z\",\"message\":{{\"usage\":{{\"input_tokens\":200,\"output_tokens\":80,\"cache_read_input_tokens\":0,\"cache_creation_input_tokens\":0}},\"content\":[{{\"type\":\"text\",\"text\":\"subagent\"}}]}}}}\"#,\n            today = today\n        ).unwrap();\n        drop(f);\n\n        let mut stats = GlobalStats::default();\n        stats.date = today.clone();\n        update_global_stats_inner(&mut stats, &today, Some(tmp.path()));\n\n        assert_eq!(\n            stats.tokens_in, 300,\n            \"should include both direct and subagent entries\"\n        );\n        assert_eq!(stats.tokens_out, 130);\n    }\n\n    #[test]\n    fn update_global_stats_parses_codex_token_count_incrementally() {\n        use std::io::Write;\n\n        let tmp = tempfile::tempdir().unwrap();\n        let today = chrono::Local::now().format(\"%Y-%m-%d\").to_string();\n\n        let codex_dir = tmp\n            .path()\n            .join(\".codex\")\n            .join(\"sessions\")\n            .join(\"2026\")\n            .join(\"02\")\n            .join(\"20\");\n        std::fs::create_dir_all(&codex_dir).unwrap();\n        let log = codex_dir.join(\"rollout.jsonl\");\n\n        let mut f = std::fs::File::create(&log).unwrap();\n        // Baseline from an older date.\n        writeln!(\n            f,\n            r#\"{{\"timestamp\":\"2020-01-01T23:59:59Z\",\"type\":\"event_msg\",\"payload\":{{\"type\":\"token_count\",\"info\":{{\"total_token_usage\":{{\"input_tokens\":90,\"cached_input_tokens\":0,\"output_tokens\":10,\"total_tokens\":100}}}}}}}}\"#\n        )\n        .unwrap();\n        // First token_count for today.\n        writeln!(\n            f,\n            r#\"{{\"timestamp\":\"{today}T10:00:00Z\",\"type\":\"event_msg\",\"payload\":{{\"type\":\"token_count\",\"info\":{{\"total_token_usage\":{{\"input_tokens\":150,\"cached_input_tokens\":20,\"output_tokens\":10,\"total_tokens\":160}}}}}}}}\"#\n        )\n        .unwrap();\n        // Duplicate snapshot (should be ignored by delta logic).\n        writeln!(\n            f,\n            r#\"{{\"timestamp\":\"{today}T10:00:01Z\",\"type\":\"event_msg\",\"payload\":{{\"type\":\"token_count\",\"info\":{{\"total_token_usage\":{{\"input_tokens\":150,\"cached_input_tokens\":20,\"output_tokens\":10,\"total_tokens\":160}}}}}}}}\"#\n        )\n        .unwrap();\n        // Second token_count for today.\n        writeln!(\n            f,\n            r#\"{{\"timestamp\":\"{today}T10:01:00Z\",\"type\":\"event_msg\",\"payload\":{{\"type\":\"token_count\",\"info\":{{\"total_token_usage\":{{\"input_tokens\":230,\"cached_input_tokens\":40,\"output_tokens\":30,\"total_tokens\":260}}}}}}}}\"#\n        )\n        .unwrap();\n        drop(f);\n\n        let mut stats = GlobalStats::default();\n        stats.date = today.clone();\n        update_global_stats_inner(&mut stats, &today, Some(tmp.path()));\n\n        assert_eq!(stats.codex_tokens_in, 140);\n        assert_eq!(stats.codex_tokens_out, 20);\n        assert_eq!(stats.codex_tokens_cache_read, 40);\n        assert_eq!(\n            stats.tokens_in, 140,\n            \"aggregate totals should include codex\"\n        );\n        assert_eq!(\n            stats.tokens_out, 20,\n            \"aggregate totals should include codex\"\n        );\n        assert_eq!(\n            stats.tokens_cache_read, 40,\n            \"aggregate totals should include codex\"\n        );\n\n        // Append one more today snapshot and verify incremental accumulation.\n        let mut f = std::fs::OpenOptions::new().append(true).open(&log).unwrap();\n        writeln!(\n            f,\n            r#\"{{\"timestamp\":\"{today}T10:02:00Z\",\"type\":\"event_msg\",\"payload\":{{\"type\":\"token_count\",\"info\":{{\"total_token_usage\":{{\"input_tokens\":260,\"cached_input_tokens\":50,\"output_tokens\":40,\"total_tokens\":300}}}}}}}}\"#\n        )\n        .unwrap();\n        drop(f);\n\n        update_global_stats_inner(&mut stats, &today, Some(tmp.path()));\n        assert_eq!(stats.codex_tokens_in, 170);\n        assert_eq!(stats.codex_tokens_out, 30);\n        assert_eq!(stats.codex_tokens_cache_read, 50);\n    }\n\n    // ── update_session_stats_from_path: assistant tool_use counting ──\n\n    #[test]\n    fn stats_assistant_tool_use_edit_and_bash() {\n        let dir = tempfile::tempdir().unwrap();\n        let path = dir.path().join(\"test.jsonl\");\n        let content = concat!(\n            r#\"{\"type\":\"assistant\",\"timestamp\":\"2025-01-01T00:00:00Z\",\"message\":{\"usage\":{\"input_tokens\":100,\"output_tokens\":50},\"content\":[{\"type\":\"tool_use\",\"name\":\"Edit\"},{\"type\":\"tool_use\",\"name\":\"Bash\"},{\"type\":\"tool_use\",\"name\":\"Write\"},{\"type\":\"tool_use\",\"name\":\"Read\"}]}}\"#,\n            \"\\n\",\n        );\n        std::fs::write(&path, content).unwrap();\n        let mut stats = SessionStats::default();\n        update_session_stats_from_path(&path, &mut stats);\n        assert_eq!(stats.edits, 2, \"Edit + Write = 2 edits\");\n        assert_eq!(stats.bash_cmds, 1, \"1 Bash command\");\n        assert_eq!(stats.turns, 1);\n        assert_eq!(stats.tokens_in, 100);\n        assert_eq!(stats.tokens_out, 50);\n    }\n\n    #[test]\n    fn stats_assistant_cache_tokens() {\n        let dir = tempfile::tempdir().unwrap();\n        let path = dir.path().join(\"test.jsonl\");\n        let content = r#\"{\"type\":\"assistant\",\"timestamp\":\"2025-01-01T00:00:00Z\",\"message\":{\"usage\":{\"input_tokens\":100,\"output_tokens\":50,\"cache_read_input_tokens\":200,\"cache_creation_input_tokens\":300},\"content\":[]}}\"#;\n        std::fs::write(&path, format!(\"{content}\\n\")).unwrap();\n        let mut stats = SessionStats::default();\n        update_session_stats_from_path(&path, &mut stats);\n        assert_eq!(stats.tokens_cache_read, 200);\n        assert_eq!(stats.tokens_cache_write, 300);\n    }\n\n    // ── update_session_stats_from_path: incremental reading ──\n\n    #[test]\n    fn stats_incremental_reads_only_new_bytes() {\n        let dir = tempfile::tempdir().unwrap();\n        let path = dir.path().join(\"test.jsonl\");\n\n        // Write first batch\n        let line1 = r#\"{\"type\":\"assistant\",\"timestamp\":\"2025-01-01T00:00:00Z\",\"message\":{\"usage\":{\"input_tokens\":100,\"output_tokens\":50},\"content\":[]}}\"#;\n        std::fs::write(&path, format!(\"{line1}\\n\")).unwrap();\n\n        let mut stats = SessionStats::default();\n        update_session_stats_from_path(&path, &mut stats);\n        assert_eq!(stats.tokens_in, 100);\n        assert_eq!(stats.turns, 1);\n        let offset_after_first = stats.read_offset;\n        assert!(offset_after_first > 0);\n\n        // Append second batch\n        let line2 = r#\"{\"type\":\"assistant\",\"timestamp\":\"2025-01-01T00:01:00Z\",\"message\":{\"usage\":{\"input_tokens\":200,\"output_tokens\":100},\"content\":[]}}\"#;\n        let mut file = std::fs::OpenOptions::new()\n            .append(true)\n            .open(&path)\n            .unwrap();\n        use std::io::Write;\n        writeln!(file, \"{line2}\").unwrap();\n\n        // Second read should only parse the new bytes\n        update_session_stats_from_path(&path, &mut stats);\n        assert_eq!(stats.tokens_in, 300, \"should accumulate: 100 + 200\");\n        assert_eq!(stats.turns, 2);\n        assert!(stats.read_offset > offset_after_first);\n    }\n\n    #[test]\n    fn stats_incremental_no_reread_when_unchanged() {\n        let dir = tempfile::tempdir().unwrap();\n        let path = dir.path().join(\"test.jsonl\");\n        let line = r#\"{\"type\":\"assistant\",\"timestamp\":\"2025-01-01T00:00:00Z\",\"message\":{\"usage\":{\"input_tokens\":100,\"output_tokens\":50},\"content\":[]}}\"#;\n        std::fs::write(&path, format!(\"{line}\\n\")).unwrap();\n\n        let mut stats = SessionStats::default();\n        update_session_stats_from_path(&path, &mut stats);\n        assert_eq!(stats.turns, 1);\n\n        // Second call with same file — should be a noop\n        update_session_stats_from_path(&path, &mut stats);\n        assert_eq!(stats.turns, 1, \"should not re-parse unchanged file\");\n    }\n\n    #[test]\n    fn stats_seek_error_returns_early() {\n        // A non-existent path should simply return without error\n        let path = std::path::Path::new(\"/nonexistent/file.jsonl\");\n        let mut stats = SessionStats::default();\n        update_session_stats_from_path(path, &mut stats);\n        assert_eq!(stats.turns, 0);\n    }\n\n    // ── update_session_stats_from_path: tool results with filenames ──\n\n    #[test]\n    fn stats_tool_result_filenames_tracked() {\n        let dir = tempfile::tempdir().unwrap();\n        let path = dir.path().join(\"test.jsonl\");\n        let content = concat!(\n            r#\"{\"toolUseResult\":{\"filenames\":[\"src/main.rs\",\"src/lib.rs\"]}}\"#,\n            \"\\n\",\n            r#\"{\"toolUseResult\":{\"filenames\":[\"src/main.rs\",\"src/app.rs\"]}}\"#,\n            \"\\n\",\n        );\n        std::fs::write(&path, content).unwrap();\n        let mut stats = SessionStats::default();\n        update_session_stats_from_path(&path, &mut stats);\n        assert_eq!(stats.files.len(), 3, \"3 unique files\");\n        assert!(stats.recent_files.contains(&\"src/main.rs\".to_string()));\n        assert!(stats.recent_files.contains(&\"src/lib.rs\".to_string()));\n        assert!(stats.recent_files.contains(&\"src/app.rs\".to_string()));\n    }\n\n    // ── update_global_stats_inner with real temp files ──\n\n    #[test]\n    fn global_stats_inner_reads_jsonl_files() {\n        let dir = tempfile::tempdir().unwrap();\n        let today = chrono::Local::now().format(\"%Y-%m-%d\").to_string();\n\n        // Create structure: dir/subproject/session.jsonl\n        let subdir = dir.path().join(\"my-project\");\n        std::fs::create_dir_all(&subdir).unwrap();\n        let jsonl_path = subdir.join(\"session.jsonl\");\n        let line = format!(\n            r#\"{{\"type\":\"assistant\",\"timestamp\":\"{today}T12:00:00Z\",\"message\":{{\"usage\":{{\"input_tokens\":500,\"output_tokens\":250,\"cache_read_input_tokens\":100,\"cache_creation_input_tokens\":50}},\"content\":[]}}}}\"#,\n        );\n        std::fs::write(&jsonl_path, format!(\"{line}\\n\")).unwrap();\n\n        let mut stats = GlobalStats::default();\n        stats.date = today.clone();\n        update_global_stats_inner(&mut stats, &today, Some(dir.path()));\n\n        assert_eq!(stats.tokens_in, 500);\n        assert_eq!(stats.tokens_out, 250);\n        assert_eq!(stats.tokens_cache_read, 100);\n        assert_eq!(stats.tokens_cache_write, 50);\n    }\n\n    #[test]\n    fn global_stats_inner_incremental() {\n        let dir = tempfile::tempdir().unwrap();\n        let today = chrono::Local::now().format(\"%Y-%m-%d\").to_string();\n\n        let subdir = dir.path().join(\"proj\");\n        std::fs::create_dir_all(&subdir).unwrap();\n        let jsonl_path = subdir.join(\"s.jsonl\");\n        let line = format!(\n            r#\"{{\"type\":\"assistant\",\"timestamp\":\"{today}T12:00:00Z\",\"message\":{{\"usage\":{{\"input_tokens\":100,\"output_tokens\":50}},\"content\":[]}}}}\"#,\n        );\n        std::fs::write(&jsonl_path, format!(\"{line}\\n\")).unwrap();\n\n        let mut stats = GlobalStats::default();\n        stats.date = today.clone();\n        update_global_stats_inner(&mut stats, &today, Some(dir.path()));\n        assert_eq!(stats.tokens_in, 100);\n\n        // Append more data\n        let line2 = format!(\n            r#\"{{\"type\":\"assistant\",\"timestamp\":\"{today}T13:00:00Z\",\"message\":{{\"usage\":{{\"input_tokens\":200,\"output_tokens\":100}},\"content\":[]}}}}\"#,\n        );\n        let mut file = std::fs::OpenOptions::new()\n            .append(true)\n            .open(&jsonl_path)\n            .unwrap();\n        use std::io::Write;\n        writeln!(file, \"{line2}\").unwrap();\n\n        update_global_stats_inner(&mut stats, &today, Some(dir.path()));\n        assert_eq!(stats.tokens_in, 300, \"should accumulate incrementally\");\n    }\n\n    #[test]\n    fn global_stats_inner_skips_non_jsonl_files() {\n        let dir = tempfile::tempdir().unwrap();\n        let today = chrono::Local::now().format(\"%Y-%m-%d\").to_string();\n\n        let subdir = dir.path().join(\"proj\");\n        std::fs::create_dir_all(&subdir).unwrap();\n        // Write a .txt file (should be ignored)\n        std::fs::write(subdir.join(\"notes.txt\"), \"not a jsonl\").unwrap();\n\n        let mut stats = GlobalStats::default();\n        stats.date = today.clone();\n        update_global_stats_inner(&mut stats, &today, Some(dir.path()));\n        assert_eq!(stats.tokens_in, 0, \"should skip non-jsonl files\");\n    }\n\n    #[test]\n    fn global_stats_inner_skips_lines_without_today() {\n        let dir = tempfile::tempdir().unwrap();\n        let today = chrono::Local::now().format(\"%Y-%m-%d\").to_string();\n\n        let subdir = dir.path().join(\"proj\");\n        std::fs::create_dir_all(&subdir).unwrap();\n        let line = r#\"{\"type\":\"assistant\",\"timestamp\":\"1999-01-01T12:00:00Z\",\"message\":{\"usage\":{\"input_tokens\":100,\"output_tokens\":50},\"content\":[]}}\"#;\n        std::fs::write(subdir.join(\"old.jsonl\"), format!(\"{line}\\n\")).unwrap();\n\n        let mut stats = GlobalStats::default();\n        stats.date = today.clone();\n        update_global_stats_inner(&mut stats, &today, Some(dir.path()));\n        assert_eq!(stats.tokens_in, 0, \"should skip lines from other dates\");\n    }\n\n    #[test]\n    fn collect_jsonl_files_respects_depth_limit() {\n        let dir = tempfile::tempdir().unwrap();\n        // Create a directory tree 6 levels deep (limit is 4)\n        let mut deep = dir.path().to_path_buf();\n        for i in 0..6 {\n            deep = deep.join(format!(\"level{i}\"));\n        }\n        std::fs::create_dir_all(&deep).unwrap();\n        // Place a jsonl file at depth 6 — should be ignored\n        std::fs::write(deep.join(\"deep.jsonl\"), \"ignored\\n\").unwrap();\n        // Also place one at depth 2 — should be found\n        let shallow = dir.path().join(\"level0\").join(\"level1\");\n        std::fs::write(shallow.join(\"shallow.jsonl\"), \"found\\n\").unwrap();\n\n        let mut files = Vec::new();\n        collect_jsonl_files(dir.path(), &mut files, 0);\n        assert_eq!(files.len(), 1, \"only shallow file should be collected\");\n        assert!(files[0].ends_with(\"shallow.jsonl\"));\n    }\n\n    #[test]\n    fn global_stats_inner_none_base_dir_without_home_is_noop() {\n        let _guard = HomeGuard::remove();\n\n        let mut stats = GlobalStats::default();\n        let today = \"2026-01-01\";\n        update_global_stats_inner(&mut stats, today, None);\n        assert_eq!(stats.tokens_in, 0, \"should be noop when HOME is unset\");\n    }\n\n    #[test]\n    fn update_session_stats_user_message_without_type_field_skipped() {\n        // A line that matches the user fast-path heuristic but has wrong JSON structure\n        let dir = tempfile::tempdir().unwrap();\n        let path = dir.path().join(\"test.jsonl\");\n        // Has \"user\" and \"timestamp\" but type is not \"user\"\n        let line = r#\"{\"type\":\"system\",\"role\":\"user\",\"timestamp\":\"2026-01-15T10:00:00.000Z\"}\"#;\n        std::fs::write(&path, format!(\"{line}\\n\")).unwrap();\n\n        let mut stats = SessionStats::default();\n        update_session_stats_from_path(&path, &mut stats);\n        assert!(\n            stats.last_user_ts.is_none(),\n            \"should not set last_user_ts for non-user type\"\n        );\n    }\n\n    #[test]\n    fn update_session_stats_assistant_message_without_usage_key_skipped() {\n        // A line that matches assistant fast-path heuristic but has no usage\n        let dir = tempfile::tempdir().unwrap();\n        let path = dir.path().join(\"test.jsonl\");\n        // Contains \"assistant\" and \"usage\" in text, but type is \"result\"\n        let line = r#\"{\"type\":\"result\",\"message\":\"assistant usage info\"}\"#;\n        std::fs::write(&path, format!(\"{line}\\n\")).unwrap();\n\n        let mut stats = SessionStats::default();\n        update_session_stats_from_path(&path, &mut stats);\n        assert_eq!(stats.turns, 0);\n    }\n\n    #[test]\n    fn parse_uuid_from_lsof_output_valid() {\n        let output = \"node  12345 user  txt  REG  /home/user/.claude/tasks/a1b2c3d4-e5f6-7890-abcd-ef1234567890/file.jsonl\\n\";\n        let result = parse_uuid_from_lsof_output(output);\n        assert_eq!(\n            result.as_deref(),\n            Some(\"a1b2c3d4-e5f6-7890-abcd-ef1234567890\")\n        );\n    }\n\n    #[test]\n    fn parse_uuid_from_lsof_output_no_match() {\n        let output = \"node  12345 user  txt  REG  /home/user/.config/something\\n\";\n        let result = parse_uuid_from_lsof_output(output);\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn parse_uuid_from_lsof_output_short_rest() {\n        // The path after .claude/tasks/ is shorter than 36 chars\n        let output = \"node  12345 user  txt  REG  /home/.claude/tasks/short/file\\n\";\n        let result = parse_uuid_from_lsof_output(output);\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn parse_uuid_from_lsof_output_invalid_uuid() {\n        // 36 chars but not a valid UUID format\n        let output = \"node  12345 user  txt  REG  /home/.claude/tasks/not-a-valid-uuid-at-all-really-nope/file\\n\";\n        let result = parse_uuid_from_lsof_output(output);\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn update_global_stats_outer_covers_today_and_delegates() {\n        let dir = tempfile::tempdir().unwrap();\n        let _guard = HomeGuard::set(dir.path());\n\n        // Create a projects dir with a jsonl file for today\n        let today = chrono::Local::now().format(\"%Y-%m-%d\").to_string();\n        let projects_dir = dir.path().join(\".claude\").join(\"projects\").join(\"proj\");\n        std::fs::create_dir_all(&projects_dir).unwrap();\n        let line = format!(\n            r#\"{{\"type\":\"assistant\",\"timestamp\":\"{today}T12:00:00Z\",\"message\":{{\"usage\":{{\"input_tokens\":100,\"output_tokens\":50}},\"content\":[]}}}}\"#,\n        );\n        std::fs::write(projects_dir.join(\"s.jsonl\"), format!(\"{line}\\n\")).unwrap();\n\n        let mut stats = GlobalStats::default();\n        update_global_stats(&mut stats);\n\n        assert_eq!(\n            stats.tokens_in, 100,\n            \"should read tokens from HOME-based path\"\n        );\n        assert_eq!(stats.date, today, \"should set today's date\");\n    }\n\n    #[test]\n    fn update_global_stats_outer_resets_on_date_change() {\n        let dir = tempfile::tempdir().unwrap();\n        let _guard = HomeGuard::set(dir.path());\n\n        let mut stats = GlobalStats::default();\n        stats.date = \"1999-01-01\".to_string(); // old date\n        stats.tokens_in = 500;\n        stats.tokens_out = 200;\n        stats.tokens_cache_read = 100;\n        stats.tokens_cache_write = 50;\n\n        update_global_stats(&mut stats);\n\n        let today = chrono::Local::now().format(\"%Y-%m-%d\").to_string();\n        assert_eq!(stats.date, today, \"date should be updated to today\");\n        assert_eq!(\n            stats.tokens_in, 0,\n            \"tokens_in should be reset on date change\"\n        );\n        assert_eq!(\n            stats.tokens_out, 0,\n            \"tokens_out should be reset on date change\"\n        );\n    }\n\n    #[test]\n    fn global_stats_inner_false_positive_assistant_line_skipped() {\n        // Line passes ALL quick filters (contains today's date, \"assistant\" as\n        // a JSON key, and \"usage\") but the top-level type is NOT \"assistant\",\n        // so it must be rejected at the JSON type check (line 383-384).\n        let dir = tempfile::tempdir().unwrap();\n        let today = chrono::Local::now().format(\"%Y-%m-%d\").to_string();\n\n        let subdir = dir.path().join(\"proj\");\n        std::fs::create_dir_all(&subdir).unwrap();\n        // \"assistant\" appears as a key name (passes contains check),\n        // \"usage\" appears as a key, and today's date is in the timestamp.\n        let line = format!(\n            r#\"{{\"type\":\"system\",\"assistant\":\"yes\",\"usage\":\"yes\",\"timestamp\":\"{today}\",\"message\":{{\"usage\":{{\"input_tokens\":999}}}}}}\"#,\n        );\n        std::fs::write(subdir.join(\"s.jsonl\"), format!(\"{line}\\n\")).unwrap();\n\n        let mut stats = GlobalStats::default();\n        stats.date = today.clone();\n        update_global_stats_inner(&mut stats, &today, Some(dir.path()));\n        assert_eq!(\n            stats.tokens_in, 0,\n            \"should skip lines where type != assistant\"\n        );\n    }\n\n    // ── read_last_assistant_message via temp files ──\n\n    #[test]\n    fn read_last_assistant_message_returns_text() {\n        let dir = tempfile::tempdir().unwrap();\n        let _guard = HomeGuard::set(dir.path());\n\n        let cwd = \"/test/project\";\n        let uuid = \"aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee\";\n        let escaped = escape_project_path(cwd);\n        let jsonl_dir = dir.path().join(\".claude\").join(\"projects\").join(&escaped);\n        std::fs::create_dir_all(&jsonl_dir).unwrap();\n\n        let jsonl_path = jsonl_dir.join(format!(\"{uuid}.jsonl\"));\n        let content = concat!(\n            r#\"{\"type\":\"user\",\"message\":{\"content\":[{\"text\":\"hello\"}]}}\"#,\n            \"\\n\",\n            r#\"{\"type\":\"assistant\",\"message\":{\"content\":[{\"text\":\"Hi there!\"},{\"text\":\"How can I help?\"}]}}\"#,\n            \"\\n\",\n            r#\"{\"type\":\"user\",\"message\":{\"content\":[{\"text\":\"bye\"}]}}\"#,\n            \"\\n\",\n            r#\"{\"type\":\"assistant\",\"message\":{\"content\":[{\"text\":\"Goodbye!\"}]}}\"#,\n            \"\\n\",\n        );\n        std::fs::write(&jsonl_path, content).unwrap();\n\n        let result = read_last_assistant_message(cwd, uuid);\n        assert_eq!(result, Some(\"Goodbye!\".to_string()));\n    }\n\n    #[test]\n    fn read_last_assistant_message_missing_file_returns_none() {\n        let dir = tempfile::tempdir().unwrap();\n        let _guard = HomeGuard::set(dir.path());\n\n        let result =\n            read_last_assistant_message(\"/nonexistent\", \"aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee\");\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn read_last_assistant_message_multi_part_content() {\n        let dir = tempfile::tempdir().unwrap();\n        let _guard = HomeGuard::set(dir.path());\n\n        let cwd = \"/test/multi\";\n        let uuid = \"11111111-2222-3333-4444-555555555555\";\n        let escaped = escape_project_path(cwd);\n        let jsonl_dir = dir.path().join(\".claude\").join(\"projects\").join(&escaped);\n        std::fs::create_dir_all(&jsonl_dir).unwrap();\n\n        let jsonl_path = jsonl_dir.join(format!(\"{uuid}.jsonl\"));\n        let content = r#\"{\"type\":\"assistant\",\"message\":{\"content\":[{\"text\":\"Part one.\"},{\"text\":\"Part two.\"}]}}\"#;\n        std::fs::write(&jsonl_path, format!(\"{content}\\n\")).unwrap();\n\n        let result = read_last_assistant_message(cwd, uuid);\n        assert_eq!(result, Some(\"Part one. Part two.\".to_string()));\n    }\n\n    // ── parse_session_id_from_cmdline ──\n\n    #[test]\n    fn parse_session_id_space_form() {\n        let cmdline = \"node claude --session-id aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee --other\";\n        let result = parse_session_id_from_cmdline(cmdline);\n        assert_eq!(\n            result,\n            Some(\"aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee\".to_string())\n        );\n    }\n\n    #[test]\n    fn parse_session_id_equals_form() {\n        let cmdline = \"node claude --session-id=aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee --other\";\n        let result = parse_session_id_from_cmdline(cmdline);\n        assert_eq!(\n            result,\n            Some(\"aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee\".to_string())\n        );\n    }\n\n    #[test]\n    fn parse_session_id_not_present() {\n        let cmdline = \"node claude --no-session-id\";\n        let result = parse_session_id_from_cmdline(cmdline);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn parse_session_id_invalid_uuid_value() {\n        let cmdline = \"node claude --session-id not-a-uuid\";\n        let result = parse_session_id_from_cmdline(cmdline);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn parse_session_id_missing_value() {\n        let cmdline = \"node claude --session-id\";\n        let result = parse_session_id_from_cmdline(cmdline);\n        assert_eq!(result, None);\n    }\n\n    // ── is_uuid ──\n\n    #[test]\n    fn is_uuid_correct_format() {\n        assert!(is_uuid(\"aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee\"));\n        assert!(is_uuid(\"12345678-1234-1234-1234-123456789abc\"));\n    }\n\n    #[test]\n    fn is_uuid_rejects_bad_format() {\n        assert!(!is_uuid(\"too-short\"));\n        assert!(!is_uuid(\"aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeee\")); // 35 chars\n        assert!(!is_uuid(\"aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeeee\")); // 37 chars\n        assert!(!is_uuid(\"gaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee\")); // non-hex\n        assert!(!is_uuid(\"aaaaaaaaabbbb-cccc-dddd-eeeeeeeeeeee\")); // missing dash at pos 8\n    }\n\n    // ── parse_uuid_from_lsof_output ──\n\n    #[test]\n    fn parse_lsof_output_valid() {\n        let output = \"node    1234  user  txt  REG  /Users/me/.claude/tasks/aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee/foo.json\\n\";\n        assert_eq!(\n            parse_uuid_from_lsof_output(output),\n            Some(\"aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee\".to_string())\n        );\n    }\n\n    #[test]\n    fn parse_lsof_output_no_match() {\n        let output = \"node    1234  user  txt  REG  /Users/me/.claude/other/file.json\\n\";\n        assert_eq!(parse_uuid_from_lsof_output(output), None);\n    }\n\n    // ── update_global_stats_inner: no-new-bytes (incremental skip) ──\n\n    #[test]\n    fn global_stats_inner_no_new_bytes_skips_reread() {\n        let dir = tempfile::tempdir().unwrap();\n        let today = chrono::Local::now().format(\"%Y-%m-%d\").to_string();\n\n        let subdir = dir.path().join(\"proj\");\n        std::fs::create_dir_all(&subdir).unwrap();\n        let line = format!(\n            r#\"{{\"type\":\"assistant\",\"timestamp\":\"{today}T10:00:00Z\",\"message\":{{\"usage\":{{\"input_tokens\":50,\"output_tokens\":10}},\"content\":[]}}}}\"#,\n        );\n        std::fs::write(subdir.join(\"log.jsonl\"), format!(\"{line}\\n\")).unwrap();\n\n        let mut stats = GlobalStats::default();\n        stats.date = today.clone();\n        update_global_stats_inner(&mut stats, &today, Some(dir.path()));\n        assert_eq!(stats.tokens_in, 50);\n\n        // Second call without changes — should hit file_len <= offset path\n        update_global_stats_inner(&mut stats, &today, Some(dir.path()));\n        assert_eq!(stats.tokens_in, 50, \"should not re-count on unchanged file\");\n    }\n\n    // ── update_global_stats_inner: short lines skipped ──\n\n    #[test]\n    fn global_stats_inner_short_lines_skipped() {\n        let dir = tempfile::tempdir().unwrap();\n        let today = chrono::Local::now().format(\"%Y-%m-%d\").to_string();\n\n        let subdir = dir.path().join(\"proj\");\n        std::fs::create_dir_all(&subdir).unwrap();\n        // Short lines (<10 chars) should be skipped\n        std::fs::write(subdir.join(\"log.jsonl\"), \"short\\n{}\\n\\n\").unwrap();\n\n        let mut stats = GlobalStats::default();\n        stats.date = today.clone();\n        update_global_stats_inner(&mut stats, &today, Some(dir.path()));\n        assert_eq!(stats.tokens_in, 0, \"short lines should not parse\");\n    }\n\n    // ── update_global_stats_inner: file open error ──\n\n    #[test]\n    fn global_stats_inner_unreadable_file_skipped() {\n        let dir = tempfile::tempdir().unwrap();\n        let today = chrono::Local::now().format(\"%Y-%m-%d\").to_string();\n\n        // Create a subdir with a symlink to a nonexistent file\n        let subdir = dir.path().join(\"proj\");\n        std::fs::create_dir_all(&subdir).unwrap();\n        #[cfg(unix)]\n        {\n            std::os::unix::fs::symlink(\"/nonexistent/path\", subdir.join(\"bad.jsonl\")).unwrap();\n        }\n\n        let mut stats = GlobalStats::default();\n        stats.date = today.clone();\n        // Should not panic — the broken symlink triggers Err on File::open\n        update_global_stats_inner(&mut stats, &today, Some(dir.path()));\n        assert_eq!(stats.tokens_in, 0);\n    }\n\n    // ── update_session_stats: unknown tool name hits default arm ──\n\n    #[test]\n    fn update_session_stats_unknown_tool_name_ignored() {\n        let dir = tempfile::tempdir().unwrap();\n        let path = dir.path().join(\"log.jsonl\");\n        // tool_use with an unrecognized tool name\n        let line = r#\"{\"type\":\"assistant\",\"message\":{\"usage\":{\"input_tokens\":10,\"output_tokens\":5},\"content\":[{\"type\":\"tool_use\",\"name\":\"UnknownTool\",\"input\":{}}]}}\"#;\n        std::fs::write(&path, format!(\"{line}\\n\")).unwrap();\n\n        let mut stats = SessionStats::default();\n        update_session_stats_from_path(&path, &mut stats);\n        assert_eq!(stats.turns, 1, \"should still count the turn\");\n        assert_eq!(stats.edits, 0, \"unknown tool should not count as edit\");\n        assert_eq!(stats.bash_cmds, 0, \"unknown tool should not count as bash\");\n    }\n\n    // ── read_last_assistant_message: non-assistant lines only ──\n\n    #[test]\n    fn read_last_assistant_message_no_assistant_returns_none() {\n        let dir = tempfile::tempdir().unwrap();\n        let _guard = HomeGuard::set(dir.path());\n\n        let cwd = \"/test/noassist\";\n        let uuid = \"aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee\";\n        let escaped = escape_project_path(cwd);\n        let jsonl_dir = dir.path().join(\".claude\").join(\"projects\").join(&escaped);\n        std::fs::create_dir_all(&jsonl_dir).unwrap();\n\n        // Only user messages, no assistant messages\n        let content = concat!(\n            r#\"{\"type\":\"user\",\"message\":{\"content\":[{\"text\":\"hello\"}]}}\"#,\n            \"\\n\",\n            r#\"{\"type\":\"user\",\"message\":{\"content\":[{\"text\":\"bye\"}]}}\"#,\n            \"\\n\",\n        );\n        std::fs::write(jsonl_dir.join(format!(\"{uuid}.jsonl\")), content).unwrap();\n\n        let result = read_last_assistant_message(cwd, uuid);\n        assert_eq!(result, None, \"no assistant messages should return None\");\n    }\n\n    // ── read_last_assistant_message: malformed JSON line ──\n\n    #[test]\n    fn read_last_assistant_message_malformed_json_skipped() {\n        let dir = tempfile::tempdir().unwrap();\n        let _guard = HomeGuard::set(dir.path());\n\n        let cwd = \"/test/malformed\";\n        let uuid = \"aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee\";\n        let escaped = escape_project_path(cwd);\n        let jsonl_dir = dir.path().join(\".claude\").join(\"projects\").join(&escaped);\n        std::fs::create_dir_all(&jsonl_dir).unwrap();\n\n        // Malformed line with \"assistant\" keyword, followed by a valid assistant message\n        let content = concat!(\n            r#\"{\"type\":\"assistant\" BROKEN JSON\"#,\n            \"\\n\",\n            r#\"{\"type\":\"assistant\",\"message\":{\"content\":[{\"text\":\"Valid msg\"}]}}\"#,\n            \"\\n\",\n        );\n        std::fs::write(jsonl_dir.join(format!(\"{uuid}.jsonl\")), content).unwrap();\n\n        let result = read_last_assistant_message(cwd, uuid);\n        assert_eq!(\n            result,\n            Some(\"Valid msg\".to_string()),\n            \"should skip malformed and return valid\"\n        );\n    }\n\n    // ── read_last_assistant_message: false positive (type != assistant) ──\n\n    #[test]\n    fn read_last_assistant_message_non_assistant_type_skipped() {\n        let dir = tempfile::tempdir().unwrap();\n        let _guard = HomeGuard::set(dir.path());\n\n        let cwd = \"/test/falsepos\";\n        let uuid = \"aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee\";\n        let escaped = escape_project_path(cwd);\n        let jsonl_dir = dir.path().join(\".claude\").join(\"projects\").join(&escaped);\n        std::fs::create_dir_all(&jsonl_dir).unwrap();\n\n        // Line passes the quick filter (contains \"assistant\" as a JSON key)\n        // but has type != \"assistant\", hitting the continue at the type check\n        let content = concat!(\n            r#\"{\"type\":\"system\",\"assistant\":\"yes\",\"message\":{\"content\":[{\"text\":\"should not appear\"}]}}\"#,\n            \"\\n\",\n        );\n        std::fs::write(jsonl_dir.join(format!(\"{uuid}.jsonl\")), content).unwrap();\n\n        let result = read_last_assistant_message(cwd, uuid);\n        assert_eq!(result, None, \"non-assistant type should be skipped\");\n    }\n\n    // ── read_last_assistant_message: content with no text items ──\n\n    #[test]\n    fn read_last_assistant_message_no_text_content_returns_none() {\n        let dir = tempfile::tempdir().unwrap();\n        let _guard = HomeGuard::set(dir.path());\n\n        let cwd = \"/test/notext\";\n        let uuid = \"aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee\";\n        let escaped = escape_project_path(cwd);\n        let jsonl_dir = dir.path().join(\".claude\").join(\"projects\").join(&escaped);\n        std::fs::create_dir_all(&jsonl_dir).unwrap();\n\n        // Assistant message with only tool_use, no text\n        let content = r#\"{\"type\":\"assistant\",\"message\":{\"content\":[{\"type\":\"tool_use\",\"name\":\"Bash\",\"input\":{}}]}}\"#;\n        std::fs::write(\n            jsonl_dir.join(format!(\"{uuid}.jsonl\")),\n            format!(\"{content}\\n\"),\n        )\n        .unwrap();\n\n        let result = read_last_assistant_message(cwd, uuid);\n        assert_eq!(\n            result, None,\n            \"assistant with no text content should return None\"\n        );\n    }\n\n    // ── update_session_stats: incremental seek path ──\n\n    #[test]\n    fn update_session_stats_from_path_incremental_seek() {\n        let dir = tempfile::tempdir().unwrap();\n        let path = dir.path().join(\"log.jsonl\");\n\n        // Write initial content\n        let line1 = r#\"{\"type\":\"assistant\",\"message\":{\"usage\":{\"input_tokens\":10,\"output_tokens\":5},\"content\":[]}}\"#;\n        std::fs::write(&path, format!(\"{line1}\\n\")).unwrap();\n\n        let mut stats = SessionStats::default();\n        update_session_stats_from_path(&path, &mut stats);\n        assert_eq!(stats.turns, 1);\n\n        // Append more and read again — exercises the seek path (offset > 0)\n        use std::io::Write;\n        let mut file = std::fs::OpenOptions::new()\n            .append(true)\n            .open(&path)\n            .unwrap();\n        let line2 = r#\"{\"type\":\"assistant\",\"message\":{\"usage\":{\"input_tokens\":20,\"output_tokens\":10},\"content\":[]}}\"#;\n        writeln!(file, \"{line2}\").unwrap();\n\n        update_session_stats_from_path(&path, &mut stats);\n        assert_eq!(stats.turns, 2);\n        assert_eq!(stats.tokens_in, 30);\n    }\n\n    // ── update_session_stats: tool_use with multiple tool types including unknown ──\n\n    #[test]\n    fn update_session_stats_mixed_tool_types() {\n        let dir = tempfile::tempdir().unwrap();\n        let path = dir.path().join(\"log.jsonl\");\n        let line = r#\"{\"type\":\"assistant\",\"message\":{\"usage\":{\"input_tokens\":10,\"output_tokens\":5},\"content\":[{\"type\":\"tool_use\",\"name\":\"Write\",\"input\":{}},{\"type\":\"tool_use\",\"name\":\"Bash\",\"input\":{}},{\"type\":\"tool_use\",\"name\":\"Read\",\"input\":{}},{\"type\":\"tool_use\",\"name\":\"Edit\",\"input\":{}}]}}\"#;\n        std::fs::write(&path, format!(\"{line}\\n\")).unwrap();\n\n        let mut stats = SessionStats::default();\n        update_session_stats_from_path(&path, &mut stats);\n        assert_eq!(stats.edits, 2, \"Write + Edit = 2 edits\");\n        assert_eq!(stats.bash_cmds, 1, \"1 Bash command\");\n        // Read and other tools don't increment any counter\n    }\n\n    // ── queue-operation subagent tracking ──\n\n    #[test]\n    fn stats_queue_operation_enqueue_increments_subagents() {\n        let dir = tempfile::tempdir().unwrap();\n        let path = dir.path().join(\"log.jsonl\");\n        let lines = [\n            r#\"{\"type\":\"queue-operation\",\"operation\":\"enqueue\",\"taskId\":\"a\"}\"#,\n            r#\"{\"type\":\"queue-operation\",\"operation\":\"enqueue\",\"taskId\":\"b\"}\"#,\n        ];\n        std::fs::write(&path, lines.join(\"\\n\") + \"\\n\").unwrap();\n\n        let mut stats = SessionStats::default();\n        update_session_stats_from_path(&path, &mut stats);\n        assert_eq!(stats.active_subagents, 2);\n    }\n\n    #[test]\n    fn stats_queue_operation_remove_decrements_subagents() {\n        let dir = tempfile::tempdir().unwrap();\n        let path = dir.path().join(\"log.jsonl\");\n        let lines = [\n            r#\"{\"type\":\"queue-operation\",\"operation\":\"enqueue\",\"taskId\":\"a\"}\"#,\n            r#\"{\"type\":\"queue-operation\",\"operation\":\"enqueue\",\"taskId\":\"b\"}\"#,\n            r#\"{\"type\":\"queue-operation\",\"operation\":\"remove\",\"taskId\":\"a\"}\"#,\n        ];\n        std::fs::write(&path, lines.join(\"\\n\") + \"\\n\").unwrap();\n\n        let mut stats = SessionStats::default();\n        update_session_stats_from_path(&path, &mut stats);\n        assert_eq!(stats.active_subagents, 1);\n    }\n\n    #[test]\n    fn stats_queue_operation_remove_saturates_at_zero() {\n        let dir = tempfile::tempdir().unwrap();\n        let path = dir.path().join(\"log.jsonl\");\n        let lines = [\n            r#\"{\"type\":\"queue-operation\",\"operation\":\"remove\",\"taskId\":\"x\"}\"#,\n        ];\n        std::fs::write(&path, lines.join(\"\\n\") + \"\\n\").unwrap();\n\n        let mut stats = SessionStats::default();\n        update_session_stats_from_path(&path, &mut stats);\n        assert_eq!(stats.active_subagents, 0);\n    }\n\n    // ── escape_project_path ──\n\n    #[test]\n    fn escape_project_path_replaces_slashes() {\n        assert_eq!(\n            escape_project_path(\"/Users/me/project\"),\n            \"-Users-me-project\"\n        );\n        assert_eq!(escape_project_path(\"no-slashes\"), \"no-slashes\");\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":2}},{"line":57,"address":[],"length":0,"stats":{"Line":4}},{"line":58,"address":[],"length":0,"stats":{"Line":4}},{"line":59,"address":[],"length":0,"stats":{"Line":4}},{"line":60,"address":[],"length":0,"stats":{"Line":4}},{"line":61,"address":[],"length":0,"stats":{"Line":2}},{"line":65,"address":[],"length":0,"stats":{"Line":6}},{"line":66,"address":[],"length":0,"stats":{"Line":12}},{"line":72,"address":[],"length":0,"stats":{"Line":197}},{"line":73,"address":[],"length":0,"stats":{"Line":677}},{"line":74,"address":[],"length":0,"stats":{"Line":172}},{"line":76,"address":[],"length":0,"stats":{"Line":86}},{"line":77,"address":[],"length":0,"stats":{"Line":21}},{"line":78,"address":[],"length":0,"stats":{"Line":63}},{"line":79,"address":[],"length":0,"stats":{"Line":21}},{"line":81,"address":[],"length":0,"stats":{"Line":4}},{"line":84,"address":[],"length":0,"stats":{"Line":19}},{"line":89,"address":[],"length":0,"stats":{"Line":130}},{"line":95,"address":[],"length":0,"stats":{"Line":8262}},{"line":97,"address":[],"length":0,"stats":{"Line":33972400}},{"line":98,"address":[],"length":0,"stats":{"Line":18}},{"line":99,"address":[],"length":0,"stats":{"Line":18}},{"line":100,"address":[],"length":0,"stats":{"Line":6}},{"line":104,"address":[],"length":0,"stats":{"Line":8306}},{"line":105,"address":[],"length":0,"stats":{"Line":150}},{"line":106,"address":[],"length":0,"stats":{"Line":150}},{"line":107,"address":[],"length":0,"stats":{"Line":100}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":33024}},{"line":114,"address":[],"length":0,"stats":{"Line":24768}},{"line":119,"address":[],"length":0,"stats":{"Line":111}},{"line":120,"address":[],"length":0,"stats":{"Line":333}},{"line":124,"address":[],"length":0,"stats":{"Line":9}},{"line":125,"address":[],"length":0,"stats":{"Line":9}},{"line":126,"address":[],"length":0,"stats":{"Line":4}},{"line":127,"address":[],"length":0,"stats":{"Line":7}},{"line":128,"address":[],"length":0,"stats":{"Line":10}},{"line":130,"address":[],"length":0,"stats":{"Line":2}},{"line":135,"address":[],"length":0,"stats":{"Line":6}},{"line":136,"address":[],"length":0,"stats":{"Line":6}},{"line":137,"address":[],"length":0,"stats":{"Line":4}},{"line":138,"address":[],"length":0,"stats":{"Line":4}},{"line":139,"address":[],"length":0,"stats":{"Line":3}},{"line":141,"address":[],"length":0,"stats":{"Line":1}},{"line":148,"address":[],"length":0,"stats":{"Line":2}},{"line":149,"address":[],"length":0,"stats":{"Line":6}},{"line":154,"address":[],"length":0,"stats":{"Line":2}},{"line":159,"address":[],"length":0,"stats":{"Line":6}},{"line":160,"address":[],"length":0,"stats":{"Line":3}},{"line":161,"address":[],"length":0,"stats":{"Line":2}},{"line":162,"address":[],"length":0,"stats":{"Line":1}},{"line":164,"address":[],"length":0,"stats":{"Line":4}},{"line":167,"address":[],"length":0,"stats":{"Line":2}},{"line":168,"address":[],"length":0,"stats":{"Line":1}},{"line":170,"address":[],"length":0,"stats":{"Line":3}},{"line":176,"address":[],"length":0,"stats":{"Line":37}},{"line":177,"address":[],"length":0,"stats":{"Line":74}},{"line":180,"address":[],"length":0,"stats":{"Line":38}},{"line":184,"address":[],"length":0,"stats":{"Line":74}},{"line":185,"address":[],"length":0,"stats":{"Line":72}},{"line":186,"address":[],"length":0,"stats":{"Line":2}},{"line":188,"address":[],"length":0,"stats":{"Line":72}},{"line":189,"address":[],"length":0,"stats":{"Line":108}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":36}},{"line":195,"address":[],"length":0,"stats":{"Line":2}},{"line":199,"address":[],"length":0,"stats":{"Line":34}},{"line":200,"address":[],"length":0,"stats":{"Line":9}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":68}},{"line":206,"address":[],"length":0,"stats":{"Line":102}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":102}},{"line":210,"address":[],"length":0,"stats":{"Line":102}},{"line":212,"address":[],"length":0,"stats":{"Line":84}},{"line":214,"address":[],"length":0,"stats":{"Line":50}},{"line":215,"address":[],"length":0,"stats":{"Line":2}},{"line":219,"address":[],"length":0,"stats":{"Line":96}},{"line":220,"address":[],"length":0,"stats":{"Line":49}},{"line":221,"address":[],"length":0,"stats":{"Line":144}},{"line":222,"address":[],"length":0,"stats":{"Line":108}},{"line":223,"address":[],"length":0,"stats":{"Line":18}},{"line":226,"address":[],"length":0,"stats":{"Line":48}},{"line":227,"address":[],"length":0,"stats":{"Line":12}},{"line":231,"address":[],"length":0,"stats":{"Line":143}},{"line":232,"address":[],"length":0,"stats":{"Line":23}},{"line":233,"address":[],"length":0,"stats":{"Line":23}},{"line":234,"address":[],"length":0,"stats":{"Line":23}},{"line":235,"address":[],"length":0,"stats":{"Line":69}},{"line":236,"address":[],"length":0,"stats":{"Line":23}},{"line":237,"address":[],"length":0,"stats":{"Line":23}},{"line":238,"address":[],"length":0,"stats":{"Line":23}},{"line":239,"address":[],"length":0,"stats":{"Line":69}},{"line":240,"address":[],"length":0,"stats":{"Line":23}},{"line":241,"address":[],"length":0,"stats":{"Line":23}},{"line":242,"address":[],"length":0,"stats":{"Line":23}},{"line":243,"address":[],"length":0,"stats":{"Line":53}},{"line":244,"address":[],"length":0,"stats":{"Line":23}},{"line":245,"address":[],"length":0,"stats":{"Line":23}},{"line":246,"address":[],"length":0,"stats":{"Line":23}},{"line":247,"address":[],"length":0,"stats":{"Line":53}},{"line":248,"address":[],"length":0,"stats":{"Line":23}},{"line":252,"address":[],"length":0,"stats":{"Line":48}},{"line":254,"address":[],"length":0,"stats":{"Line":72}},{"line":255,"address":[],"length":0,"stats":{"Line":72}},{"line":257,"address":[],"length":0,"stats":{"Line":52}},{"line":258,"address":[],"length":0,"stats":{"Line":168}},{"line":259,"address":[],"length":0,"stats":{"Line":96}},{"line":260,"address":[],"length":0,"stats":{"Line":16}},{"line":261,"address":[],"length":0,"stats":{"Line":36}},{"line":262,"address":[],"length":0,"stats":{"Line":12}},{"line":263,"address":[],"length":0,"stats":{"Line":4}},{"line":271,"address":[],"length":0,"stats":{"Line":25}},{"line":275,"address":[],"length":0,"stats":{"Line":46}},{"line":276,"address":[],"length":0,"stats":{"Line":26}},{"line":277,"address":[],"length":0,"stats":{"Line":6}},{"line":279,"address":[],"length":0,"stats":{"Line":10}},{"line":280,"address":[],"length":0,"stats":{"Line":30}},{"line":281,"address":[],"length":0,"stats":{"Line":28}},{"line":282,"address":[],"length":0,"stats":{"Line":8}},{"line":286,"address":[],"length":0,"stats":{"Line":5}},{"line":290,"address":[],"length":0,"stats":{"Line":52}},{"line":291,"address":[],"length":0,"stats":{"Line":16}},{"line":292,"address":[],"length":0,"stats":{"Line":16}},{"line":294,"address":[],"length":0,"stats":{"Line":24}},{"line":295,"address":[],"length":0,"stats":{"Line":24}},{"line":297,"address":[],"length":0,"stats":{"Line":22}},{"line":298,"address":[],"length":0,"stats":{"Line":38}},{"line":299,"address":[],"length":0,"stats":{"Line":36}},{"line":304,"address":[],"length":0,"stats":{"Line":8}},{"line":308,"address":[],"length":0,"stats":{"Line":20}},{"line":309,"address":[],"length":0,"stats":{"Line":12}},{"line":310,"address":[],"length":0,"stats":{"Line":36}},{"line":311,"address":[],"length":0,"stats":{"Line":30}},{"line":312,"address":[],"length":0,"stats":{"Line":10}},{"line":313,"address":[],"length":0,"stats":{"Line":4}},{"line":315,"address":[],"length":0,"stats":{"Line":4}},{"line":316,"address":[],"length":0,"stats":{"Line":2}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":34}},{"line":326,"address":[],"length":0,"stats":{"Line":34}},{"line":377,"address":[],"length":0,"stats":{"Line":191}},{"line":390,"address":[],"length":0,"stats":{"Line":382}},{"line":391,"address":[],"length":0,"stats":{"Line":382}},{"line":392,"address":[],"length":0,"stats":{"Line":382}},{"line":393,"address":[],"length":0,"stats":{"Line":191}},{"line":395,"address":[],"length":0,"stats":{"Line":191}},{"line":404,"address":[],"length":0,"stats":{"Line":5}},{"line":405,"address":[],"length":0,"stats":{"Line":10}},{"line":406,"address":[],"length":0,"stats":{"Line":5}},{"line":407,"address":[],"length":0,"stats":{"Line":5}},{"line":408,"address":[],"length":0,"stats":{"Line":5}},{"line":409,"address":[],"length":0,"stats":{"Line":5}},{"line":410,"address":[],"length":0,"stats":{"Line":3}},{"line":411,"address":[],"length":0,"stats":{"Line":3}},{"line":414,"address":[],"length":0,"stats":{"Line":5}},{"line":415,"address":[],"length":0,"stats":{"Line":6}},{"line":416,"address":[],"length":0,"stats":{"Line":6}},{"line":417,"address":[],"length":0,"stats":{"Line":6}},{"line":418,"address":[],"length":0,"stats":{"Line":6}},{"line":419,"address":[],"length":0,"stats":{"Line":3}},{"line":422,"address":[],"length":0,"stats":{"Line":4}},{"line":423,"address":[],"length":0,"stats":{"Line":4}},{"line":424,"address":[],"length":0,"stats":{"Line":4}},{"line":425,"address":[],"length":0,"stats":{"Line":4}},{"line":427,"address":[],"length":0,"stats":{"Line":4}},{"line":428,"address":[],"length":0,"stats":{"Line":2}},{"line":429,"address":[],"length":0,"stats":{"Line":4}},{"line":430,"address":[],"length":0,"stats":{"Line":2}},{"line":431,"address":[],"length":0,"stats":{"Line":2}},{"line":432,"address":[],"length":0,"stats":{"Line":4}},{"line":433,"address":[],"length":0,"stats":{"Line":2}},{"line":434,"address":[],"length":0,"stats":{"Line":2}},{"line":436,"address":[],"length":0,"stats":{"Line":2}},{"line":437,"address":[],"length":0,"stats":{"Line":2}},{"line":438,"address":[],"length":0,"stats":{"Line":2}},{"line":439,"address":[],"length":0,"stats":{"Line":2}},{"line":440,"address":[],"length":0,"stats":{"Line":2}},{"line":441,"address":[],"length":0,"stats":{"Line":2}},{"line":442,"address":[],"length":0,"stats":{"Line":2}},{"line":449,"address":[],"length":0,"stats":{"Line":2}},{"line":450,"address":[],"length":0,"stats":{"Line":8}},{"line":453,"address":[],"length":0,"stats":{"Line":4}},{"line":454,"address":[],"length":0,"stats":{"Line":4}},{"line":455,"address":[],"length":0,"stats":{"Line":4}},{"line":456,"address":[],"length":0,"stats":{"Line":4}},{"line":457,"address":[],"length":0,"stats":{"Line":4}},{"line":458,"address":[],"length":0,"stats":{"Line":4}},{"line":459,"address":[],"length":0,"stats":{"Line":4}},{"line":460,"address":[],"length":0,"stats":{"Line":4}},{"line":461,"address":[],"length":0,"stats":{"Line":4}},{"line":462,"address":[],"length":0,"stats":{"Line":4}},{"line":463,"address":[],"length":0,"stats":{"Line":4}},{"line":464,"address":[],"length":0,"stats":{"Line":4}},{"line":465,"address":[],"length":0,"stats":{"Line":6}},{"line":466,"address":[],"length":0,"stats":{"Line":6}},{"line":467,"address":[],"length":0,"stats":{"Line":6}},{"line":468,"address":[],"length":0,"stats":{"Line":6}},{"line":469,"address":[],"length":0,"stats":{"Line":4}},{"line":470,"address":[],"length":0,"stats":{"Line":4}},{"line":473,"address":[],"length":0,"stats":{"Line":8}},{"line":477,"address":[],"length":0,"stats":{"Line":22}},{"line":482,"address":[],"length":0,"stats":{"Line":64}},{"line":483,"address":[],"length":0,"stats":{"Line":76}},{"line":485,"address":[],"length":0,"stats":{"Line":5}},{"line":486,"address":[],"length":0,"stats":{"Line":4}},{"line":487,"address":[],"length":0,"stats":{"Line":1}},{"line":490,"address":[],"length":0,"stats":{"Line":4}},{"line":491,"address":[],"length":0,"stats":{"Line":2}},{"line":496,"address":[],"length":0,"stats":{"Line":63}},{"line":497,"address":[],"length":0,"stats":{"Line":42}},{"line":498,"address":[],"length":0,"stats":{"Line":4}},{"line":500,"address":[],"length":0,"stats":{"Line":21}},{"line":501,"address":[],"length":0,"stats":{"Line":34}},{"line":502,"address":[],"length":0,"stats":{"Line":51}},{"line":503,"address":[],"length":0,"stats":{"Line":34}},{"line":505,"address":[],"length":0,"stats":{"Line":34}},{"line":506,"address":[],"length":0,"stats":{"Line":51}},{"line":507,"address":[],"length":0,"stats":{"Line":34}},{"line":509,"address":[],"length":0,"stats":{"Line":85}},{"line":510,"address":[],"length":0,"stats":{"Line":17}},{"line":511,"address":[],"length":0,"stats":{"Line":17}},{"line":512,"address":[],"length":0,"stats":{"Line":17}},{"line":514,"address":[],"length":0,"stats":{"Line":85}},{"line":515,"address":[],"length":0,"stats":{"Line":17}},{"line":516,"address":[],"length":0,"stats":{"Line":17}},{"line":517,"address":[],"length":0,"stats":{"Line":17}},{"line":519,"address":[],"length":0,"stats":{"Line":17}},{"line":523,"address":[],"length":0,"stats":{"Line":63}},{"line":524,"address":[],"length":0,"stats":{"Line":53}},{"line":525,"address":[],"length":0,"stats":{"Line":48}},{"line":529,"address":[],"length":0,"stats":{"Line":63}},{"line":530,"address":[],"length":0,"stats":{"Line":25}},{"line":531,"address":[],"length":0,"stats":{"Line":6}},{"line":535,"address":[],"length":0,"stats":{"Line":12}},{"line":542,"address":[],"length":0,"stats":{"Line":12}},{"line":543,"address":[],"length":0,"stats":{"Line":12}},{"line":544,"address":[],"length":0,"stats":{"Line":12}},{"line":545,"address":[],"length":0,"stats":{"Line":12}},{"line":547,"address":[],"length":0,"stats":{"Line":12}},{"line":548,"address":[],"length":0,"stats":{"Line":12}},{"line":549,"address":[],"length":0,"stats":{"Line":12}},{"line":550,"address":[],"length":0,"stats":{"Line":12}},{"line":553,"address":[],"length":0,"stats":{"Line":3}},{"line":559,"address":[],"length":0,"stats":{"Line":3}},{"line":560,"address":[],"length":0,"stats":{"Line":3}},{"line":561,"address":[],"length":0,"stats":{"Line":3}},{"line":563,"address":[],"length":0,"stats":{"Line":3}},{"line":564,"address":[],"length":0,"stats":{"Line":3}},{"line":565,"address":[],"length":0,"stats":{"Line":3}},{"line":568,"address":[],"length":0,"stats":{"Line":16}},{"line":569,"address":[],"length":0,"stats":{"Line":31}},{"line":570,"address":[],"length":0,"stats":{"Line":30}},{"line":571,"address":[],"length":0,"stats":{"Line":1}},{"line":573,"address":[],"length":0,"stats":{"Line":30}},{"line":574,"address":[],"length":0,"stats":{"Line":45}},{"line":575,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":90}},{"line":579,"address":[],"length":0,"stats":{"Line":15}},{"line":580,"address":[],"length":0,"stats":{"Line":1}},{"line":583,"address":[],"length":0,"stats":{"Line":20}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":28}},{"line":588,"address":[],"length":0,"stats":{"Line":42}},{"line":589,"address":[],"length":0,"stats":{"Line":0}},{"line":591,"address":[],"length":0,"stats":{"Line":42}},{"line":593,"address":[],"length":0,"stats":{"Line":32}},{"line":594,"address":[],"length":0,"stats":{"Line":18}},{"line":595,"address":[],"length":0,"stats":{"Line":3}},{"line":597,"address":[],"length":0,"stats":{"Line":56}},{"line":598,"address":[],"length":0,"stats":{"Line":2}},{"line":600,"address":[],"length":0,"stats":{"Line":26}},{"line":601,"address":[],"length":0,"stats":{"Line":78}},{"line":602,"address":[],"length":0,"stats":{"Line":1}},{"line":604,"address":[],"length":0,"stats":{"Line":72}},{"line":606,"address":[],"length":0,"stats":{"Line":12}},{"line":607,"address":[],"length":0,"stats":{"Line":12}},{"line":608,"address":[],"length":0,"stats":{"Line":12}},{"line":609,"address":[],"length":0,"stats":{"Line":36}},{"line":610,"address":[],"length":0,"stats":{"Line":12}},{"line":611,"address":[],"length":0,"stats":{"Line":12}},{"line":612,"address":[],"length":0,"stats":{"Line":12}},{"line":613,"address":[],"length":0,"stats":{"Line":36}},{"line":614,"address":[],"length":0,"stats":{"Line":12}},{"line":615,"address":[],"length":0,"stats":{"Line":12}},{"line":616,"address":[],"length":0,"stats":{"Line":12}},{"line":617,"address":[],"length":0,"stats":{"Line":28}},{"line":618,"address":[],"length":0,"stats":{"Line":12}},{"line":619,"address":[],"length":0,"stats":{"Line":12}},{"line":620,"address":[],"length":0,"stats":{"Line":12}},{"line":621,"address":[],"length":0,"stats":{"Line":28}},{"line":622,"address":[],"length":0,"stats":{"Line":12}},{"line":628,"address":[],"length":0,"stats":{"Line":70}},{"line":631,"address":[],"length":0,"stats":{"Line":2}},{"line":632,"address":[],"length":0,"stats":{"Line":4}},{"line":633,"address":[],"length":0,"stats":{"Line":4}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":4}},{"line":637,"address":[],"length":0,"stats":{"Line":6}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":641,"address":[],"length":0,"stats":{"Line":4}},{"line":642,"address":[],"length":0,"stats":{"Line":2}},{"line":643,"address":[],"length":0,"stats":{"Line":4}},{"line":644,"address":[],"length":0,"stats":{"Line":2}},{"line":646,"address":[],"length":0,"stats":{"Line":4}},{"line":647,"address":[],"length":0,"stats":{"Line":2}},{"line":648,"address":[],"length":0,"stats":{"Line":4}},{"line":649,"address":[],"length":0,"stats":{"Line":2}},{"line":651,"address":[],"length":0,"stats":{"Line":4}},{"line":652,"address":[],"length":0,"stats":{"Line":2}},{"line":653,"address":[],"length":0,"stats":{"Line":4}},{"line":654,"address":[],"length":0,"stats":{"Line":2}},{"line":656,"address":[],"length":0,"stats":{"Line":4}},{"line":657,"address":[],"length":0,"stats":{"Line":2}},{"line":658,"address":[],"length":0,"stats":{"Line":4}},{"line":659,"address":[],"length":0,"stats":{"Line":2}},{"line":661,"address":[],"length":0,"stats":{"Line":4}},{"line":662,"address":[],"length":0,"stats":{"Line":2}},{"line":663,"address":[],"length":0,"stats":{"Line":4}},{"line":664,"address":[],"length":0,"stats":{"Line":2}},{"line":667,"address":[],"length":0,"stats":{"Line":2}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":5}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[],"length":0,"stats":{"Line":4}},{"line":676,"address":[],"length":0,"stats":{"Line":6}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":679,"address":[],"length":0,"stats":{"Line":6}},{"line":681,"address":[],"length":0,"stats":{"Line":7}},{"line":682,"address":[],"length":0,"stats":{"Line":5}},{"line":683,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":10}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":10}},{"line":690,"address":[],"length":0,"stats":{"Line":10}},{"line":691,"address":[],"length":0,"stats":{"Line":0}},{"line":694,"address":[],"length":0,"stats":{"Line":30}},{"line":695,"address":[],"length":0,"stats":{"Line":0}},{"line":697,"address":[],"length":0,"stats":{"Line":10}},{"line":698,"address":[],"length":0,"stats":{"Line":10}},{"line":699,"address":[],"length":0,"stats":{"Line":0}},{"line":701,"address":[],"length":0,"stats":{"Line":30}},{"line":702,"address":[],"length":0,"stats":{"Line":0}},{"line":705,"address":[],"length":0,"stats":{"Line":30}},{"line":706,"address":[],"length":0,"stats":{"Line":10}},{"line":707,"address":[],"length":0,"stats":{"Line":0}},{"line":710,"address":[],"length":0,"stats":{"Line":10}},{"line":712,"address":[],"length":0,"stats":{"Line":15}},{"line":714,"address":[],"length":0,"stats":{"Line":10}},{"line":716,"address":[],"length":0,"stats":{"Line":15}},{"line":718,"address":[],"length":0,"stats":{"Line":10}},{"line":720,"address":[],"length":0,"stats":{"Line":15}},{"line":722,"address":[],"length":0,"stats":{"Line":10}},{"line":724,"address":[],"length":0,"stats":{"Line":15}},{"line":725,"address":[],"length":0,"stats":{"Line":20}},{"line":727,"address":[],"length":0,"stats":{"Line":10}},{"line":729,"address":[],"length":0,"stats":{"Line":15}},{"line":730,"address":[],"length":0,"stats":{"Line":20}},{"line":732,"address":[],"length":0,"stats":{"Line":5}},{"line":733,"address":[],"length":0,"stats":{"Line":7}},{"line":734,"address":[],"length":0,"stats":{"Line":15}},{"line":735,"address":[],"length":0,"stats":{"Line":15}},{"line":736,"address":[],"length":0,"stats":{"Line":6}},{"line":737,"address":[],"length":0,"stats":{"Line":12}},{"line":738,"address":[],"length":0,"stats":{"Line":12}},{"line":743,"address":[],"length":0,"stats":{"Line":5}},{"line":744,"address":[],"length":0,"stats":{"Line":5}},{"line":745,"address":[],"length":0,"stats":{"Line":5}},{"line":746,"address":[],"length":0,"stats":{"Line":5}},{"line":749,"address":[],"length":0,"stats":{"Line":4}},{"line":750,"address":[],"length":0,"stats":{"Line":4}},{"line":751,"address":[],"length":0,"stats":{"Line":2}},{"line":752,"address":[],"length":0,"stats":{"Line":4}},{"line":753,"address":[],"length":0,"stats":{"Line":4}},{"line":754,"address":[],"length":0,"stats":{"Line":4}},{"line":755,"address":[],"length":0,"stats":{"Line":2}},{"line":756,"address":[],"length":0,"stats":{"Line":2}},{"line":763,"address":[],"length":0,"stats":{"Line":63}},{"line":764,"address":[],"length":0,"stats":{"Line":63}},{"line":765,"address":[],"length":0,"stats":{"Line":2}},{"line":767,"address":[],"length":0,"stats":{"Line":103}},{"line":768,"address":[],"length":0,"stats":{"Line":84}},{"line":769,"address":[],"length":0,"stats":{"Line":19}},{"line":771,"address":[],"length":0,"stats":{"Line":128}},{"line":772,"address":[],"length":0,"stats":{"Line":132}},{"line":773,"address":[],"length":0,"stats":{"Line":72}},{"line":774,"address":[],"length":0,"stats":{"Line":84}},{"line":775,"address":[],"length":0,"stats":{"Line":123}},{"line":776,"address":[],"length":0,"stats":{"Line":30}},{"line":782,"address":[],"length":0,"stats":{"Line":0}},{"line":783,"address":[],"length":0,"stats":{"Line":0}},{"line":784,"address":[],"length":0,"stats":{"Line":0}},{"line":785,"address":[],"length":0,"stats":{"Line":0}},{"line":786,"address":[],"length":0,"stats":{"Line":0}},{"line":787,"address":[],"length":0,"stats":{"Line":0}},{"line":788,"address":[],"length":0,"stats":{"Line":0}},{"line":790,"address":[],"length":0,"stats":{"Line":0}},{"line":793,"address":[],"length":0,"stats":{"Line":0}},{"line":794,"address":[],"length":0,"stats":{"Line":0}},{"line":797,"address":[],"length":0,"stats":{"Line":0}},{"line":802,"address":[],"length":0,"stats":{"Line":12}},{"line":803,"address":[],"length":0,"stats":{"Line":36}},{"line":804,"address":[],"length":0,"stats":{"Line":64}},{"line":805,"address":[],"length":0,"stats":{"Line":28}},{"line":806,"address":[],"length":0,"stats":{"Line":10}},{"line":807,"address":[],"length":0,"stats":{"Line":8}},{"line":808,"address":[],"length":0,"stats":{"Line":2}},{"line":813,"address":[],"length":0,"stats":{"Line":29}},{"line":814,"address":[],"length":0,"stats":{"Line":6}},{"line":815,"address":[],"length":0,"stats":{"Line":2}},{"line":819,"address":[],"length":0,"stats":{"Line":8}},{"line":824,"address":[],"length":0,"stats":{"Line":0}},{"line":825,"address":[],"length":0,"stats":{"Line":0}},{"line":826,"address":[],"length":0,"stats":{"Line":0}},{"line":827,"address":[],"length":0,"stats":{"Line":0}},{"line":830,"address":[],"length":0,"stats":{"Line":0}},{"line":831,"address":[],"length":0,"stats":{"Line":0}},{"line":834,"address":[],"length":0,"stats":{"Line":0}},{"line":835,"address":[],"length":0,"stats":{"Line":0}},{"line":841,"address":[],"length":0,"stats":{"Line":0}},{"line":842,"address":[],"length":0,"stats":{"Line":0}},{"line":844,"address":[],"length":0,"stats":{"Line":0}},{"line":845,"address":[],"length":0,"stats":{"Line":0}},{"line":847,"address":[],"length":0,"stats":{"Line":0}},{"line":848,"address":[],"length":0,"stats":{"Line":0}},{"line":850,"address":[],"length":0,"stats":{"Line":0}},{"line":851,"address":[],"length":0,"stats":{"Line":0}},{"line":852,"address":[],"length":0,"stats":{"Line":0}},{"line":854,"address":[],"length":0,"stats":{"Line":0}},{"line":855,"address":[],"length":0,"stats":{"Line":0}},{"line":857,"address":[],"length":0,"stats":{"Line":0}},{"line":858,"address":[],"length":0,"stats":{"Line":0}},{"line":859,"address":[],"length":0,"stats":{"Line":0}},{"line":860,"address":[],"length":0,"stats":{"Line":0}},{"line":861,"address":[],"length":0,"stats":{"Line":0}},{"line":863,"address":[],"length":0,"stats":{"Line":0}},{"line":864,"address":[],"length":0,"stats":{"Line":0}},{"line":865,"address":[],"length":0,"stats":{"Line":0}},{"line":871,"address":[],"length":0,"stats":{"Line":0}},{"line":872,"address":[],"length":0,"stats":{"Line":0}},{"line":875,"address":[],"length":0,"stats":{"Line":0}},{"line":879,"address":[],"length":0,"stats":{"Line":11}},{"line":880,"address":[],"length":0,"stats":{"Line":34}},{"line":881,"address":[],"length":0,"stats":{"Line":19}},{"line":882,"address":[],"length":0,"stats":{"Line":28}},{"line":883,"address":[],"length":0,"stats":{"Line":7}},{"line":884,"address":[],"length":0,"stats":{"Line":8}},{"line":885,"address":[],"length":0,"stats":{"Line":8}},{"line":886,"address":[],"length":0,"stats":{"Line":3}},{"line":891,"address":[],"length":0,"stats":{"Line":8}},{"line":896,"address":[],"length":0,"stats":{"Line":0}},{"line":897,"address":[],"length":0,"stats":{"Line":0}},{"line":898,"address":[],"length":0,"stats":{"Line":0}},{"line":901,"address":[],"length":0,"stats":{"Line":0}},{"line":903,"address":[],"length":0,"stats":{"Line":0}},{"line":907,"address":[],"length":0,"stats":{"Line":0}},{"line":908,"address":[],"length":0,"stats":{"Line":0}},{"line":911,"address":[],"length":0,"stats":{"Line":0}},{"line":912,"address":[],"length":0,"stats":{"Line":0}},{"line":915,"address":[],"length":0,"stats":{"Line":27}},{"line":916,"address":[],"length":0,"stats":{"Line":27}},{"line":917,"address":[],"length":0,"stats":{"Line":516}},{"line":918,"address":[],"length":0,"stats":{"Line":1767}},{"line":919,"address":[],"length":0,"stats":{"Line":51}},{"line":921,"address":[],"length":0,"stats":{"Line":822}},{"line":928,"address":[],"length":0,"stats":{"Line":0}},{"line":929,"address":[],"length":0,"stats":{"Line":0}},{"line":932,"address":[],"length":0,"stats":{"Line":0}},{"line":933,"address":[],"length":0,"stats":{"Line":0}},{"line":934,"address":[],"length":0,"stats":{"Line":0}},{"line":935,"address":[],"length":0,"stats":{"Line":0}},{"line":940,"address":[],"length":0,"stats":{"Line":0}},{"line":945,"address":[],"length":0,"stats":{"Line":37}},{"line":946,"address":[],"length":0,"stats":{"Line":111}},{"line":949,"address":[],"length":0,"stats":{"Line":35}},{"line":950,"address":[],"length":0,"stats":{"Line":70}},{"line":952,"address":[],"length":0,"stats":{"Line":105}},{"line":953,"address":[],"length":0,"stats":{"Line":105}},{"line":955,"address":[],"length":0,"stats":{"Line":70}},{"line":956,"address":[],"length":0,"stats":{"Line":76}},{"line":957,"address":[],"length":0,"stats":{"Line":219}},{"line":958,"address":[],"length":0,"stats":{"Line":48}},{"line":962,"address":[],"length":0,"stats":{"Line":70}},{"line":963,"address":[],"length":0,"stats":{"Line":14}},{"line":965,"address":[],"length":0,"stats":{"Line":42}},{"line":972,"address":[],"length":0,"stats":{"Line":15}},{"line":973,"address":[],"length":0,"stats":{"Line":45}},{"line":974,"address":[],"length":0,"stats":{"Line":45}},{"line":975,"address":[],"length":0,"stats":{"Line":60}},{"line":978,"address":[],"length":0,"stats":{"Line":30}},{"line":979,"address":[],"length":0,"stats":{"Line":15}},{"line":981,"address":[],"length":0,"stats":{"Line":60}},{"line":982,"address":[],"length":0,"stats":{"Line":65}},{"line":985,"address":[],"length":0,"stats":{"Line":39}},{"line":986,"address":[],"length":0,"stats":{"Line":52}},{"line":987,"address":[],"length":0,"stats":{"Line":52}},{"line":989,"address":[],"length":0,"stats":{"Line":26}},{"line":990,"address":[],"length":0,"stats":{"Line":52}},{"line":991,"address":[],"length":0,"stats":{"Line":39}},{"line":993,"address":[],"length":0,"stats":{"Line":39}},{"line":995,"address":[],"length":0,"stats":{"Line":34}},{"line":997,"address":[],"length":0,"stats":{"Line":21}},{"line":998,"address":[],"length":0,"stats":{"Line":8}},{"line":1000,"address":[],"length":0,"stats":{"Line":37}},{"line":1001,"address":[],"length":0,"stats":{"Line":24}},{"line":1002,"address":[],"length":0,"stats":{"Line":1}},{"line":1004,"address":[],"length":0,"stats":{"Line":72}},{"line":1005,"address":[],"length":0,"stats":{"Line":1}},{"line":1007,"address":[],"length":0,"stats":{"Line":29}},{"line":1008,"address":[],"length":0,"stats":{"Line":9}},{"line":1013,"address":[],"length":0,"stats":{"Line":47}}],"covered":434,"coverable":515},{"path":["/","Users","cat","hydra","src","main.rs"],"content":"mod app;\nmod event;\nmod logs;\nmod manifest;\nmod session;\nmod tmux;\nmod ui;\n\nuse anyhow::{Context, Result};\nuse clap::{Parser, Subcommand};\nuse crossterm::{\n    event::{DisableMouseCapture, EnableMouseCapture, KeyEventKind, MouseEventKind},\n    execute,\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\n};\nuse ratatui::backend::CrosstermBackend;\nuse ratatui::Terminal;\nuse std::io;\nuse std::time::Duration;\n\nuse app::{App, Mode};\nuse event::{Event, EventHandler};\nuse session::{project_id, AgentType};\n\nconst EVENT_TICK_RATE: Duration = Duration::from_millis(100);\nconst SESSION_REFRESH_INTERVAL_TICKS: u8 = 2;\n\n#[derive(Parser)]\n#[command(name = \"hydra\", about = \"AI Agent tmux session manager\")]\nstruct Cli {\n    #[command(subcommand)]\n    command: Option<Commands>,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    /// Create a new agent session\n    New {\n        /// Agent type (claude, codex)\n        agent: String,\n        /// Session name\n        name: String,\n    },\n    /// Kill a session\n    Kill {\n        /// Session name\n        name: String,\n    },\n    /// List sessions for the current project\n    Ls,\n}\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    let cli = Cli::parse();\n\n    let cwd = std::env::current_dir()\n        .context(\"Failed to get current directory\")?\n        .to_string_lossy()\n        .to_string();\n    let pid = project_id(&cwd);\n\n    match cli.command {\n        Some(Commands::New { agent, name }) => cmd_new(&pid, &name, &agent, &cwd).await,\n        Some(Commands::Kill { name }) => cmd_kill(&pid, &name).await,\n        Some(Commands::Ls) => cmd_ls(&pid).await,\n        None => run_tui(pid, cwd).await,\n    }\n}\n\nasync fn cmd_new(project_id: &str, name: &str, agent_str: &str, cwd: &str) -> Result<()> {\n    let agent: AgentType = agent_str.parse()?;\n    let record = manifest::SessionRecord::for_new_session(name, &agent, cwd);\n    let cmd = record.create_command();\n    let base_dir = manifest::default_base_dir();\n\n    let tmux_name = tmux::create_session(project_id, name, &agent, cwd, Some(&cmd)).await?;\n    manifest::add_session(&base_dir, project_id, record).await?;\n    println!(\"Created session: {tmux_name}\");\n    Ok(())\n}\n\nasync fn cmd_kill(project_id: &str, name: &str) -> Result<()> {\n    let tmux_name = session::tmux_session_name(project_id, name);\n    tmux::kill_session(&tmux_name).await?;\n    let base_dir = manifest::default_base_dir();\n    let _ = manifest::remove_session(&base_dir, project_id, name).await;\n    println!(\"Killed session: {tmux_name}\");\n    Ok(())\n}\n\nasync fn cmd_ls(project_id: &str) -> Result<()> {\n    let manager = tmux::TmuxSessionManager::new();\n    let sessions = tmux::SessionManager::list_sessions(&manager, project_id).await?;\n    if sessions.is_empty() {\n        println!(\"No sessions for this project.\");\n    } else {\n        for s in &sessions {\n            println!(\"{} [{}]\", s.name, s.agent_type);\n        }\n    }\n    Ok(())\n}\n\nasync fn run_tui(project_id: String, cwd: String) -> Result<()> {\n    // Setup terminal\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen, EnableMouseCapture)?;\n    let backend = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backend)?;\n\n    let mut app = App::new(project_id, cwd);\n    app.revive_sessions().await;\n    app.refresh_sessions().await;\n    app.refresh_preview().await;\n\n    let mut events = EventHandler::new(EVENT_TICK_RATE);\n    let mut prev_mouse_captured = true;\n    let mut session_refresh_tick = 0u8;\n\n    // Draw initial frame before entering event loop\n    terminal.draw(|frame| ui::draw(frame, &app))?;\n\n    // Main loop: process events first, then draw — eliminates 0-250ms\n    // input→display latency from the old draw-then-wait pattern.\n    loop {\n        if app.should_quit {\n            break;\n        }\n\n        match events.next().await {\n            Some(Event::Key(key)) => {\n                if key.kind == KeyEventKind::Press {\n                    let was_attached = app.mode == Mode::Attached;\n                    app.handle_key(key).await;\n                    // In Attached mode, avoid one tmux preview capture per keypress.\n                    // Tick refreshes keep the preview live without input lag.\n                    if !was_attached {\n                        app.refresh_preview().await;\n                    }\n                }\n            }\n            Some(Event::Mouse(mouse)) => {\n                let should_refresh_preview = !matches!(mouse.kind, MouseEventKind::Moved);\n                app.handle_mouse(mouse);\n                app.flush_pending_keys().await;\n                if should_refresh_preview {\n                    app.refresh_preview().await;\n                }\n            }\n            Some(Event::Tick) => {\n                session_refresh_tick = session_refresh_tick.wrapping_add(1);\n                if session_refresh_tick % SESSION_REFRESH_INTERVAL_TICKS == 0 {\n                    app.refresh_sessions().await;\n                    app.refresh_preview().await;\n                }\n                app.refresh_messages();\n            }\n            Some(Event::Resize) => {}\n            None => break,\n        }\n\n        // Toggle mouse capture when the flag changes\n        if app.mouse_captured != prev_mouse_captured {\n            if app.mouse_captured {\n                execute!(terminal.backend_mut(), EnableMouseCapture)?;\n            } else {\n                execute!(terminal.backend_mut(), DisableMouseCapture)?;\n            }\n            prev_mouse_captured = app.mouse_captured;\n        }\n\n        // Draw after event handling — user sees result immediately\n        terminal.draw(|frame| ui::draw(frame, &app))?;\n    }\n\n    // Restore terminal\n    disable_raw_mode()?;\n    execute!(\n        terminal.backend_mut(),\n        LeaveAlternateScreen,\n        DisableMouseCapture\n    )?;\n    terminal.show_cursor()?;\n\n    Ok(())\n}\n","traces":[{"line":54,"address":[],"length":0,"stats":{"Line":12}},{"line":55,"address":[],"length":0,"stats":{"Line":12}},{"line":57,"address":[],"length":0,"stats":{"Line":12}},{"line":61,"address":[],"length":0,"stats":{"Line":18}},{"line":63,"address":[],"length":0,"stats":{"Line":8}},{"line":64,"address":[],"length":0,"stats":{"Line":13}},{"line":65,"address":[],"length":0,"stats":{"Line":6}},{"line":66,"address":[],"length":0,"stats":{"Line":8}},{"line":67,"address":[],"length":0,"stats":{"Line":18}},{"line":71,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":3}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":2}},{"line":93,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":4}},{"line":95,"address":[],"length":0,"stats":{"Line":2}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":13}},{"line":99,"address":[],"length":0,"stats":{"Line":6}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}}],"covered":18,"coverable":80},{"path":["/","Users","cat","hydra","src","manifest.rs"],"content":"use anyhow::Result;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::path::{Path, PathBuf};\n\nuse crate::session::AgentType;\n\n/// Maximum failed revival attempts before pruning a manifest entry.\npub const MAX_FAILED_ATTEMPTS: u32 = 3;\n\n#[derive(Serialize, Deserialize, Clone, Debug)]\npub struct SessionRecord {\n    pub name: String,\n    pub agent_type: String,\n    pub agent_session_id: Option<String>,\n    pub cwd: String,\n    #[serde(default)]\n    pub failed_attempts: u32,\n}\n\n#[derive(Serialize, Deserialize, Default, Debug)]\npub struct Manifest {\n    pub sessions: HashMap<String, SessionRecord>,\n}\n\n/// Default base directory for manifests: `~/.hydra/`\npub fn default_base_dir() -> PathBuf {\n    dirs::home_dir()\n        .unwrap_or_else(|| PathBuf::from(\".\"))\n        .join(\".hydra\")\n}\n\n/// Return the manifest file path: `<base_dir>/<project_id>/sessions.json`\npub fn manifest_path(base_dir: &Path, project_id: &str) -> PathBuf {\n    base_dir.join(project_id).join(\"sessions.json\")\n}\n\n/// Load manifest from disk. Returns empty Manifest on missing or corrupt file.\npub async fn load_manifest(base_dir: &Path, project_id: &str) -> Manifest {\n    let path = manifest_path(base_dir, project_id);\n    match tokio::fs::read_to_string(&path).await {\n        Ok(contents) => serde_json::from_str(&contents).unwrap_or_default(),\n        Err(_) => Manifest::default(),\n    }\n}\n\n/// Save manifest to disk, creating directories as needed.\n/// Uses write-to-temp-then-rename for atomic writes on POSIX,\n/// preventing corruption from crashes or concurrent instances.\npub async fn save_manifest(base_dir: &Path, project_id: &str, manifest: &Manifest) -> Result<()> {\n    let path = manifest_path(base_dir, project_id);\n    if let Some(parent) = path.parent() {\n        tokio::fs::create_dir_all(parent).await?;\n    }\n    let json = serde_json::to_string_pretty(manifest)?;\n    // Use a unique temp filename to avoid collisions between concurrent writes\n    use std::sync::atomic::{AtomicU64, Ordering};\n    static COUNTER: AtomicU64 = AtomicU64::new(0);\n    let tmp_name = format!(\n        \"sessions.{}.{}.tmp\",\n        std::process::id(),\n        COUNTER.fetch_add(1, Ordering::Relaxed),\n    );\n    let tmp_path = path.with_file_name(tmp_name);\n    tokio::fs::write(&tmp_path, json).await?;\n    tokio::fs::rename(&tmp_path, &path).await?;\n    Ok(())\n}\n\n/// Add a session record to the manifest (load-modify-save).\npub async fn add_session(base_dir: &Path, project_id: &str, record: SessionRecord) -> Result<()> {\n    let mut manifest = load_manifest(base_dir, project_id).await;\n    manifest.sessions.insert(record.name.clone(), record);\n    save_manifest(base_dir, project_id, &manifest).await\n}\n\n/// Remove a session record from the manifest by name (load-modify-save).\npub async fn remove_session(base_dir: &Path, project_id: &str, name: &str) -> Result<()> {\n    let mut manifest = load_manifest(base_dir, project_id).await;\n    manifest.sessions.remove(name);\n    save_manifest(base_dir, project_id, &manifest).await\n}\n\nimpl SessionRecord {\n    /// Create a new SessionRecord for a fresh session, generating a UUID for Claude.\n    pub fn for_new_session(name: &str, agent: &AgentType, cwd: &str) -> Self {\n        let agent_session_id = if *agent == AgentType::Claude {\n            Some(uuid::Uuid::new_v4().to_string())\n        } else {\n            None\n        };\n        Self {\n            name: name.to_string(),\n            agent_type: agent.to_string().to_lowercase(),\n            agent_session_id,\n            cwd: cwd.to_string(),\n            failed_attempts: 0,\n        }\n    }\n\n    /// Build the command string to resume this agent session.\n    pub fn resume_command(&self) -> String {\n        match self.agent_type.as_str() {\n            \"claude\" => {\n                if let Some(ref uuid) = self.agent_session_id {\n                    format!(\"claude --dangerously-skip-permissions --resume {uuid}\")\n                } else {\n                    \"claude --dangerously-skip-permissions\".to_string()\n                }\n            }\n            \"codex\" => {\n                \"codex -c check_for_update_on_startup=false --yolo resume --last\".to_string()\n            }\n            _ => self.agent_type.clone(),\n        }\n    }\n\n    /// Build the command string for initial session creation.\n    /// For Claude, includes `--session-id` so we can resume later.\n    pub fn create_command(&self) -> String {\n        match self.agent_type.as_str() {\n            \"claude\" => {\n                if let Some(ref uuid) = self.agent_session_id {\n                    format!(\"claude --dangerously-skip-permissions --session-id {uuid}\")\n                } else {\n                    \"claude --dangerously-skip-permissions\".to_string()\n                }\n            }\n            \"codex\" => \"codex -c check_for_update_on_startup=false --yolo\".to_string(),\n            _ => self.agent_type.clone(),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn resume_command_claude_with_uuid() {\n        let record = SessionRecord {\n            name: \"alpha\".to_string(),\n            agent_type: \"claude\".to_string(),\n            agent_session_id: Some(\"abc-123\".to_string()),\n            cwd: \"/tmp/test\".to_string(),\n            failed_attempts: 0,\n        };\n        assert_eq!(\n            record.resume_command(),\n            \"claude --dangerously-skip-permissions --resume abc-123\"\n        );\n    }\n\n    #[test]\n    fn resume_command_claude_without_uuid() {\n        let record = SessionRecord {\n            name: \"alpha\".to_string(),\n            agent_type: \"claude\".to_string(),\n            agent_session_id: None,\n            cwd: \"/tmp/test\".to_string(),\n            failed_attempts: 0,\n        };\n        assert_eq!(\n            record.resume_command(),\n            \"claude --dangerously-skip-permissions\"\n        );\n    }\n\n    #[test]\n    fn resume_command_codex() {\n        let record = SessionRecord {\n            name: \"bravo\".to_string(),\n            agent_type: \"codex\".to_string(),\n            agent_session_id: None,\n            cwd: \"/tmp/test\".to_string(),\n            failed_attempts: 0,\n        };\n        assert_eq!(\n            record.resume_command(),\n            \"codex -c check_for_update_on_startup=false --yolo resume --last\"\n        );\n    }\n\n    #[test]\n    fn create_command_claude_with_uuid() {\n        let record = SessionRecord {\n            name: \"alpha\".to_string(),\n            agent_type: \"claude\".to_string(),\n            agent_session_id: Some(\"abc-123\".to_string()),\n            cwd: \"/tmp/test\".to_string(),\n            failed_attempts: 0,\n        };\n        assert_eq!(\n            record.create_command(),\n            \"claude --dangerously-skip-permissions --session-id abc-123\"\n        );\n    }\n\n    #[test]\n    fn create_command_claude_without_uuid() {\n        let record = SessionRecord {\n            name: \"alpha\".to_string(),\n            agent_type: \"claude\".to_string(),\n            agent_session_id: None,\n            cwd: \"/tmp/test\".to_string(),\n            failed_attempts: 0,\n        };\n        assert_eq!(\n            record.create_command(),\n            \"claude --dangerously-skip-permissions\"\n        );\n    }\n\n    #[test]\n    fn create_command_codex() {\n        let record = SessionRecord {\n            name: \"bravo\".to_string(),\n            agent_type: \"codex\".to_string(),\n            agent_session_id: None,\n            cwd: \"/tmp/test\".to_string(),\n            failed_attempts: 0,\n        };\n        assert_eq!(\n            record.create_command(),\n            \"codex -c check_for_update_on_startup=false --yolo\"\n        );\n    }\n\n    #[test]\n    fn resume_command_custom_agent_returns_agent_type() {\n        let record = SessionRecord {\n            name: \"s1\".to_string(),\n            agent_type: \"aider\".to_string(),\n            agent_session_id: None,\n            cwd: \"/tmp\".to_string(),\n            failed_attempts: 0,\n        };\n        assert_eq!(record.resume_command(), \"aider\");\n    }\n\n    #[test]\n    fn create_command_custom_agent_returns_agent_type() {\n        let record = SessionRecord {\n            name: \"s1\".to_string(),\n            agent_type: \"aider\".to_string(),\n            agent_session_id: None,\n            cwd: \"/tmp\".to_string(),\n            failed_attempts: 0,\n        };\n        assert_eq!(record.create_command(), \"aider\");\n    }\n\n    #[tokio::test]\n    async fn roundtrip_manifest() {\n        let dir = tempfile::tempdir().unwrap();\n        let base = dir.path();\n        let pid = \"test1234\";\n\n        let mut manifest = Manifest::default();\n        manifest.sessions.insert(\n            \"alpha\".to_string(),\n            SessionRecord {\n                name: \"alpha\".to_string(),\n                agent_type: \"claude\".to_string(),\n                agent_session_id: Some(\"uuid-1\".to_string()),\n                cwd: \"/tmp/test\".to_string(),\n                failed_attempts: 0,\n            },\n        );\n        manifest.sessions.insert(\n            \"bravo\".to_string(),\n            SessionRecord {\n                name: \"bravo\".to_string(),\n                agent_type: \"codex\".to_string(),\n                agent_session_id: None,\n                cwd: \"/tmp/test\".to_string(),\n                failed_attempts: 0,\n            },\n        );\n\n        save_manifest(base, pid, &manifest).await.unwrap();\n        let loaded = load_manifest(base, pid).await;\n\n        assert_eq!(loaded.sessions.len(), 2);\n        assert!(loaded.sessions.contains_key(\"alpha\"));\n        assert!(loaded.sessions.contains_key(\"bravo\"));\n        assert_eq!(\n            loaded.sessions[\"alpha\"].agent_session_id,\n            Some(\"uuid-1\".to_string())\n        );\n        assert_eq!(loaded.sessions[\"bravo\"].agent_session_id, None);\n    }\n\n    #[tokio::test]\n    async fn load_manifest_missing_file_returns_empty() {\n        let dir = tempfile::tempdir().unwrap();\n        let manifest = load_manifest(dir.path(), \"nonexistent\").await;\n        assert!(manifest.sessions.is_empty());\n    }\n\n    #[tokio::test]\n    async fn corrupt_json_returns_empty_manifest() {\n        let dir = tempfile::tempdir().unwrap();\n        let base = dir.path();\n        let pid = \"corrupt_test\";\n        let path = manifest_path(base, pid);\n        tokio::fs::create_dir_all(path.parent().unwrap())\n            .await\n            .unwrap();\n        tokio::fs::write(&path, \"not valid json {{{\").await.unwrap();\n\n        let manifest = load_manifest(base, pid).await;\n        assert!(manifest.sessions.is_empty());\n    }\n\n    #[tokio::test]\n    async fn add_and_remove_session() {\n        let dir = tempfile::tempdir().unwrap();\n        let base = dir.path();\n        let pid = \"test_add_remove\";\n\n        let record = SessionRecord {\n            name: \"alpha\".to_string(),\n            agent_type: \"claude\".to_string(),\n            agent_session_id: Some(\"uuid-1\".to_string()),\n            cwd: \"/tmp/test\".to_string(),\n            failed_attempts: 0,\n        };\n        add_session(base, pid, record).await.unwrap();\n\n        let manifest = load_manifest(base, pid).await;\n        assert_eq!(manifest.sessions.len(), 1);\n        assert!(manifest.sessions.contains_key(\"alpha\"));\n\n        remove_session(base, pid, \"alpha\").await.unwrap();\n        let manifest = load_manifest(base, pid).await;\n        assert!(manifest.sessions.is_empty());\n    }\n\n    #[test]\n    fn manifest_path_contains_project_id() {\n        let base = Path::new(\"/home/user/.hydra\");\n        let path = manifest_path(base, \"abcd1234\");\n        let path_str = path.to_string_lossy();\n        assert!(path_str.contains(\"abcd1234\"));\n        assert!(path_str.ends_with(\"sessions.json\"));\n    }\n\n    #[test]\n    fn for_new_session_claude_has_uuid() {\n        let record = SessionRecord::for_new_session(\"alpha\", &AgentType::Claude, \"/tmp\");\n        assert_eq!(record.agent_type, \"claude\");\n        assert!(record.agent_session_id.is_some());\n        assert_eq!(record.failed_attempts, 0);\n    }\n\n    #[test]\n    fn for_new_session_codex_no_uuid() {\n        let record = SessionRecord::for_new_session(\"bravo\", &AgentType::Codex, \"/tmp\");\n        assert_eq!(record.agent_type, \"codex\");\n        assert!(record.agent_session_id.is_none());\n    }\n\n    #[test]\n    fn failed_attempts_defaults_to_zero_on_deserialize() {\n        let json = r#\"{\"name\":\"a\",\"agent_type\":\"claude\",\"agent_session_id\":null,\"cwd\":\"/tmp\"}\"#;\n        let record: SessionRecord = serde_json::from_str(json).unwrap();\n        assert_eq!(record.failed_attempts, 0);\n    }\n\n    #[test]\n    fn default_base_dir_contains_hydra() {\n        let dir = default_base_dir();\n        assert!(\n            dir.to_string_lossy().ends_with(\".hydra\"),\n            \"default_base_dir should end with .hydra, got: {}\",\n            dir.display()\n        );\n    }\n\n    #[tokio::test]\n    async fn atomic_write_no_temp_file_left_behind() {\n        let dir = tempfile::tempdir().unwrap();\n        let base = dir.path();\n        let pid = \"atomic_test\";\n\n        let mut manifest = Manifest::default();\n        manifest.sessions.insert(\n            \"alpha\".to_string(),\n            SessionRecord {\n                name: \"alpha\".to_string(),\n                agent_type: \"claude\".to_string(),\n                agent_session_id: None,\n                cwd: \"/tmp\".to_string(),\n                failed_attempts: 0,\n            },\n        );\n\n        save_manifest(base, pid, &manifest).await.unwrap();\n\n        // The final file should exist and be valid JSON\n        let path = manifest_path(base, pid);\n        let contents = tokio::fs::read_to_string(&path).await.unwrap();\n        let loaded: Manifest = serde_json::from_str(&contents).unwrap();\n        assert_eq!(loaded.sessions.len(), 1);\n\n        // The temp file should not exist after a successful write\n        let tmp_path = path.with_extension(\"json.tmp\");\n        assert!(\n            !tmp_path.exists(),\n            \"temp file should be renamed away, not left behind\"\n        );\n    }\n\n    #[tokio::test]\n    async fn concurrent_saves_dont_corrupt() {\n        let dir = tempfile::tempdir().unwrap();\n        let base = dir.path().to_path_buf();\n        let pid = \"concurrent_test\";\n\n        // Pre-create the directory to avoid concurrent create_dir_all races\n        let manifest_dir = base.join(pid);\n        tokio::fs::create_dir_all(&manifest_dir).await.unwrap();\n\n        // Run several saves concurrently\n        let mut handles = Vec::new();\n        for i in 0..10 {\n            let base = base.clone();\n            let pid = pid.to_string();\n            handles.push(tokio::spawn(async move {\n                let mut manifest = Manifest::default();\n                manifest.sessions.insert(\n                    format!(\"session-{i}\"),\n                    SessionRecord {\n                        name: format!(\"session-{i}\"),\n                        agent_type: \"claude\".to_string(),\n                        agent_session_id: None,\n                        cwd: \"/tmp\".to_string(),\n                        failed_attempts: 0,\n                    },\n                );\n                save_manifest(&base, &pid, &manifest).await.unwrap();\n            }));\n        }\n        for h in handles {\n            h.await.unwrap();\n        }\n\n        // The file should contain valid JSON (one of the concurrent writes wins)\n        let path = manifest_path(&base, pid);\n        let contents = tokio::fs::read_to_string(&path).await.unwrap();\n        let loaded: Manifest = serde_json::from_str(&contents).unwrap();\n        assert!(\n            !loaded.sessions.is_empty(),\n            \"manifest should contain at least one session from concurrent writes\"\n        );\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":169}},{"line":28,"address":[],"length":0,"stats":{"Line":169}},{"line":29,"address":[],"length":0,"stats":{"Line":169}},{"line":34,"address":[],"length":0,"stats":{"Line":69}},{"line":35,"address":[],"length":0,"stats":{"Line":138}},{"line":39,"address":[],"length":0,"stats":{"Line":58}},{"line":40,"address":[],"length":0,"stats":{"Line":116}},{"line":41,"address":[],"length":0,"stats":{"Line":87}},{"line":42,"address":[],"length":0,"stats":{"Line":92}},{"line":43,"address":[],"length":0,"stats":{"Line":6}},{"line":50,"address":[],"length":0,"stats":{"Line":72}},{"line":51,"address":[],"length":0,"stats":{"Line":144}},{"line":52,"address":[],"length":0,"stats":{"Line":72}},{"line":53,"address":[],"length":0,"stats":{"Line":74}},{"line":55,"address":[],"length":0,"stats":{"Line":102}},{"line":59,"address":[],"length":0,"stats":{"Line":68}},{"line":61,"address":[],"length":0,"stats":{"Line":34}},{"line":62,"address":[],"length":0,"stats":{"Line":102}},{"line":64,"address":[],"length":0,"stats":{"Line":102}},{"line":65,"address":[],"length":0,"stats":{"Line":102}},{"line":66,"address":[],"length":0,"stats":{"Line":102}},{"line":67,"address":[],"length":0,"stats":{"Line":34}},{"line":71,"address":[],"length":0,"stats":{"Line":16}},{"line":72,"address":[],"length":0,"stats":{"Line":32}},{"line":73,"address":[],"length":0,"stats":{"Line":40}},{"line":74,"address":[],"length":0,"stats":{"Line":32}},{"line":78,"address":[],"length":0,"stats":{"Line":10}},{"line":79,"address":[],"length":0,"stats":{"Line":20}},{"line":80,"address":[],"length":0,"stats":{"Line":15}},{"line":81,"address":[],"length":0,"stats":{"Line":20}},{"line":86,"address":[],"length":0,"stats":{"Line":10}},{"line":87,"address":[],"length":0,"stats":{"Line":20}},{"line":88,"address":[],"length":0,"stats":{"Line":8}},{"line":90,"address":[],"length":0,"stats":{"Line":2}},{"line":93,"address":[],"length":0,"stats":{"Line":30}},{"line":94,"address":[],"length":0,"stats":{"Line":20}},{"line":96,"address":[],"length":0,"stats":{"Line":10}},{"line":102,"address":[],"length":0,"stats":{"Line":7}},{"line":103,"address":[],"length":0,"stats":{"Line":7}},{"line":104,"address":[],"length":0,"stats":{"Line":7}},{"line":105,"address":[],"length":0,"stats":{"Line":9}},{"line":106,"address":[],"length":0,"stats":{"Line":4}},{"line":108,"address":[],"length":0,"stats":{"Line":2}},{"line":111,"address":[],"length":0,"stats":{"Line":2}},{"line":112,"address":[],"length":0,"stats":{"Line":2}},{"line":114,"address":[],"length":0,"stats":{"Line":2}},{"line":120,"address":[],"length":0,"stats":{"Line":12}},{"line":121,"address":[],"length":0,"stats":{"Line":12}},{"line":122,"address":[],"length":0,"stats":{"Line":12}},{"line":123,"address":[],"length":0,"stats":{"Line":17}},{"line":124,"address":[],"length":0,"stats":{"Line":8}},{"line":126,"address":[],"length":0,"stats":{"Line":2}},{"line":129,"address":[],"length":0,"stats":{"Line":7}},{"line":130,"address":[],"length":0,"stats":{"Line":2}}],"covered":54,"coverable":54},{"path":["/","Users","cat","hydra","src","session.rs"],"content":"use sha2::{Digest, Sha256};\nuse std::fmt;\nuse std::time::Duration;\n\n#[derive(Debug, Clone, PartialEq)]\npub enum AgentType {\n    Claude,\n    Codex,\n}\n\nimpl AgentType {\n    pub fn command(&self) -> &str {\n        match self {\n            AgentType::Claude => \"claude --dangerously-skip-permissions\",\n            AgentType::Codex => \"codex -c check_for_update_on_startup=false --yolo\",\n        }\n    }\n\n    pub fn all() -> &'static [AgentType] {\n        &[AgentType::Claude, AgentType::Codex]\n    }\n}\n\nimpl fmt::Display for AgentType {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            AgentType::Claude => write!(f, \"Claude\"),\n            AgentType::Codex => write!(f, \"Codex\"),\n        }\n    }\n}\n\nimpl std::str::FromStr for AgentType {\n    type Err = anyhow::Error;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        match s.to_lowercase().as_str() {\n            \"claude\" => Ok(AgentType::Claude),\n            \"codex\" => Ok(AgentType::Codex),\n            _ => Err(anyhow::anyhow!(\n                \"Unknown agent type: {s}. Use 'claude' or 'codex'.\"\n            )),\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum SessionStatus {\n    Running,\n    Idle,\n    Exited,\n}\n\nimpl SessionStatus {\n    /// Sort priority: Idle (needs input) first, then Running, then Exited.\n    pub fn sort_order(&self) -> u8 {\n        match self {\n            SessionStatus::Idle => 0,\n            SessionStatus::Running => 1,\n            SessionStatus::Exited => 2,\n        }\n    }\n}\n\nimpl fmt::Display for SessionStatus {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            SessionStatus::Running => write!(f, \"Running\"),\n            SessionStatus::Idle => write!(f, \"Idle\"),\n            SessionStatus::Exited => write!(f, \"Exited\"),\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct Session {\n    pub name: String,\n    pub tmux_name: String,\n    pub agent_type: AgentType,\n    pub status: SessionStatus,\n    pub task_elapsed: Option<Duration>,\n    pub _alive: bool,\n}\n\npub fn format_duration(d: Duration) -> String {\n    let secs = d.as_secs();\n    if secs < 60 {\n        format!(\"{secs}s\")\n    } else if secs < 3600 {\n        format!(\"{}m {:02}s\", secs / 60, secs % 60)\n    } else {\n        format!(\"{}h {:02}m\", secs / 3600, (secs % 3600) / 60)\n    }\n}\n\n/// Generate an 8-char hex hash from the absolute CWD path.\npub fn project_id(cwd: &str) -> String {\n    let mut hasher = Sha256::new();\n    hasher.update(cwd.as_bytes());\n    let result = hasher.finalize();\n    hex::encode(&result[..4])\n}\n\n/// Build the tmux session name: `hydra-<hash>-<name>`\npub fn tmux_session_name(project_id: &str, name: &str) -> String {\n    format!(\"hydra-{project_id}-{name}\")\n}\n\n/// Extract the user-facing session name from a tmux session name.\npub fn parse_session_name(tmux_name: &str, project_id: &str) -> Option<String> {\n    let prefix = format!(\"hydra-{project_id}-\");\n    tmux_name.strip_prefix(&prefix).map(|s| s.to_string())\n}\n\nconst AUTO_NAMES: &[&str] = &[\n    \"alpha\", \"bravo\", \"charlie\", \"delta\", \"echo\", \"foxtrot\", \"golf\", \"hotel\", \"india\", \"juliet\",\n    \"kilo\", \"lima\", \"mike\", \"november\", \"oscar\", \"papa\", \"quebec\", \"romeo\", \"sierra\", \"tango\",\n    \"uniform\", \"victor\", \"whiskey\", \"xray\", \"yankee\", \"zulu\",\n];\n\n/// Generate the next available session name from the NATO phonetic alphabet.\npub fn generate_name(existing: &[String]) -> String {\n    for name in AUTO_NAMES {\n        if !existing.iter().any(|n| n == name) {\n            return name.to_string();\n        }\n    }\n    let mut i = AUTO_NAMES.len() + 1;\n    loop {\n        let name = format!(\"agent-{i}\");\n        if !existing.iter().any(|n| *n == name) {\n            return name;\n        }\n        i += 1;\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::str::FromStr;\n\n    // ── project_id tests ──────────────────────────────────────────────\n\n    #[test]\n    fn project_id_is_deterministic() {\n        let id1 = project_id(\"/home/user/project\");\n        let id2 = project_id(\"/home/user/project\");\n        assert_eq!(id1, id2);\n    }\n\n    #[test]\n    fn project_id_different_inputs_produce_different_ids() {\n        let id1 = project_id(\"/home/user/project-a\");\n        let id2 = project_id(\"/home/user/project-b\");\n        assert_ne!(id1, id2);\n    }\n\n    #[test]\n    fn project_id_is_8_char_hex() {\n        let id = project_id(\"/some/path\");\n        assert_eq!(id.len(), 8);\n        assert!(\n            id.chars().all(|c| c.is_ascii_hexdigit()),\n            \"project_id should only contain hex characters, got: {id}\"\n        );\n    }\n\n    #[test]\n    fn project_id_empty_string_input() {\n        let id = project_id(\"\");\n        assert_eq!(id.len(), 8);\n        assert!(id.chars().all(|c| c.is_ascii_hexdigit()));\n    }\n\n    // ── tmux_session_name tests ───────────────────────────────────────\n\n    #[test]\n    fn tmux_session_name_correct_format() {\n        let name = tmux_session_name(\"abcd1234\", \"my-session\");\n        assert_eq!(name, \"hydra-abcd1234-my-session\");\n    }\n\n    #[test]\n    fn tmux_session_name_with_empty_name() {\n        let name = tmux_session_name(\"abcd1234\", \"\");\n        assert_eq!(name, \"hydra-abcd1234-\");\n    }\n\n    // ── parse_session_name tests ──────────────────────────────────────\n\n    #[test]\n    fn parse_session_name_roundtrip() {\n        let pid = project_id(\"/home/user/my-project\");\n        let session = \"worker-1\";\n        let tmux = tmux_session_name(&pid, session);\n        let parsed = parse_session_name(&tmux, &pid);\n        assert_eq!(parsed, Some(session.to_string()));\n    }\n\n    #[test]\n    fn parse_session_name_wrong_prefix_returns_none() {\n        let result = parse_session_name(\"other-prefix-session\", \"abcd1234\");\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn parse_session_name_wrong_project_id_returns_none() {\n        let tmux = tmux_session_name(\"aaaaaaaa\", \"session\");\n        let result = parse_session_name(&tmux, \"bbbbbbbb\");\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn parse_session_name_exact_prefix_no_name() {\n        let tmux = \"hydra-abcd1234-\";\n        let result = parse_session_name(tmux, \"abcd1234\");\n        assert_eq!(result, Some(String::new()));\n    }\n\n    // ── AgentType::command tests ──────────────────────────────────────\n\n    #[test]\n    fn agent_type_command_claude() {\n        assert_eq!(\n            AgentType::Claude.command(),\n            \"claude --dangerously-skip-permissions\"\n        );\n    }\n\n    #[test]\n    fn agent_type_command_codex() {\n        assert_eq!(\n            AgentType::Codex.command(),\n            \"codex -c check_for_update_on_startup=false --yolo\"\n        );\n    }\n\n    // ── AgentType::all tests ──────────────────────────────────────────\n\n    #[test]\n    fn agent_type_all_returns_both_variants() {\n        let all = AgentType::all();\n        assert_eq!(all.len(), 2);\n        assert_eq!(all[0], AgentType::Claude);\n        assert_eq!(all[1], AgentType::Codex);\n    }\n\n    // ── AgentType Display tests ───────────────────────────────────────\n\n    #[test]\n    fn agent_type_display_claude() {\n        assert_eq!(format!(\"{}\", AgentType::Claude), \"Claude\");\n    }\n\n    #[test]\n    fn agent_type_display_codex() {\n        assert_eq!(format!(\"{}\", AgentType::Codex), \"Codex\");\n    }\n\n    // ── AgentType FromStr tests ───────────────────────────────────────\n\n    #[test]\n    fn agent_type_from_str_claude_lowercase() {\n        let agent = AgentType::from_str(\"claude\").unwrap();\n        assert_eq!(agent, AgentType::Claude);\n    }\n\n    #[test]\n    fn agent_type_from_str_codex_lowercase() {\n        let agent = AgentType::from_str(\"codex\").unwrap();\n        assert_eq!(agent, AgentType::Codex);\n    }\n\n    #[test]\n    fn agent_type_from_str_case_insensitive_uppercase() {\n        let agent = AgentType::from_str(\"CLAUDE\").unwrap();\n        assert_eq!(agent, AgentType::Claude);\n    }\n\n    #[test]\n    fn agent_type_from_str_case_insensitive_mixed() {\n        let agent = AgentType::from_str(\"Codex\").unwrap();\n        assert_eq!(agent, AgentType::Codex);\n    }\n\n    #[test]\n    fn agent_type_from_str_invalid_returns_error() {\n        let result = AgentType::from_str(\"gpt\");\n        assert!(result.is_err());\n        let err_msg = result.unwrap_err().to_string();\n        assert!(\n            err_msg.contains(\"Unknown agent type\"),\n            \"Error message should mention 'Unknown agent type', got: {err_msg}\"\n        );\n    }\n\n    #[test]\n    fn agent_type_from_str_empty_returns_error() {\n        let result = AgentType::from_str(\"\");\n        assert!(result.is_err());\n    }\n\n    // ── generate_name tests ──────────────────────────────────────────\n\n    #[test]\n    fn generate_name_first_is_alpha() {\n        let name = generate_name(&[]);\n        assert_eq!(name, \"alpha\");\n    }\n\n    #[test]\n    fn generate_name_skips_existing() {\n        let existing = vec![\"alpha\".to_string(), \"bravo\".to_string()];\n        let name = generate_name(&existing);\n        assert_eq!(name, \"charlie\");\n    }\n\n    #[test]\n    fn generate_name_fills_gaps() {\n        let existing = vec![\"alpha\".to_string(), \"charlie\".to_string()];\n        let name = generate_name(&existing);\n        assert_eq!(name, \"bravo\");\n    }\n\n    #[test]\n    fn generate_name_fallback_when_all_taken() {\n        let all_taken: Vec<String> = AUTO_NAMES.iter().map(|s| s.to_string()).collect();\n        let name = generate_name(&all_taken);\n        assert_eq!(name, \"agent-27\");\n    }\n\n    #[test]\n    fn generate_name_fallback_skips_existing() {\n        let mut names: Vec<String> = AUTO_NAMES.iter().map(|s| s.to_string()).collect();\n        names.push(\"agent-27\".to_string());\n        let name = generate_name(&names);\n        assert_eq!(name, \"agent-28\");\n    }\n\n    // ── format_duration tests ────────────────────────────────────────\n\n    #[test]\n    fn format_duration_seconds_only() {\n        assert_eq!(format_duration(Duration::from_secs(0)), \"0s\");\n        assert_eq!(format_duration(Duration::from_secs(1)), \"1s\");\n        assert_eq!(format_duration(Duration::from_secs(59)), \"59s\");\n    }\n\n    #[test]\n    fn format_duration_minutes_and_seconds() {\n        assert_eq!(format_duration(Duration::from_secs(60)), \"1m 00s\");\n        assert_eq!(format_duration(Duration::from_secs(90)), \"1m 30s\");\n        assert_eq!(format_duration(Duration::from_secs(3599)), \"59m 59s\");\n    }\n\n    #[test]\n    fn format_duration_hours_and_minutes() {\n        assert_eq!(format_duration(Duration::from_secs(3600)), \"1h 00m\");\n        assert_eq!(format_duration(Duration::from_secs(3661)), \"1h 01m\");\n        assert_eq!(format_duration(Duration::from_secs(7200)), \"2h 00m\");\n    }\n\n    #[test]\n    fn format_duration_ignores_subsecond() {\n        assert_eq!(format_duration(Duration::from_millis(999)), \"0s\");\n        assert_eq!(format_duration(Duration::from_millis(1500)), \"1s\");\n    }\n\n    // ── SessionStatus::sort_order tests ─────────────────────────────\n\n    #[test]\n    fn sort_order_idle_is_lowest() {\n        assert_eq!(SessionStatus::Idle.sort_order(), 0);\n    }\n\n    #[test]\n    fn sort_order_running_is_middle() {\n        assert_eq!(SessionStatus::Running.sort_order(), 1);\n    }\n\n    #[test]\n    fn sort_order_exited_is_highest() {\n        assert_eq!(SessionStatus::Exited.sort_order(), 2);\n    }\n\n    #[test]\n    fn sort_order_produces_correct_ordering() {\n        let mut statuses = vec![\n            SessionStatus::Exited,\n            SessionStatus::Running,\n            SessionStatus::Idle,\n        ];\n        statuses.sort_by_key(|s| s.sort_order());\n        assert_eq!(\n            statuses,\n            vec![\n                SessionStatus::Idle,\n                SessionStatus::Running,\n                SessionStatus::Exited,\n            ]\n        );\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":2}},{"line":13,"address":[],"length":0,"stats":{"Line":2}},{"line":14,"address":[],"length":0,"stats":{"Line":1}},{"line":15,"address":[],"length":0,"stats":{"Line":1}},{"line":19,"address":[],"length":0,"stats":{"Line":21}},{"line":20,"address":[],"length":0,"stats":{"Line":21}},{"line":25,"address":[],"length":0,"stats":{"Line":45}},{"line":26,"address":[],"length":0,"stats":{"Line":45}},{"line":27,"address":[],"length":0,"stats":{"Line":64}},{"line":28,"address":[],"length":0,"stats":{"Line":26}},{"line":36,"address":[],"length":0,"stats":{"Line":18}},{"line":37,"address":[],"length":0,"stats":{"Line":18}},{"line":38,"address":[],"length":0,"stats":{"Line":25}},{"line":39,"address":[],"length":0,"stats":{"Line":17}},{"line":40,"address":[],"length":0,"stats":{"Line":5}},{"line":41,"address":[],"length":0,"stats":{"Line":5}},{"line":56,"address":[],"length":0,"stats":{"Line":47}},{"line":57,"address":[],"length":0,"stats":{"Line":47}},{"line":58,"address":[],"length":0,"stats":{"Line":23}},{"line":59,"address":[],"length":0,"stats":{"Line":20}},{"line":60,"address":[],"length":0,"stats":{"Line":4}},{"line":66,"address":[],"length":0,"stats":{"Line":13}},{"line":67,"address":[],"length":0,"stats":{"Line":13}},{"line":68,"address":[],"length":0,"stats":{"Line":4}},{"line":69,"address":[],"length":0,"stats":{"Line":20}},{"line":70,"address":[],"length":0,"stats":{"Line":2}},{"line":85,"address":[],"length":0,"stats":{"Line":12}},{"line":86,"address":[],"length":0,"stats":{"Line":36}},{"line":87,"address":[],"length":0,"stats":{"Line":12}},{"line":88,"address":[],"length":0,"stats":{"Line":5}},{"line":89,"address":[],"length":0,"stats":{"Line":7}},{"line":90,"address":[],"length":0,"stats":{"Line":12}},{"line":92,"address":[],"length":0,"stats":{"Line":9}},{"line":97,"address":[],"length":0,"stats":{"Line":9}},{"line":98,"address":[],"length":0,"stats":{"Line":18}},{"line":99,"address":[],"length":0,"stats":{"Line":36}},{"line":100,"address":[],"length":0,"stats":{"Line":27}},{"line":101,"address":[],"length":0,"stats":{"Line":18}},{"line":105,"address":[],"length":0,"stats":{"Line":4}},{"line":106,"address":[],"length":0,"stats":{"Line":4}},{"line":110,"address":[],"length":0,"stats":{"Line":10}},{"line":111,"address":[],"length":0,"stats":{"Line":20}},{"line":112,"address":[],"length":0,"stats":{"Line":56}},{"line":122,"address":[],"length":0,"stats":{"Line":13}},{"line":123,"address":[],"length":0,"stats":{"Line":68}},{"line":124,"address":[],"length":0,"stats":{"Line":1564}},{"line":125,"address":[],"length":0,"stats":{"Line":22}},{"line":128,"address":[],"length":0,"stats":{"Line":4}},{"line":130,"address":[],"length":0,"stats":{"Line":6}},{"line":131,"address":[],"length":0,"stats":{"Line":166}},{"line":132,"address":[],"length":0,"stats":{"Line":2}},{"line":134,"address":[],"length":0,"stats":{"Line":1}}],"covered":52,"coverable":52},{"path":["/","Users","cat","hydra","src","tmux.rs"],"content":"use anyhow::{bail, Context, Result};\nuse std::collections::{HashMap, HashSet};\nuse std::sync::Mutex;\nuse std::time::Duration;\nuse tokio::process::Command;\n\nuse crate::session::{parse_session_name, AgentType, Session, SessionStatus};\n\n/// Default timeout for subprocess calls (2 seconds).\nconst CMD_TIMEOUT: Duration = Duration::from_secs(2);\n\n/// Longer timeout for scrollback capture (can be large).\nconst CMD_TIMEOUT_LONG: Duration = Duration::from_secs(5);\n\n/// Run a Command with a timeout, returning its Output.\n/// On timeout or spawn failure, returns an anyhow error.\npub async fn run_cmd_timeout(cmd: &mut Command) -> Result<std::process::Output> {\n    match tokio::time::timeout(CMD_TIMEOUT, cmd.output()).await {\n        Ok(result) => result.context(\"subprocess failed to execute\"),\n        Err(_) => bail!(\"subprocess timed out after {}s\", CMD_TIMEOUT.as_secs()),\n    }\n}\n\n/// Run a Command with a timeout, returning its ExitStatus.\n/// On timeout or spawn failure, returns an anyhow error.\npub async fn run_status_timeout(cmd: &mut Command) -> Result<std::process::ExitStatus> {\n    match tokio::time::timeout(CMD_TIMEOUT, cmd.status()).await {\n        Ok(result) => result.context(\"subprocess failed to execute\"),\n        Err(_) => bail!(\"subprocess timed out after {}s\", CMD_TIMEOUT.as_secs()),\n    }\n}\n\n#[async_trait::async_trait]\npub trait SessionManager: Send + Sync {\n    async fn list_sessions(&self, project_id: &str) -> Result<Vec<Session>>;\n    async fn create_session(\n        &self,\n        project_id: &str,\n        name: &str,\n        agent: &AgentType,\n        cwd: &str,\n        command_override: Option<&str>,\n    ) -> Result<String>;\n    async fn capture_pane(&self, tmux_name: &str) -> Result<String>;\n    async fn kill_session(&self, tmux_name: &str) -> Result<()>;\n    async fn send_keys(&self, tmux_name: &str, key: &str) -> Result<()>;\n    /// Send literal text (including escape sequences) via `tmux send-keys -l`.\n    async fn send_keys_literal(&self, _tmux_name: &str, _text: &str) -> Result<()> {\n        Ok(())\n    }\n    async fn capture_pane_scrollback(&self, tmux_name: &str) -> Result<String>;\n\n    /// Batch-capture pane content for multiple sessions. Default impl is sequential;\n    /// `TmuxSessionManager` overrides with parallel subprocess calls.\n    async fn capture_panes(&self, names: &[String]) -> Vec<Result<String>> {\n        let mut results = Vec::with_capacity(names.len());\n        for name in names {\n            results.push(self.capture_pane(name).await);\n        }\n        results\n    }\n}\n\npub struct TmuxSessionManager {\n    agent_cache: Mutex<HashMap<String, AgentType>>,\n}\n\nimpl TmuxSessionManager {\n    pub fn new() -> Self {\n        Self {\n            agent_cache: Mutex::new(HashMap::new()),\n        }\n    }\n}\n\nfn prune_agent_cache(cache: &mut HashMap<String, AgentType>, live_sessions: &HashSet<String>) {\n    cache.retain(|tmux_name, _| live_sessions.contains(tmux_name));\n}\n\n#[async_trait::async_trait]\nimpl SessionManager for TmuxSessionManager {\n    async fn list_sessions(&self, project_id: &str) -> Result<Vec<Session>> {\n        let output =\n            run_cmd_timeout(Command::new(\"tmux\").args([\"list-sessions\", \"-F\", \"#{session_name}\"]))\n                .await;\n\n        let output = match output {\n            Ok(o) => o,\n            Err(_) => return Ok(vec![]),\n        };\n\n        // tmux returns error when no server is running - that's fine, just no sessions\n        if !output.status.success() {\n            return Ok(vec![]);\n        }\n\n        let stdout = String::from_utf8_lossy(&output.stdout);\n        let prefix = format!(\"hydra-{project_id}-\");\n        let live_sessions: HashSet<String> = stdout\n            .lines()\n            .map(str::trim)\n            .filter(|line| !line.is_empty())\n            .map(|line| line.to_string())\n            .collect();\n\n        // Keep cache aligned with live tmux sessions to avoid unbounded growth.\n        prune_agent_cache(&mut self.agent_cache.lock().unwrap(), &live_sessions);\n\n        // Pass 1: Parse session names and resolve agent types (cached, no subprocess)\n        let mut parsed: Vec<(String, String, AgentType)> = Vec::new();\n        for line in stdout.lines() {\n            let tmux_name = line.trim();\n            if !tmux_name.starts_with(&prefix) {\n                continue;\n            }\n            let name = match parse_session_name(tmux_name, project_id) {\n                Some(n) => n,\n                None => continue,\n            };\n\n            let agent_type = {\n                let cached = self.agent_cache.lock().unwrap().get(tmux_name).cloned();\n                match cached {\n                    Some(a) => a,\n                    None => {\n                        let agent = get_agent_type(tmux_name).await.unwrap_or(AgentType::Claude);\n                        self.agent_cache\n                            .lock()\n                            .unwrap()\n                            .insert(tmux_name.to_string(), agent.clone());\n                        agent\n                    }\n                }\n            };\n\n            parsed.push((name, tmux_name.to_string(), agent_type));\n        }\n\n        // Pass 2: Run all is_pane_dead checks in parallel\n        let dead_futures = parsed\n            .iter()\n            .map(|(_, tmux_name, _)| is_pane_dead(tmux_name));\n        let dead_results = futures::future::join_all(dead_futures).await;\n\n        let sessions = parsed\n            .into_iter()\n            .zip(dead_results)\n            .map(|((name, tmux_name, agent_type), dead)| {\n                let status = if dead {\n                    SessionStatus::Exited\n                } else {\n                    // Default to Idle; App will upgrade to Running via content comparison\n                    SessionStatus::Idle\n                };\n                Session {\n                    name,\n                    tmux_name,\n                    agent_type,\n                    status,\n                    task_elapsed: None,\n                    _alive: true,\n                }\n            })\n            .collect();\n\n        Ok(sessions)\n    }\n\n    async fn create_session(\n        &self,\n        project_id: &str,\n        name: &str,\n        agent: &AgentType,\n        cwd: &str,\n        command_override: Option<&str>,\n    ) -> Result<String> {\n        let tmux_name = create_session(project_id, name, agent, cwd, command_override).await?;\n        self.agent_cache\n            .lock()\n            .unwrap()\n            .insert(tmux_name.clone(), agent.clone());\n        Ok(tmux_name)\n    }\n\n    async fn capture_pane(&self, tmux_name: &str) -> Result<String> {\n        capture_pane(tmux_name).await\n    }\n\n    async fn capture_panes(&self, names: &[String]) -> Vec<Result<String>> {\n        let futs = names.iter().map(|n| capture_pane(n));\n        futures::future::join_all(futs).await\n    }\n\n    async fn kill_session(&self, tmux_name: &str) -> Result<()> {\n        kill_session(tmux_name).await?;\n        self.agent_cache.lock().unwrap().remove(tmux_name);\n        Ok(())\n    }\n\n    async fn send_keys(&self, tmux_name: &str, key: &str) -> Result<()> {\n        send_keys(tmux_name, key).await\n    }\n\n    async fn send_keys_literal(&self, tmux_name: &str, text: &str) -> Result<()> {\n        send_keys_literal(tmux_name, text).await\n    }\n\n    async fn capture_pane_scrollback(&self, tmux_name: &str) -> Result<String> {\n        capture_pane_scrollback(tmux_name).await\n    }\n}\n\n/// Check if the pane in a tmux session has exited (requires remain-on-exit).\n/// Returns `true` when the session can't be queried (gone/dead) — a session\n/// we can't reach is effectively dead rather than silently \"Idle\".\nasync fn is_pane_dead(tmux_name: &str) -> bool {\n    let output = run_cmd_timeout(Command::new(\"tmux\").args([\n        \"list-panes\",\n        \"-t\",\n        tmux_name,\n        \"-F\",\n        \"#{pane_dead}\",\n    ]))\n    .await;\n\n    match output {\n        Ok(o) if o.status.success() => {\n            // Only treat as alive when we get a definitive \"not dead\" answer\n            String::from_utf8_lossy(&o.stdout).trim() != \"0\"\n        }\n        _ => true, // Can't reach session → treat as dead\n    }\n}\n\n/// Read the HYDRA_AGENT_TYPE env var from the tmux session.\nasync fn get_agent_type(tmux_name: &str) -> Option<AgentType> {\n    let output = run_cmd_timeout(Command::new(\"tmux\").args([\n        \"show-environment\",\n        \"-t\",\n        tmux_name,\n        \"HYDRA_AGENT_TYPE\",\n    ]))\n    .await\n    .ok()?;\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    // Output format: HYDRA_AGENT_TYPE=claude\n    let val = stdout.trim().strip_prefix(\"HYDRA_AGENT_TYPE=\")?;\n    val.parse().ok()\n}\n\n/// Create a new detached tmux session running the given agent command.\n/// If `command_override` is provided, it is used instead of `agent.command()`.\npub async fn create_session(\n    project_id: &str,\n    name: &str,\n    agent: &AgentType,\n    cwd: &str,\n    command_override: Option<&str>,\n) -> Result<String> {\n    let tmux_name = crate::session::tmux_session_name(project_id, name);\n    let cmd = command_override.unwrap_or(agent.command());\n\n    let status = run_status_timeout(Command::new(\"tmux\").args([\n        \"new-session\",\n        \"-d\",\n        \"-s\",\n        &tmux_name,\n        \"-c\",\n        cwd,\n        cmd,\n    ]))\n    .await\n    .context(\"Failed to create tmux session\")?;\n\n    if !status.success() {\n        bail!(\"tmux new-session failed for '{tmux_name}'\");\n    }\n\n    // Keep pane alive after command exits so we can detect Exited status\n    let _ = run_status_timeout(Command::new(\"tmux\").args([\n        \"set-option\",\n        \"-t\",\n        &tmux_name,\n        \"remain-on-exit\",\n        \"on\",\n    ]))\n    .await;\n\n    // Store agent type as env var on the session\n    let _ = run_status_timeout(Command::new(\"tmux\").args([\n        \"set-environment\",\n        \"-t\",\n        &tmux_name,\n        \"HYDRA_AGENT_TYPE\",\n        &agent.to_string().to_lowercase(),\n    ]))\n    .await;\n\n    Ok(tmux_name)\n}\n\n/// Capture the current pane content of a tmux session.\npub async fn capture_pane(tmux_name: &str) -> Result<String> {\n    let output =\n        run_cmd_timeout(Command::new(\"tmux\").args([\"capture-pane\", \"-t\", tmux_name, \"-p\"]))\n            .await\n            .context(\"Failed to capture tmux pane\")?;\n\n    if !output.status.success() {\n        return Ok(String::from(\"[session not available]\"));\n    }\n\n    let raw = String::from_utf8_lossy(&output.stdout);\n    let trimmed = raw.trim_end_matches('\\n');\n    Ok(trimmed.to_string())\n}\n\n/// Capture the scrollback buffer of a tmux session (last 5000 lines).\npub async fn capture_pane_scrollback(tmux_name: &str) -> Result<String> {\n    let output = match tokio::time::timeout(\n        CMD_TIMEOUT_LONG,\n        Command::new(\"tmux\")\n            .args([\"capture-pane\", \"-t\", tmux_name, \"-p\", \"-S\", \"-5000\"])\n            .output(),\n    )\n    .await\n    {\n        Ok(result) => result.context(\"Failed to capture tmux pane scrollback\")?,\n        Err(_) => bail!(\n            \"capture_pane_scrollback timed out after {}s\",\n            CMD_TIMEOUT_LONG.as_secs()\n        ),\n    };\n\n    if !output.status.success() {\n        return Ok(String::from(\"[session not available]\"));\n    }\n\n    // Trim trailing blank lines — tmux pads the capture to the full pane\n    // height, which makes short output appear to start halfway up the preview.\n    let raw = String::from_utf8_lossy(&output.stdout);\n    let trimmed = raw.trim_end_matches('\\n');\n    Ok(trimmed.to_string())\n}\n\n/// Send a key to a tmux session via `tmux send-keys`.\n/// Fire-and-forget: spawns the subprocess and reaps it in the background.\n/// The exit code provides no actionable info (session-not-found is discovered on next tick).\npub async fn send_keys(tmux_name: &str, key: &str) -> Result<()> {\n    let mut child = Command::new(\"tmux\")\n        .args([\"send-keys\", \"-t\", tmux_name, key])\n        .spawn()\n        .context(\"Failed to spawn tmux send-keys\")?;\n    tokio::spawn(async move {\n        let _ = tokio::time::timeout(Duration::from_millis(500), child.wait()).await;\n    });\n    Ok(())\n}\n\n/// Send literal text (including raw escape sequences) to a tmux session.\n/// Fire-and-forget: spawns the subprocess and reaps it in the background.\npub async fn send_keys_literal(tmux_name: &str, text: &str) -> Result<()> {\n    let mut child = Command::new(\"tmux\")\n        .args([\"send-keys\", \"-t\", tmux_name, \"-l\", text])\n        .spawn()\n        .context(\"Failed to spawn tmux send-keys -l\")?;\n    tokio::spawn(async move {\n        let _ = tokio::time::timeout(Duration::from_millis(500), child.wait()).await;\n    });\n    Ok(())\n}\n\n/// Map a crossterm KeyCode + KeyModifiers to a tmux key name.\npub fn keycode_to_tmux(\n    code: crossterm::event::KeyCode,\n    modifiers: crossterm::event::KeyModifiers,\n) -> Option<String> {\n    use crossterm::event::{KeyCode, KeyModifiers};\n\n    // Character keys: apply modifier prefix directly\n    if let KeyCode::Char(c) = code {\n        return Some(if modifiers.contains(KeyModifiers::CONTROL) {\n            format!(\"C-{c}\")\n        } else if modifiers.contains(KeyModifiers::ALT) {\n            format!(\"M-{c}\")\n        } else {\n            // SHIFT is already reflected in the char value (uppercase)\n            c.to_string()\n        });\n    }\n\n    // BackTab is Shift+Tab — already a distinct keycode, no modifier prefix needed\n    if code == KeyCode::BackTab {\n        return Some(\"BTab\".to_string());\n    }\n\n    // Special keys → tmux base names\n    let base = match code {\n        KeyCode::Enter => \"Enter\",\n        KeyCode::Backspace => \"BSpace\",\n        KeyCode::Tab => \"Tab\",\n        KeyCode::Up => \"Up\",\n        KeyCode::Down => \"Down\",\n        KeyCode::Left => \"Left\",\n        KeyCode::Right => \"Right\",\n        KeyCode::Home => \"Home\",\n        KeyCode::End => \"End\",\n        KeyCode::PageUp => \"PageUp\",\n        KeyCode::PageDown => \"PageDown\",\n        KeyCode::Delete => \"DC\",\n        KeyCode::Insert => \"IC\",\n        KeyCode::F(n) => return Some(apply_tmux_modifiers(&format!(\"F{n}\"), modifiers)),\n        _ => return None,\n    };\n\n    Some(apply_tmux_modifiers(base, modifiers))\n}\n\n/// Wrap a tmux key name with modifier prefixes (C-, M-, S-).\nfn apply_tmux_modifiers(base: &str, modifiers: crossterm::event::KeyModifiers) -> String {\n    use crossterm::event::KeyModifiers;\n\n    let mut key = base.to_string();\n    if modifiers.contains(KeyModifiers::SHIFT) {\n        key = format!(\"S-{key}\");\n    }\n    if modifiers.contains(KeyModifiers::ALT) {\n        key = format!(\"M-{key}\");\n    }\n    if modifiers.contains(KeyModifiers::CONTROL) {\n        key = format!(\"C-{key}\");\n    }\n    key\n}\n\n/// Kill a tmux session.\npub async fn kill_session(tmux_name: &str) -> Result<()> {\n    let status = run_status_timeout(Command::new(\"tmux\").args([\"kill-session\", \"-t\", tmux_name]))\n        .await\n        .context(\"Failed to kill tmux session\")?;\n\n    if !status.success() {\n        bail!(\"tmux kill-session failed for '{tmux_name}'\");\n    }\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crossterm::event::{KeyCode, KeyModifiers};\n\n    // ── keycode_to_tmux: character keys ──────────────────────────────\n\n    #[test]\n    fn char_key_no_modifiers() {\n        assert_eq!(\n            keycode_to_tmux(KeyCode::Char('a'), KeyModifiers::NONE),\n            Some(\"a\".into())\n        );\n    }\n\n    #[test]\n    fn char_key_uppercase() {\n        assert_eq!(\n            keycode_to_tmux(KeyCode::Char('A'), KeyModifiers::SHIFT),\n            Some(\"A\".into())\n        );\n    }\n\n    #[test]\n    fn char_key_ctrl() {\n        assert_eq!(\n            keycode_to_tmux(KeyCode::Char('c'), KeyModifiers::CONTROL),\n            Some(\"C-c\".into())\n        );\n    }\n\n    #[test]\n    fn char_key_alt() {\n        assert_eq!(\n            keycode_to_tmux(KeyCode::Char('x'), KeyModifiers::ALT),\n            Some(\"M-x\".into())\n        );\n    }\n\n    // ── keycode_to_tmux: special keys ────────────────────────────────\n\n    #[test]\n    fn enter_key() {\n        assert_eq!(\n            keycode_to_tmux(KeyCode::Enter, KeyModifiers::NONE),\n            Some(\"Enter\".into())\n        );\n    }\n\n    #[test]\n    fn backspace_key() {\n        assert_eq!(\n            keycode_to_tmux(KeyCode::Backspace, KeyModifiers::NONE),\n            Some(\"BSpace\".into())\n        );\n    }\n\n    #[test]\n    fn tab_key() {\n        assert_eq!(\n            keycode_to_tmux(KeyCode::Tab, KeyModifiers::NONE),\n            Some(\"Tab\".into())\n        );\n    }\n\n    #[test]\n    fn backtab_key() {\n        assert_eq!(\n            keycode_to_tmux(KeyCode::BackTab, KeyModifiers::NONE),\n            Some(\"BTab\".into())\n        );\n    }\n\n    #[test]\n    fn arrow_keys() {\n        assert_eq!(\n            keycode_to_tmux(KeyCode::Up, KeyModifiers::NONE),\n            Some(\"Up\".into())\n        );\n        assert_eq!(\n            keycode_to_tmux(KeyCode::Down, KeyModifiers::NONE),\n            Some(\"Down\".into())\n        );\n        assert_eq!(\n            keycode_to_tmux(KeyCode::Left, KeyModifiers::NONE),\n            Some(\"Left\".into())\n        );\n        assert_eq!(\n            keycode_to_tmux(KeyCode::Right, KeyModifiers::NONE),\n            Some(\"Right\".into())\n        );\n    }\n\n    #[test]\n    fn home_end_keys() {\n        assert_eq!(\n            keycode_to_tmux(KeyCode::Home, KeyModifiers::NONE),\n            Some(\"Home\".into())\n        );\n        assert_eq!(\n            keycode_to_tmux(KeyCode::End, KeyModifiers::NONE),\n            Some(\"End\".into())\n        );\n    }\n\n    #[test]\n    fn page_up_down_keys() {\n        assert_eq!(\n            keycode_to_tmux(KeyCode::PageUp, KeyModifiers::NONE),\n            Some(\"PageUp\".into())\n        );\n        assert_eq!(\n            keycode_to_tmux(KeyCode::PageDown, KeyModifiers::NONE),\n            Some(\"PageDown\".into())\n        );\n    }\n\n    #[test]\n    fn delete_insert_keys() {\n        assert_eq!(\n            keycode_to_tmux(KeyCode::Delete, KeyModifiers::NONE),\n            Some(\"DC\".into())\n        );\n        assert_eq!(\n            keycode_to_tmux(KeyCode::Insert, KeyModifiers::NONE),\n            Some(\"IC\".into())\n        );\n    }\n\n    #[test]\n    fn function_keys() {\n        assert_eq!(\n            keycode_to_tmux(KeyCode::F(1), KeyModifiers::NONE),\n            Some(\"F1\".into())\n        );\n        assert_eq!(\n            keycode_to_tmux(KeyCode::F(12), KeyModifiers::NONE),\n            Some(\"F12\".into())\n        );\n    }\n\n    #[test]\n    fn esc_returns_none() {\n        assert_eq!(keycode_to_tmux(KeyCode::Esc, KeyModifiers::NONE), None);\n    }\n\n    // ── keycode_to_tmux: modifiers on special keys ───────────────────\n\n    #[test]\n    fn ctrl_arrow() {\n        assert_eq!(\n            keycode_to_tmux(KeyCode::Up, KeyModifiers::CONTROL),\n            Some(\"C-Up\".into())\n        );\n    }\n\n    #[test]\n    fn alt_arrow() {\n        assert_eq!(\n            keycode_to_tmux(KeyCode::Left, KeyModifiers::ALT),\n            Some(\"M-Left\".into())\n        );\n    }\n\n    #[test]\n    fn shift_arrow() {\n        assert_eq!(\n            keycode_to_tmux(KeyCode::Right, KeyModifiers::SHIFT),\n            Some(\"S-Right\".into())\n        );\n    }\n\n    #[test]\n    fn ctrl_shift_function_key() {\n        assert_eq!(\n            keycode_to_tmux(KeyCode::F(5), KeyModifiers::CONTROL | KeyModifiers::SHIFT),\n            Some(\"C-S-F5\".into())\n        );\n    }\n\n    #[test]\n    fn all_modifiers_on_special_key() {\n        let mods = KeyModifiers::CONTROL | KeyModifiers::ALT | KeyModifiers::SHIFT;\n        assert_eq!(\n            keycode_to_tmux(KeyCode::Enter, mods),\n            Some(\"C-M-S-Enter\".into())\n        );\n    }\n\n    // ── apply_tmux_modifiers ─────────────────────────────────────────\n\n    #[test]\n    fn apply_no_modifiers() {\n        assert_eq!(apply_tmux_modifiers(\"Enter\", KeyModifiers::NONE), \"Enter\");\n    }\n\n    #[test]\n    fn apply_shift_only() {\n        assert_eq!(apply_tmux_modifiers(\"Up\", KeyModifiers::SHIFT), \"S-Up\");\n    }\n\n    #[test]\n    fn apply_alt_only() {\n        assert_eq!(apply_tmux_modifiers(\"Tab\", KeyModifiers::ALT), \"M-Tab\");\n    }\n\n    #[test]\n    fn apply_ctrl_only() {\n        assert_eq!(\n            apply_tmux_modifiers(\"Left\", KeyModifiers::CONTROL),\n            \"C-Left\"\n        );\n    }\n\n    #[test]\n    fn apply_modifier_ordering_ctrl_alt_shift() {\n        let mods = KeyModifiers::CONTROL | KeyModifiers::ALT | KeyModifiers::SHIFT;\n        // Shift applied first (innermost), then Alt, then Ctrl (outermost)\n        assert_eq!(apply_tmux_modifiers(\"F1\", mods), \"C-M-S-F1\");\n    }\n\n    // ── TmuxSessionManager agent cache ───────────────────────────────\n\n    #[test]\n    fn tmux_session_manager_new_has_empty_cache() {\n        let mgr = TmuxSessionManager::new();\n        let cache = mgr.agent_cache.lock().unwrap();\n        assert!(cache.is_empty());\n    }\n\n    #[test]\n    fn prune_agent_cache_removes_non_live_entries() {\n        let mut cache = HashMap::new();\n        cache.insert(\"hydra-a-one\".to_string(), AgentType::Claude);\n        cache.insert(\"hydra-a-two\".to_string(), AgentType::Codex);\n        cache.insert(\"hydra-a-stale\".to_string(), AgentType::Claude);\n\n        let live: HashSet<String> = [\"hydra-a-one\", \"hydra-a-two\"]\n            .iter()\n            .map(|s| s.to_string())\n            .collect();\n        prune_agent_cache(&mut cache, &live);\n\n        assert_eq!(cache.len(), 2);\n        assert!(cache.contains_key(\"hydra-a-one\"));\n        assert!(cache.contains_key(\"hydra-a-two\"));\n        assert!(!cache.contains_key(\"hydra-a-stale\"));\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":26}},{"line":18,"address":[],"length":0,"stats":{"Line":52}},{"line":19,"address":[],"length":0,"stats":{"Line":39}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":342}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":3}},{"line":71,"address":[],"length":0,"stats":{"Line":3}},{"line":76,"address":[],"length":0,"stats":{"Line":2}},{"line":77,"address":[],"length":0,"stats":{"Line":13}},{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":22}},{"line":103,"address":[],"length":0,"stats":{"Line":22}},{"line":142,"address":[],"length":0,"stats":{"Line":12}},{"line":148,"address":[],"length":0,"stats":{"Line":6}},{"line":149,"address":[],"length":0,"stats":{"Line":12}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":6}},{"line":155,"address":[],"length":0,"stats":{"Line":6}},{"line":156,"address":[],"length":0,"stats":{"Line":12}},{"line":157,"address":[],"length":0,"stats":{"Line":12}},{"line":158,"address":[],"length":0,"stats":{"Line":12}},{"line":159,"address":[],"length":0,"stats":{"Line":6}},{"line":160,"address":[],"length":0,"stats":{"Line":6}},{"line":161,"address":[],"length":0,"stats":{"Line":6}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":12}},{"line":217,"address":[],"length":0,"stats":{"Line":30}},{"line":218,"address":[],"length":0,"stats":{"Line":6}},{"line":219,"address":[],"length":0,"stats":{"Line":12}},{"line":220,"address":[],"length":0,"stats":{"Line":12}},{"line":221,"address":[],"length":0,"stats":{"Line":6}},{"line":222,"address":[],"length":0,"stats":{"Line":6}},{"line":224,"address":[],"length":0,"stats":{"Line":6}},{"line":226,"address":[],"length":0,"stats":{"Line":6}},{"line":227,"address":[],"length":0,"stats":{"Line":24}},{"line":229,"address":[],"length":0,"stats":{"Line":6}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":12}},{"line":237,"address":[],"length":0,"stats":{"Line":30}},{"line":238,"address":[],"length":0,"stats":{"Line":6}},{"line":239,"address":[],"length":0,"stats":{"Line":12}},{"line":240,"address":[],"length":0,"stats":{"Line":6}},{"line":241,"address":[],"length":0,"stats":{"Line":6}},{"line":243,"address":[],"length":0,"stats":{"Line":6}},{"line":246,"address":[],"length":0,"stats":{"Line":18}},{"line":248,"address":[],"length":0,"stats":{"Line":18}},{"line":249,"address":[],"length":0,"stats":{"Line":18}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":29}},{"line":382,"address":[],"length":0,"stats":{"Line":35}},{"line":383,"address":[],"length":0,"stats":{"Line":12}},{"line":384,"address":[],"length":0,"stats":{"Line":2}},{"line":385,"address":[],"length":0,"stats":{"Line":8}},{"line":386,"address":[],"length":0,"stats":{"Line":1}},{"line":389,"address":[],"length":0,"stats":{"Line":6}},{"line":394,"address":[],"length":0,"stats":{"Line":23}},{"line":395,"address":[],"length":0,"stats":{"Line":1}},{"line":399,"address":[],"length":0,"stats":{"Line":39}},{"line":400,"address":[],"length":0,"stats":{"Line":2}},{"line":401,"address":[],"length":0,"stats":{"Line":1}},{"line":402,"address":[],"length":0,"stats":{"Line":1}},{"line":403,"address":[],"length":0,"stats":{"Line":2}},{"line":404,"address":[],"length":0,"stats":{"Line":1}},{"line":405,"address":[],"length":0,"stats":{"Line":2}},{"line":406,"address":[],"length":0,"stats":{"Line":2}},{"line":407,"address":[],"length":0,"stats":{"Line":1}},{"line":408,"address":[],"length":0,"stats":{"Line":1}},{"line":409,"address":[],"length":0,"stats":{"Line":1}},{"line":410,"address":[],"length":0,"stats":{"Line":1}},{"line":411,"address":[],"length":0,"stats":{"Line":1}},{"line":412,"address":[],"length":0,"stats":{"Line":1}},{"line":413,"address":[],"length":0,"stats":{"Line":9}},{"line":414,"address":[],"length":0,"stats":{"Line":2}},{"line":417,"address":[],"length":0,"stats":{"Line":34}},{"line":421,"address":[],"length":0,"stats":{"Line":25}},{"line":424,"address":[],"length":0,"stats":{"Line":75}},{"line":425,"address":[],"length":0,"stats":{"Line":55}},{"line":426,"address":[],"length":0,"stats":{"Line":5}},{"line":428,"address":[],"length":0,"stats":{"Line":54}},{"line":429,"address":[],"length":0,"stats":{"Line":4}},{"line":431,"address":[],"length":0,"stats":{"Line":55}},{"line":432,"address":[],"length":0,"stats":{"Line":5}},{"line":434,"address":[],"length":0,"stats":{"Line":25}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}}],"covered":78,"coverable":168},{"path":["/","Users","cat","hydra","src","ui.rs"],"content":"use ratatui::{\n    layout::{Constraint, Direction, Layout, Rect},\n    style::{Color, Modifier, Style},\n    text::{Line, Span},\n    widgets::{Block, BorderType, Borders, Clear, List, ListItem, Paragraph},\n    Frame,\n};\n\nuse crate::app::{App, Mode};\nuse crate::logs::{format_cost, format_tokens};\nuse crate::session::{format_duration, AgentType, SessionStatus};\n\npub fn draw(frame: &mut Frame, app: &App) {\n    let chunks = Layout::default()\n        .direction(Direction::Vertical)\n        .constraints([Constraint::Min(1), Constraint::Length(1)])\n        .split(frame.area());\n\n    let main_area = chunks[0];\n    let help_area = chunks[1];\n\n    // Main layout: sidebar | preview\n    let panels = Layout::default()\n        .direction(Direction::Horizontal)\n        .constraints([Constraint::Percentage(20), Constraint::Percentage(80)])\n        .split(main_area);\n\n    app.sidebar_area.set(panels[0]);\n    app.preview_area.set(panels[1]);\n\n    draw_sidebar(frame, app, panels[0]);\n    draw_preview(frame, app, panels[1]);\n    draw_help_bar(frame, app, help_area);\n\n    // Draw modal overlays\n    match app.mode {\n        Mode::NewSessionAgent => draw_agent_select(frame, app),\n        Mode::ConfirmDelete => draw_confirm_delete(frame, app),\n        Mode::Browse | Mode::Attached => {}\n    }\n}\n\nfn status_color(status: &SessionStatus) -> Color {\n    match status {\n        SessionStatus::Idle => Color::Green,\n        SessionStatus::Running => Color::Red,\n        SessionStatus::Exited => Color::Yellow,\n    }\n}\n\nfn draw_sidebar(frame: &mut Frame, app: &App, area: Rect) {\n    // Show stats if global stats have any tokens\n    let has_stats = app.global_stats.tokens_in + app.global_stats.tokens_out > 0;\n\n    let stats_height = if has_stats { 3 } else { 0 }; // 1 line + top/bottom border\n\n    // Update diff tree cache if inputs changed (diff_files or sidebar width).\n    // Avoids recomputing sort + format on every frame (~4+ FPS) when data\n    // only changes every ~5 seconds.\n    let width = area.width.saturating_sub(2) as usize;\n    {\n        let mut cache = app.diff_tree_cache.borrow_mut();\n        if cache.0 != app.diff_files || cache.1 != width {\n            cache.2 = build_diff_tree_lines(&app.diff_files, width);\n            cache.0 = app.diff_files.clone();\n            cache.1 = width;\n        }\n    }\n    let cache = app.diff_tree_cache.borrow();\n    let tree_lines = &cache.2;\n\n    let max_tree_rows: u16 = 8;\n    let tree_height = if tree_lines.is_empty() {\n        0\n    } else {\n        (tree_lines.len() as u16 + 2).min(max_tree_rows + 2) // +2 for top/bottom border\n    };\n\n    let sidebar_chunks = Layout::default()\n        .direction(Direction::Vertical)\n        .constraints([\n            Constraint::Min(1),\n            Constraint::Length(stats_height),\n            Constraint::Length(tree_height),\n        ])\n        .split(area);\n\n    let list_area = sidebar_chunks[0];\n    let stats_area = sidebar_chunks[1];\n    let tree_area = sidebar_chunks[2];\n\n    // Build session list with status group headers.\n    // Sessions are already sorted by status group then name in app.rs.\n    // We insert a header ListItem when the status group changes.\n    // `selected_visual_row` maps app.selected (session index) to the\n    // visual row in the list (accounting for header items).\n    let inner_width = list_area.width.saturating_sub(2) as usize; // inside border\n    let subtle = Style::default();\n    let mut items: Vec<ListItem> = Vec::new();\n    let mut selected_visual_row: usize = 0;\n    let mut current_group: Option<u8> = None;\n\n    for (i, session) in app.sessions.iter().enumerate() {\n        let group = session.status.sort_order();\n        if current_group != Some(group) {\n            current_group = Some(group);\n            // Build header: \"── ● Running ──────\"\n            let label = format!(\" {} \", session.status);\n            let dot_color = status_color(&session.status);\n            let dashes_left = \"── \";\n            let dashes_right_len = inner_width.saturating_sub(dashes_left.len() + 2 + label.len()); // 2 for \"● \"\n            let dashes_right: String = \"─\".repeat(dashes_right_len);\n            let header_spans = vec![\n                Span::styled(dashes_left, subtle),\n                Span::styled(\"● \", Style::default().fg(dot_color)),\n                Span::styled(label, Style::default()),\n                Span::styled(dashes_right, subtle),\n            ];\n            items.push(ListItem::new(Line::from(header_spans)));\n        }\n\n        if i == app.selected {\n            selected_visual_row = items.len();\n        }\n\n        let marker = if i == app.selected { \">> \" } else { \"   \" };\n        let name_style = if i == app.selected {\n            Style::default()\n                .fg(Color::Yellow)\n                .add_modifier(Modifier::BOLD)\n        } else {\n            Style::default()\n        };\n        let mut spans = vec![\n            Span::styled(marker, name_style),\n            Span::styled(\"● \", Style::default().fg(status_color(&session.status))),\n            Span::styled(\n                format!(\"{} [{}]\", session.name, session.agent_type),\n                name_style,\n            ),\n        ];\n        if let Some(elapsed) = session.task_elapsed {\n            spans.push(Span::styled(\n                format!(\" {}\", format_duration(elapsed)),\n                Style::default(),\n            ));\n        }\n        if let Some(stats) = app.session_stats.get(&session.tmux_name) {\n            if stats.active_subagents > 0 {\n                spans.push(Span::styled(\n                    format!(\" [{}T]\", stats.active_subagents),\n                    Style::default().fg(Color::Magenta),\n                ));\n            }\n        }\n        let mut lines = vec![Line::from(spans)];\n        if let Some(msg) = app.last_messages.get(&session.tmux_name) {\n            let max_chars = 50;\n            let display = if msg.chars().count() > max_chars {\n                let truncated: String = msg.chars().take(max_chars).collect();\n                format!(\"     {truncated}...\")\n            } else {\n                format!(\"     {msg}\")\n            };\n            lines.push(Line::from(Span::styled(display, Style::default())));\n        }\n        items.push(ListItem::new(lines));\n    }\n\n    let session_count = app.sessions.len();\n    let title = format!(\" Sessions ({session_count}) \");\n    let list = List::new(items)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .title(title)\n                .border_style(Style::default().fg(Color::Cyan)),\n        )\n        .highlight_style(Style::default()) // selection handled manually via \">>\"\n        .highlight_symbol(\"\");\n\n    // Use stateful rendering to scroll the list to the selected visual row.\n    let mut list_state = ratatui::widgets::ListState::default();\n    list_state.select(Some(selected_visual_row));\n    frame.render_stateful_widget(list, list_area, &mut list_state);\n\n    // Draw aggregate stats across all sessions\n    if has_stats {\n        draw_stats(frame, app, stats_area);\n    }\n\n    // Draw diff tree\n    if !tree_lines.is_empty() {\n        draw_diff_tree(frame, &tree_lines, tree_area);\n    }\n}\n\n/// Truncate a string to at most `max` characters (Unicode-safe).\nfn truncate_chars(s: &str, max: usize) -> String {\n    s.chars().take(max).collect()\n}\n\n/// Build lines for a compact diff tree grouped by directory.\n/// Files sorted by path, grouped under directory headers.\n/// Output example:\n///   src/\n///    app.rs       +45-12\n///    ui.rs        +30-5\n///   README.md     +3\npub fn build_diff_tree_lines(\n    diff_files: &[crate::app::DiffFile],\n    width: usize,\n) -> Vec<Line<'static>> {\n    if diff_files.is_empty() {\n        return vec![];\n    }\n\n    let green = Style::default().fg(Color::Green);\n    let red = Style::default().fg(Color::Red);\n    let cyan = Style::default().fg(Color::Cyan);\n\n    let mut sorted: Vec<&crate::app::DiffFile> = diff_files.iter().collect();\n    sorted.sort_by(|a, b| a.path.cmp(&b.path));\n\n    let mut lines: Vec<Line> = Vec::new();\n    let mut current_dir: Option<&str> = None;\n    let inner_w = width.saturating_sub(1); // leave 1 char margin\n\n    for f in &sorted {\n        let (dir, basename) = match f.path.rfind('/') {\n            Some(i) => (Some(&f.path[..=i]), &f.path[i + 1..]),\n            None => (None, f.path.as_str()),\n        };\n\n        // Skip entries with empty basenames (e.g. trailing-slash paths)\n        if basename.is_empty() {\n            continue;\n        }\n\n        // Emit directory header if changed\n        let dir_str = dir.unwrap_or(\"\");\n        let show_dir = match current_dir {\n            Some(prev) => prev != dir_str,\n            None => dir.is_some(),\n        };\n        if show_dir {\n            if let Some(d) = dir {\n                let display: String = if d.chars().count() > inner_w {\n                    truncate_chars(d, inner_w)\n                } else {\n                    d.to_string()\n                };\n                lines.push(Line::from(Span::styled(\n                    format!(\" {display}\"),\n                    Style::default(),\n                )));\n            }\n            current_dir = Some(dir_str);\n        }\n\n        // Build diff stat string\n        let stat = if f.untracked {\n            \"new\".to_string()\n        } else {\n            format_compact_diff(f.insertions, f.deletions)\n        };\n        let indent = if dir.is_some() { \"  \" } else { \" \" };\n\n        // Compute available space for filename\n        let stat_len = stat.chars().count();\n        let prefix_len = indent.len();\n        let available = inner_w.saturating_sub(prefix_len + stat_len + 1);\n\n        let basename_chars = basename.chars().count();\n        let name: String = if available == 0 {\n            String::new()\n        } else if basename_chars > available && available > 3 {\n            format!(\"{}…\", truncate_chars(basename, available - 1))\n        } else if basename_chars > available {\n            truncate_chars(basename, available)\n        } else {\n            basename.to_string()\n        };\n\n        let name_chars = name.chars().count();\n        let padding = inner_w.saturating_sub(prefix_len + name_chars + stat_len);\n        let pad_str: String = \" \".repeat(padding);\n\n        let mut spans = vec![Span::styled(\n            format!(\"{indent}{name}{pad_str}\"),\n            Style::default(),\n        )];\n\n        if f.untracked {\n            spans.push(Span::styled(\"new\", cyan));\n        } else {\n            if f.insertions > 0 {\n                spans.push(Span::styled(format!(\"+{}\", f.insertions), green));\n            }\n            if f.deletions > 0 {\n                spans.push(Span::styled(format!(\"-{}\", f.deletions), red));\n            }\n        }\n\n        lines.push(Line::from(spans));\n    }\n\n    lines\n}\n\n/// Format compact diff: \"+45-12\", \"+45\", \"-12\"\nfn format_compact_diff(ins: u32, del: u32) -> String {\n    match (ins > 0, del > 0) {\n        (true, true) => format!(\"+{ins}-{del}\"),\n        (true, false) => format!(\"+{ins}\"),\n        (false, true) => format!(\"-{del}\"),\n        (false, false) => String::new(),\n    }\n}\n\nfn draw_diff_tree(frame: &mut Frame, lines: &[Line], area: Rect) {\n    let block = Block::default()\n        .borders(Borders::ALL)\n        .title(\" Changes \")\n        .border_style(Style::default().fg(Color::Cyan));\n\n    let inner = block.inner(area);\n    frame.render_widget(block, area);\n\n    // Show the tail that fits (most relevant files at bottom)\n    let max_rows = inner.height as usize;\n    let start = lines.len().saturating_sub(max_rows);\n    let visible: Vec<Line> = lines[start..].to_vec();\n\n    let paragraph = Paragraph::new(visible);\n    frame.render_widget(paragraph, inner);\n}\n\nfn draw_stats(frame: &mut Frame, app: &App, area: Rect) {\n    // Use machine-wide global stats for cost and tokens\n    let total_cost = app.global_stats.cost_usd();\n    let total_tokens = app.global_stats.tokens_in + app.global_stats.tokens_out;\n\n    // Edits are hydra-specific (per-session)\n    let total_edits: u16 = app.session_stats.values().map(|s| s.edits).sum();\n\n    let val = Style::default();\n\n    // Total diff across all files\n    let total_diff: u32 = app\n        .diff_files\n        .iter()\n        .map(|f| f.insertions + f.deletions)\n        .sum();\n\n    let mut spans = vec![\n        Span::styled(format_cost(total_cost), Style::default().fg(Color::Green)),\n        Span::styled(format!(\" {}\", format_tokens(total_tokens)), val),\n        Span::styled(format!(\" {}✎\", total_edits), val),\n    ];\n\n    if total_diff > 0 {\n        spans.push(Span::styled(format!(\" Δ{total_diff}\"), val));\n    }\n\n    let line = Line::from(spans);\n\n    let block = Block::default()\n        .borders(Borders::ALL)\n        .title(\" Stats \")\n        .border_style(Style::default().fg(Color::Cyan));\n\n    let paragraph = Paragraph::new(line).block(block);\n    frame.render_widget(paragraph, area);\n}\n\nfn draw_preview(frame: &mut Frame, app: &App, area: Rect) {\n    let title = if let Some(session) = app.sessions.get(app.selected) {\n        format!(\" {} \", session.name)\n    } else {\n        \" Preview \".to_string()\n    };\n\n    let mut preview_area = area;\n    let (border_style, border_type, border_title) = if app.mode == Mode::Attached {\n        let active_style = Style::default()\n            .fg(Color::LightGreen)\n            .add_modifier(Modifier::BOLD);\n\n        // Use three nested borders in attached mode so the active pane is obvious.\n        if area.width >= 7 && area.height >= 7 {\n            let attached_title = if let Some(session) = app.sessions.get(app.selected) {\n                format!(\" {} [ATTACHED] \", session.name)\n            } else {\n                \" Preview [ATTACHED] \".to_string()\n            };\n\n            frame.render_widget(\n                Block::default()\n                    .borders(Borders::ALL)\n                    .border_type(BorderType::Thick)\n                    .title(attached_title)\n                    .border_style(active_style),\n                area,\n            );\n\n            let middle_area = inset_rect(area, 1);\n            frame.render_widget(\n                Block::default()\n                    .borders(Borders::ALL)\n                    .border_type(BorderType::Double)\n                    .border_style(active_style),\n                middle_area,\n            );\n\n            preview_area = inset_rect(area, 2);\n            (active_style, BorderType::Plain, String::new())\n        } else {\n            (active_style, BorderType::Double, title)\n        }\n    } else {\n        (Style::default().fg(Color::Cyan), BorderType::Plain, title)\n    };\n\n    let inner_height = preview_area.height.saturating_sub(2);\n    let total_lines = app.preview_line_count;\n    let max_scroll_offset = total_lines.saturating_sub(inner_height);\n    let capped_offset = app.preview_scroll_offset.min(max_scroll_offset);\n    let scroll_y = max_scroll_offset.saturating_sub(capped_offset);\n\n    let preview = Paragraph::new(app.preview.as_str())\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_type(border_type)\n                .title(border_title)\n                .border_style(border_style),\n        )\n        .scroll((scroll_y, 0));\n\n    frame.render_widget(preview, preview_area);\n}\n\nfn draw_help_bar(frame: &mut Frame, app: &App, area: Rect) {\n    let help_text = match app.mode {\n        Mode::Browse if !app.mouse_captured => \"SELECT TEXT TO COPY  |  c: exit copy mode\",\n        Mode::Browse => \"j/k: navigate  Enter: attach  n: new  d: delete  c: copy  q: quit\",\n        Mode::Attached => \"Esc: detach  (keys forwarded to session)\",\n        Mode::NewSessionAgent => \"j/k: select agent  Enter: confirm  Esc: cancel\",\n        Mode::ConfirmDelete => \"y: confirm delete  Esc: cancel\",\n    };\n\n    let status = if let Some(msg) = &app.status_message {\n        format!(\" {msg} | {help_text}\")\n    } else {\n        format!(\" {help_text}\")\n    };\n\n    let bar = Paragraph::new(Line::from(Span::styled(\n        status,\n        Style::default()\n            .fg(Color::Black)\n            .bg(Color::Cyan)\n            .add_modifier(Modifier::BOLD),\n    )));\n\n    frame.render_widget(bar, area);\n}\n\nfn centered_rect(width: u16, height: u16, area: Rect) -> Rect {\n    let x = area.x + area.width.saturating_sub(width) / 2;\n    let y = area.y + area.height.saturating_sub(height) / 2;\n    Rect::new(x, y, width.min(area.width), height.min(area.height))\n}\n\nfn inset_rect(area: Rect, margin: u16) -> Rect {\n    let double = margin.saturating_mul(2);\n    Rect::new(\n        area.x.saturating_add(margin),\n        area.y.saturating_add(margin),\n        area.width.saturating_sub(double),\n        area.height.saturating_sub(double),\n    )\n}\n\nfn draw_agent_select(frame: &mut Frame, app: &App) {\n    let agents = AgentType::all();\n    let height = agents.len() as u16 + 2;\n    let area = centered_rect(30, height, frame.area());\n    frame.render_widget(Clear, area);\n\n    let items: Vec<ListItem> = agents\n        .iter()\n        .enumerate()\n        .map(|(i, agent)| {\n            let marker = if i == app.agent_selection {\n                \">> \"\n            } else {\n                \"   \"\n            };\n            let label = format!(\"{marker}{agent}\");\n            let style = if i == app.agent_selection {\n                Style::default()\n                    .fg(Color::Yellow)\n                    .add_modifier(Modifier::BOLD)\n            } else {\n                Style::default()\n            };\n            ListItem::new(Line::from(Span::styled(label, style)))\n        })\n        .collect();\n\n    let list = List::new(items).block(\n        Block::default()\n            .borders(Borders::ALL)\n            .title(\" Select Agent \")\n            .border_style(Style::default().fg(Color::Yellow)),\n    );\n    frame.render_widget(list, area);\n}\n\nfn draw_confirm_delete(frame: &mut Frame, app: &App) {\n    let area = centered_rect(40, 5, frame.area());\n    frame.render_widget(Clear, area);\n\n    let name = app\n        .sessions\n        .get(app.selected)\n        .map(|s| s.name.as_str())\n        .unwrap_or(\"?\");\n\n    let text = format!(\" Kill session '{name}'? (y/n)\");\n    let confirm = Paragraph::new(text).block(\n        Block::default()\n            .borders(Borders::ALL)\n            .title(\" Confirm Delete \")\n            .border_style(Style::default().fg(Color::Red)),\n    );\n    frame.render_widget(confirm, area);\n}\n\n#[cfg(test)]\nmod tests {\n    use ratatui::{backend::TestBackend, Terminal};\n\n    use crate::app::{App, Mode};\n    use crate::session::{AgentType, Session, SessionStatus};\n    use crate::tmux::SessionManager;\n\n    struct NoopSessionManager;\n\n    #[async_trait::async_trait]\n    impl SessionManager for NoopSessionManager {\n        async fn list_sessions(&self, _: &str) -> anyhow::Result<Vec<Session>> {\n            Ok(vec![])\n        }\n        async fn create_session(\n            &self,\n            _: &str,\n            _: &str,\n            _: &AgentType,\n            _: &str,\n            _: Option<&str>,\n        ) -> anyhow::Result<String> {\n            Ok(String::new())\n        }\n        async fn capture_pane(&self, _: &str) -> anyhow::Result<String> {\n            Ok(String::new())\n        }\n        async fn kill_session(&self, _: &str) -> anyhow::Result<()> {\n            Ok(())\n        }\n        async fn send_keys(&self, _: &str, _: &str) -> anyhow::Result<()> {\n            Ok(())\n        }\n        async fn capture_pane_scrollback(&self, _: &str) -> anyhow::Result<String> {\n            Ok(String::new())\n        }\n    }\n\n    fn make_app() -> App {\n        App::new_with_manager(\n            \"testproj\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(NoopSessionManager),\n        )\n    }\n\n    fn make_session(name: &str, agent: AgentType) -> Session {\n        make_session_with_status(name, agent, SessionStatus::Idle)\n    }\n\n    fn make_session_with_status(name: &str, agent: AgentType, status: SessionStatus) -> Session {\n        Session {\n            name: name.to_string(),\n            tmux_name: format!(\"hydra-testproj-{name}\"),\n            agent_type: agent,\n            status,\n            task_elapsed: None,\n            _alive: true,\n        }\n    }\n\n    fn buffer_to_string(terminal: &Terminal<TestBackend>) -> String {\n        let buf = terminal.backend().buffer();\n        let mut output = String::new();\n        for y in 0..buf.area.height {\n            for x in 0..buf.area.width {\n                let cell = &buf[(x, y)];\n                output.push_str(cell.symbol());\n            }\n            let trimmed = output.trim_end();\n            output = trimmed.to_string();\n            output.push('\\n');\n        }\n        output\n    }\n\n    #[test]\n    fn browse_mode_with_sessions() {\n        let backend = TestBackend::new(80, 24);\n        let mut terminal = Terminal::new(backend).unwrap();\n\n        let mut app = make_app();\n        app.sessions = vec![\n            make_session(\"worker-1\", AgentType::Claude),\n            make_session(\"worker-2\", AgentType::Codex),\n            make_session(\"research\", AgentType::Claude),\n        ];\n        app.selected = 0;\n        app.set_preview_text(\"some preview content\".to_string());\n\n        terminal.draw(|f| super::draw(f, &app)).unwrap();\n        let output = buffer_to_string(&terminal);\n\n        insta::assert_snapshot!(output);\n    }\n\n    #[test]\n    fn browse_mode_empty() {\n        let backend = TestBackend::new(80, 24);\n        let mut terminal = Terminal::new(backend).unwrap();\n\n        let mut app = make_app();\n        app.set_preview_text(\"No sessions. Press 'n' to create one.\".to_string());\n\n        terminal.draw(|f| super::draw(f, &app)).unwrap();\n        let output = buffer_to_string(&terminal);\n\n        insta::assert_snapshot!(output);\n    }\n\n    #[test]\n    fn new_session_agent_modal() {\n        let backend = TestBackend::new(80, 24);\n        let mut terminal = Terminal::new(backend).unwrap();\n\n        let mut app = make_app();\n        app.mode = Mode::NewSessionAgent;\n        app.agent_selection = 0;\n\n        terminal.draw(|f| super::draw(f, &app)).unwrap();\n        let output = buffer_to_string(&terminal);\n\n        insta::assert_snapshot!(output);\n    }\n\n    #[test]\n    fn confirm_delete_modal() {\n        let backend = TestBackend::new(80, 24);\n        let mut terminal = Terminal::new(backend).unwrap();\n\n        let mut app = make_app();\n        app.sessions = vec![make_session(\"doomed-session\", AgentType::Claude)];\n        app.selected = 0;\n        app.mode = Mode::ConfirmDelete;\n\n        terminal.draw(|f| super::draw(f, &app)).unwrap();\n        let output = buffer_to_string(&terminal);\n\n        insta::assert_snapshot!(output);\n    }\n\n    #[test]\n    fn attached_mode() {\n        let backend = TestBackend::new(80, 24);\n        let mut terminal = Terminal::new(backend).unwrap();\n\n        let mut app = make_app();\n        app.sessions = vec![make_session(\"active-session\", AgentType::Claude)];\n        app.selected = 0;\n        app.mode = Mode::Attached;\n        app.set_preview_text(\"$ claude\\nHello, how can I help?\".to_string());\n\n        terminal.draw(|f| super::draw(f, &app)).unwrap();\n        let output = buffer_to_string(&terminal);\n\n        insta::assert_snapshot!(output);\n    }\n\n    #[test]\n    fn status_message_displayed() {\n        let backend = TestBackend::new(80, 24);\n        let mut terminal = Terminal::new(backend).unwrap();\n\n        let mut app = make_app();\n        app.status_message = Some(\"Created session 'worker-1' with Claude\".to_string());\n        app.set_preview_text(\"No sessions. Press 'n' to create one.\".to_string());\n\n        terminal.draw(|f| super::draw(f, &app)).unwrap();\n        let output = buffer_to_string(&terminal);\n\n        insta::assert_snapshot!(output);\n    }\n\n    #[test]\n    fn browse_mode_with_all_statuses() {\n        let backend = TestBackend::new(80, 24);\n        let mut terminal = Terminal::new(backend).unwrap();\n\n        let mut app = make_app();\n        app.sessions = vec![\n            make_session_with_status(\"idle-one\", AgentType::Claude, SessionStatus::Idle),\n            make_session_with_status(\"running-one\", AgentType::Codex, SessionStatus::Running),\n            make_session_with_status(\"exited-one\", AgentType::Claude, SessionStatus::Exited),\n        ];\n        app.selected = 1;\n        app.set_preview_text(\"running session output\".to_string());\n\n        terminal.draw(|f| super::draw(f, &app)).unwrap();\n        let output = buffer_to_string(&terminal);\n\n        insta::assert_snapshot!(output);\n    }\n\n    #[test]\n    fn browse_mode_with_task_elapsed() {\n        let backend = TestBackend::new(80, 24);\n        let mut terminal = Terminal::new(backend).unwrap();\n\n        let mut app = make_app();\n        let mut session = make_session(\"worker-1\", AgentType::Claude);\n        session.status = SessionStatus::Running;\n        session.task_elapsed = Some(std::time::Duration::from_secs(125));\n        app.sessions = vec![session];\n        app.selected = 0;\n        app.set_preview_text(\"working...\".to_string());\n\n        terminal.draw(|f| super::draw(f, &app)).unwrap();\n        let output = buffer_to_string(&terminal);\n\n        insta::assert_snapshot!(output);\n    }\n\n    #[test]\n    fn browse_mode_with_last_messages() {\n        let backend = TestBackend::new(80, 24);\n        let mut terminal = Terminal::new(backend).unwrap();\n\n        let mut app = make_app();\n        app.sessions = vec![\n            make_session(\"worker-1\", AgentType::Claude),\n            make_session(\"worker-2\", AgentType::Codex),\n        ];\n        app.selected = 0;\n        app.set_preview_text(\"preview\".to_string());\n        app.last_messages.insert(\n            \"hydra-testproj-worker-1\".to_string(),\n            \"I'll help you with that task.\".to_string(),\n        );\n\n        terminal.draw(|f| super::draw(f, &app)).unwrap();\n        let output = buffer_to_string(&terminal);\n\n        insta::assert_snapshot!(output);\n    }\n\n    #[test]\n    fn browse_mode_with_long_last_message_truncated() {\n        let backend = TestBackend::new(80, 24);\n        let mut terminal = Terminal::new(backend).unwrap();\n\n        let mut app = make_app();\n        app.sessions = vec![make_session(\"worker-1\", AgentType::Claude)];\n        app.selected = 0;\n        app.set_preview_text(\"preview\".to_string());\n        app.last_messages.insert(\n            \"hydra-testproj-worker-1\".to_string(),\n            \"This is a very long message that should be truncated at fifty characters to fit sidebar\".to_string(),\n        );\n\n        terminal.draw(|f| super::draw(f, &app)).unwrap();\n        let output = buffer_to_string(&terminal);\n\n        insta::assert_snapshot!(output);\n    }\n\n    #[test]\n    fn preview_scrolling_renders() {\n        let backend = TestBackend::new(80, 24);\n        let mut terminal = Terminal::new(backend).unwrap();\n\n        let mut app = make_app();\n        app.sessions = vec![make_session(\"s1\", AgentType::Claude)];\n        app.selected = 0;\n        // Create content taller than the preview area\n        app.set_preview_text(\n            (0..50)\n                .map(|i| format!(\"line {i}\"))\n                .collect::<Vec<_>>()\n                .join(\"\\n\"),\n        );\n        app.preview_scroll_offset = 10;\n\n        terminal.draw(|f| super::draw(f, &app)).unwrap();\n        let output = buffer_to_string(&terminal);\n\n        insta::assert_snapshot!(output);\n    }\n\n    #[test]\n    fn agent_select_second_highlighted() {\n        let backend = TestBackend::new(80, 24);\n        let mut terminal = Terminal::new(backend).unwrap();\n\n        let mut app = make_app();\n        app.mode = Mode::NewSessionAgent;\n        app.agent_selection = 1; // Select Codex\n\n        terminal.draw(|f| super::draw(f, &app)).unwrap();\n        let output = buffer_to_string(&terminal);\n\n        insta::assert_snapshot!(output);\n    }\n\n    #[test]\n    fn confirm_delete_no_sessions() {\n        let backend = TestBackend::new(80, 24);\n        let mut terminal = Terminal::new(backend).unwrap();\n\n        let mut app = make_app();\n        app.mode = Mode::ConfirmDelete;\n        // No sessions — should show \"?\"\n\n        terminal.draw(|f| super::draw(f, &app)).unwrap();\n        let output = buffer_to_string(&terminal);\n\n        insta::assert_snapshot!(output);\n    }\n\n    // ── Unit tests for helper functions ───────────────────────────────\n\n    #[test]\n    fn status_color_maps_correctly() {\n        assert_eq!(\n            super::status_color(&SessionStatus::Idle),\n            ratatui::style::Color::Green\n        );\n        assert_eq!(\n            super::status_color(&SessionStatus::Running),\n            ratatui::style::Color::Red\n        );\n        assert_eq!(\n            super::status_color(&SessionStatus::Exited),\n            ratatui::style::Color::Yellow\n        );\n    }\n\n    #[test]\n    fn centered_rect_normal() {\n        let area = ratatui::layout::Rect::new(0, 0, 80, 24);\n        let result = super::centered_rect(40, 10, area);\n        assert_eq!(result.width, 40);\n        assert_eq!(result.height, 10);\n        assert_eq!(result.x, 20); // (80 - 40) / 2\n        assert_eq!(result.y, 7); // (24 - 10) / 2\n    }\n\n    #[test]\n    fn centered_rect_larger_than_area() {\n        let area = ratatui::layout::Rect::new(0, 0, 20, 10);\n        let result = super::centered_rect(40, 20, area);\n        // Width and height clamped to area\n        assert_eq!(result.width, 20);\n        assert_eq!(result.height, 10);\n    }\n\n    #[test]\n    fn centered_rect_with_offset() {\n        let area = ratatui::layout::Rect::new(10, 5, 60, 20);\n        let result = super::centered_rect(20, 10, area);\n        assert_eq!(result.x, 30); // 10 + (60-20)/2\n        assert_eq!(result.y, 10); // 5 + (20-10)/2\n    }\n\n    #[test]\n    fn centered_rect_zero_size_area() {\n        let area = ratatui::layout::Rect::new(0, 0, 0, 0);\n        let result = super::centered_rect(40, 10, area);\n        assert_eq!(result.width, 0);\n        assert_eq!(result.height, 0);\n    }\n\n    // ── format_compact_diff unit tests ──────────────────────────────\n\n    #[test]\n    fn format_compact_diff_both() {\n        assert_eq!(super::format_compact_diff(10, 5), \"+10-5\");\n    }\n\n    #[test]\n    fn format_compact_diff_insert_only() {\n        assert_eq!(super::format_compact_diff(7, 0), \"+7\");\n    }\n\n    #[test]\n    fn format_compact_diff_delete_only() {\n        assert_eq!(super::format_compact_diff(0, 3), \"-3\");\n    }\n\n    #[test]\n    fn format_compact_diff_zero() {\n        assert_eq!(super::format_compact_diff(0, 0), \"\");\n    }\n\n    // ── build_diff_tree_lines unit tests ─────────────────────────────\n\n    #[test]\n    fn diff_tree_empty() {\n        let lines = super::build_diff_tree_lines(&[], 40);\n        assert!(lines.is_empty());\n    }\n\n    #[test]\n    fn diff_tree_root_level_file() {\n        let files = vec![crate::app::DiffFile {\n            path: \"README.md\".into(),\n            insertions: 3,\n            deletions: 0,\n            untracked: false,\n        }];\n        let lines = super::build_diff_tree_lines(&files, 40);\n        assert_eq!(lines.len(), 1);\n    }\n\n    #[test]\n    fn diff_tree_with_directory() {\n        let files = vec![\n            crate::app::DiffFile {\n                path: \"src/app.rs\".into(),\n                insertions: 10,\n                deletions: 2,\n                untracked: false,\n            },\n            crate::app::DiffFile {\n                path: \"src/ui.rs\".into(),\n                insertions: 5,\n                deletions: 0,\n                untracked: false,\n            },\n        ];\n        let lines = super::build_diff_tree_lines(&files, 40);\n        // 1 directory header + 2 files\n        assert_eq!(lines.len(), 3);\n    }\n\n    #[test]\n    fn diff_tree_multiple_directories() {\n        let files = vec![\n            crate::app::DiffFile {\n                path: \"src/app.rs\".into(),\n                insertions: 1,\n                deletions: 0,\n                untracked: false,\n            },\n            crate::app::DiffFile {\n                path: \"tests/cli.rs\".into(),\n                insertions: 2,\n                deletions: 1,\n                untracked: false,\n            },\n        ];\n        let lines = super::build_diff_tree_lines(&files, 40);\n        // 2 directory headers + 2 files\n        assert_eq!(lines.len(), 4);\n    }\n\n    #[test]\n    fn diff_tree_deletion_only_file() {\n        let files = vec![crate::app::DiffFile {\n            path: \"old.rs\".into(),\n            insertions: 0,\n            deletions: 15,\n            untracked: false,\n        }];\n        let lines = super::build_diff_tree_lines(&files, 40);\n        assert_eq!(lines.len(), 1);\n    }\n\n    #[test]\n    fn diff_tree_narrow_width_truncates_name() {\n        let files = vec![crate::app::DiffFile {\n            path: \"src/very_long_filename_that_exceeds.rs\".into(),\n            insertions: 100,\n            deletions: 50,\n            untracked: false,\n        }];\n        let lines = super::build_diff_tree_lines(&files, 10);\n        assert!(!lines.is_empty());\n    }\n\n    #[test]\n    fn diff_tree_narrow_width_truncates_directory() {\n        let files = vec![crate::app::DiffFile {\n            path: \"very/deeply/nested/directory/structure/file.rs\".into(),\n            insertions: 1,\n            deletions: 0,\n            untracked: false,\n        }];\n        // inner_w = 11, dir \"very/deeply/nested/directory/structure/\" is 40 chars > 11\n        let lines = super::build_diff_tree_lines(&files, 12);\n        assert!(!lines.is_empty());\n    }\n\n    #[test]\n    fn diff_tree_zero_changes_file() {\n        let files = vec![crate::app::DiffFile {\n            path: \"unchanged.rs\".into(),\n            insertions: 0,\n            deletions: 0,\n            untracked: false,\n        }];\n        let lines = super::build_diff_tree_lines(&files, 40);\n        assert_eq!(lines.len(), 1);\n    }\n\n    #[test]\n    fn diff_tree_untracked_file() {\n        let files = vec![crate::app::DiffFile {\n            path: \"new_file.rs\".into(),\n            insertions: 0,\n            deletions: 0,\n            untracked: true,\n        }];\n        let lines = super::build_diff_tree_lines(&files, 40);\n        assert_eq!(lines.len(), 1);\n    }\n\n    #[test]\n    fn diff_tree_mixed_tracked_and_untracked() {\n        let files = vec![\n            crate::app::DiffFile {\n                path: \"src/app.rs\".into(),\n                insertions: 10,\n                deletions: 2,\n                untracked: false,\n            },\n            crate::app::DiffFile {\n                path: \"src/new.rs\".into(),\n                insertions: 0,\n                deletions: 0,\n                untracked: true,\n            },\n        ];\n        let lines = super::build_diff_tree_lines(&files, 40);\n        // 1 directory header + 2 files\n        assert_eq!(lines.len(), 3);\n    }\n\n    // ── Snapshot with deletion-only diff ─────────────────────────────\n\n    #[test]\n    fn browse_mode_with_deletion_only_diff() {\n        let backend = TestBackend::new(80, 24);\n        let mut terminal = Terminal::new(backend).unwrap();\n\n        let mut app = make_app();\n        app.sessions = vec![make_session(\"worker-1\", AgentType::Claude)];\n        app.selected = 0;\n        app.set_preview_text(\"preview content\".to_string());\n\n        let mut stats = crate::logs::SessionStats::default();\n        stats.turns = 5;\n        stats.tokens_in = 5000;\n        stats.tokens_out = 1000;\n        stats.edits = 2;\n        app.session_stats\n            .insert(\"hydra-testproj-worker-1\".to_string(), stats);\n\n        app.diff_files = vec![crate::app::DiffFile {\n            path: \"old.rs\".into(),\n            insertions: 0,\n            deletions: 20,\n            untracked: false,\n        }];\n\n        terminal.draw(|f| super::draw(f, &app)).unwrap();\n        let output = buffer_to_string(&terminal);\n\n        insta::assert_snapshot!(output);\n    }\n\n    #[test]\n    fn browse_mode_with_stats() {\n        let backend = TestBackend::new(80, 24);\n        let mut terminal = Terminal::new(backend).unwrap();\n\n        let mut app = make_app();\n        app.sessions = vec![make_session(\"worker-1\", AgentType::Claude)];\n        app.selected = 0;\n        app.set_preview_text(\"some preview content\".to_string());\n\n        // Populate global stats (machine-wide, drives stats block visibility)\n        app.global_stats.tokens_in = 28200;\n        app.global_stats.tokens_out = 6500;\n        app.global_stats.tokens_cache_read = 500;\n        app.global_stats.tokens_cache_write = 100;\n\n        // Per-session stats (edits are still hydra-specific)\n        let mut stats1 = crate::logs::SessionStats::default();\n        stats1.turns = 12;\n        stats1.edits = 5;\n        stats1.bash_cmds = 3;\n        app.session_stats\n            .insert(\"hydra-testproj-worker-1\".to_string(), stats1);\n\n        let mut stats2 = crate::logs::SessionStats::default();\n        stats2.turns = 8;\n        stats2.edits = 3;\n        stats2.bash_cmds = 2;\n        app.session_stats\n            .insert(\"hydra-testproj-worker-2\".to_string(), stats2);\n\n        // Per-file git diff stats\n        app.diff_files = vec![\n            crate::app::DiffFile {\n                path: \"src/app.rs\".into(),\n                insertions: 45,\n                deletions: 12,\n                untracked: false,\n            },\n            crate::app::DiffFile {\n                path: \"src/ui.rs\".into(),\n                insertions: 30,\n                deletions: 5,\n                untracked: false,\n            },\n            crate::app::DiffFile {\n                path: \"README.md\".into(),\n                insertions: 8,\n                deletions: 0,\n                untracked: false,\n            },\n            crate::app::DiffFile {\n                path: \"src/new_mod.rs\".into(),\n                insertions: 0,\n                deletions: 0,\n                untracked: true,\n            },\n        ];\n\n        terminal.draw(|f| super::draw(f, &app)).unwrap();\n        let output = buffer_to_string(&terminal);\n\n        insta::assert_snapshot!(output);\n    }\n\n    // ── diff tree resilience tests ──────────────────────────────────\n\n    #[test]\n    fn diff_tree_utf8_filename() {\n        // Non-ASCII filename that would panic with byte slicing\n        let files = vec![crate::app::DiffFile {\n            path: \"src/café.rs\".into(),\n            insertions: 5,\n            deletions: 2,\n            untracked: false,\n        }];\n        // Width narrow enough to force truncation\n        let lines = super::build_diff_tree_lines(&files, 10);\n        assert!(\n            !lines.is_empty(),\n            \"should produce lines for UTF-8 filenames\"\n        );\n    }\n\n    #[test]\n    fn diff_tree_width_zero() {\n        let files = vec![crate::app::DiffFile {\n            path: \"src/app.rs\".into(),\n            insertions: 1,\n            deletions: 0,\n            untracked: false,\n        }];\n        // width=0 should not panic\n        let lines = super::build_diff_tree_lines(&files, 0);\n        assert!(!lines.is_empty());\n    }\n\n    #[test]\n    fn diff_tree_width_one() {\n        let files = vec![crate::app::DiffFile {\n            path: \"src/app.rs\".into(),\n            insertions: 1,\n            deletions: 0,\n            untracked: false,\n        }];\n        // width=1 should not panic\n        let lines = super::build_diff_tree_lines(&files, 1);\n        assert!(!lines.is_empty());\n    }\n\n    #[test]\n    fn diff_tree_trailing_slash_path() {\n        let files = vec![crate::app::DiffFile {\n            path: \"src/\".into(),\n            insertions: 1,\n            deletions: 0,\n            untracked: false,\n        }];\n        // Trailing slash produces empty basename — should be skipped\n        let lines = super::build_diff_tree_lines(&files, 40);\n        assert!(lines.is_empty(), \"trailing-slash path should be skipped\");\n    }\n\n    #[test]\n    fn truncate_chars_ascii() {\n        assert_eq!(super::truncate_chars(\"hello\", 3), \"hel\");\n        assert_eq!(super::truncate_chars(\"hi\", 10), \"hi\");\n    }\n\n    #[test]\n    fn truncate_chars_unicode() {\n        assert_eq!(super::truncate_chars(\"café\", 3), \"caf\");\n        assert_eq!(super::truncate_chars(\"日本語テスト\", 3), \"日本語\");\n    }\n\n    #[test]\n    fn browse_mode_copy_mode_help_bar() {\n        let backend = TestBackend::new(80, 24);\n        let mut terminal = Terminal::new(backend).unwrap();\n\n        let mut app = make_app();\n        app.sessions = vec![make_session(\"s1\", AgentType::Claude)];\n        app.set_preview_text(\"test output\".to_string());\n        app.mouse_captured = false; // copy mode enabled\n\n        terminal.draw(|f| super::draw(f, &app)).unwrap();\n        let output = buffer_to_string(&terminal);\n\n        insta::assert_snapshot!(output);\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":16}},{"line":14,"address":[],"length":0,"stats":{"Line":48}},{"line":15,"address":[],"length":0,"stats":{"Line":48}},{"line":16,"address":[],"length":0,"stats":{"Line":32}},{"line":17,"address":[],"length":0,"stats":{"Line":48}},{"line":19,"address":[],"length":0,"stats":{"Line":32}},{"line":20,"address":[],"length":0,"stats":{"Line":32}},{"line":23,"address":[],"length":0,"stats":{"Line":48}},{"line":24,"address":[],"length":0,"stats":{"Line":48}},{"line":25,"address":[],"length":0,"stats":{"Line":32}},{"line":26,"address":[],"length":0,"stats":{"Line":32}},{"line":28,"address":[],"length":0,"stats":{"Line":48}},{"line":29,"address":[],"length":0,"stats":{"Line":48}},{"line":31,"address":[],"length":0,"stats":{"Line":64}},{"line":32,"address":[],"length":0,"stats":{"Line":64}},{"line":33,"address":[],"length":0,"stats":{"Line":64}},{"line":36,"address":[],"length":0,"stats":{"Line":16}},{"line":37,"address":[],"length":0,"stats":{"Line":6}},{"line":38,"address":[],"length":0,"stats":{"Line":6}},{"line":39,"address":[],"length":0,"stats":{"Line":12}},{"line":43,"address":[],"length":0,"stats":{"Line":32}},{"line":44,"address":[],"length":0,"stats":{"Line":32}},{"line":45,"address":[],"length":0,"stats":{"Line":24}},{"line":46,"address":[],"length":0,"stats":{"Line":5}},{"line":47,"address":[],"length":0,"stats":{"Line":3}},{"line":51,"address":[],"length":0,"stats":{"Line":16}},{"line":53,"address":[],"length":0,"stats":{"Line":32}},{"line":55,"address":[],"length":0,"stats":{"Line":48}},{"line":60,"address":[],"length":0,"stats":{"Line":32}},{"line":62,"address":[],"length":0,"stats":{"Line":48}},{"line":63,"address":[],"length":0,"stats":{"Line":46}},{"line":64,"address":[],"length":0,"stats":{"Line":80}},{"line":65,"address":[],"length":0,"stats":{"Line":64}},{"line":66,"address":[],"length":0,"stats":{"Line":16}},{"line":69,"address":[],"length":0,"stats":{"Line":48}},{"line":70,"address":[],"length":0,"stats":{"Line":32}},{"line":72,"address":[],"length":0,"stats":{"Line":48}},{"line":73,"address":[],"length":0,"stats":{"Line":48}},{"line":74,"address":[],"length":0,"stats":{"Line":14}},{"line":76,"address":[],"length":0,"stats":{"Line":6}},{"line":79,"address":[],"length":0,"stats":{"Line":48}},{"line":80,"address":[],"length":0,"stats":{"Line":48}},{"line":81,"address":[],"length":0,"stats":{"Line":32}},{"line":82,"address":[],"length":0,"stats":{"Line":32}},{"line":83,"address":[],"length":0,"stats":{"Line":16}},{"line":84,"address":[],"length":0,"stats":{"Line":16}},{"line":86,"address":[],"length":0,"stats":{"Line":32}},{"line":88,"address":[],"length":0,"stats":{"Line":32}},{"line":89,"address":[],"length":0,"stats":{"Line":32}},{"line":90,"address":[],"length":0,"stats":{"Line":32}},{"line":97,"address":[],"length":0,"stats":{"Line":32}},{"line":98,"address":[],"length":0,"stats":{"Line":32}},{"line":99,"address":[],"length":0,"stats":{"Line":48}},{"line":100,"address":[],"length":0,"stats":{"Line":48}},{"line":101,"address":[],"length":0,"stats":{"Line":48}},{"line":103,"address":[],"length":0,"stats":{"Line":64}},{"line":104,"address":[],"length":0,"stats":{"Line":48}},{"line":105,"address":[],"length":0,"stats":{"Line":29}},{"line":106,"address":[],"length":0,"stats":{"Line":26}},{"line":108,"address":[],"length":0,"stats":{"Line":39}},{"line":109,"address":[],"length":0,"stats":{"Line":52}},{"line":110,"address":[],"length":0,"stats":{"Line":39}},{"line":111,"address":[],"length":0,"stats":{"Line":78}},{"line":112,"address":[],"length":0,"stats":{"Line":78}},{"line":113,"address":[],"length":0,"stats":{"Line":39}},{"line":114,"address":[],"length":0,"stats":{"Line":52}},{"line":115,"address":[],"length":0,"stats":{"Line":65}},{"line":116,"address":[],"length":0,"stats":{"Line":52}},{"line":117,"address":[],"length":0,"stats":{"Line":52}},{"line":119,"address":[],"length":0,"stats":{"Line":52}},{"line":122,"address":[],"length":0,"stats":{"Line":27}},{"line":123,"address":[],"length":0,"stats":{"Line":11}},{"line":126,"address":[],"length":0,"stats":{"Line":48}},{"line":127,"address":[],"length":0,"stats":{"Line":32}},{"line":128,"address":[],"length":0,"stats":{"Line":11}},{"line":129,"address":[],"length":0,"stats":{"Line":22}},{"line":130,"address":[],"length":0,"stats":{"Line":11}},{"line":132,"address":[],"length":0,"stats":{"Line":5}},{"line":134,"address":[],"length":0,"stats":{"Line":32}},{"line":135,"address":[],"length":0,"stats":{"Line":48}},{"line":136,"address":[],"length":0,"stats":{"Line":80}},{"line":137,"address":[],"length":0,"stats":{"Line":16}},{"line":138,"address":[],"length":0,"stats":{"Line":16}},{"line":139,"address":[],"length":0,"stats":{"Line":16}},{"line":142,"address":[],"length":0,"stats":{"Line":18}},{"line":143,"address":[],"length":0,"stats":{"Line":4}},{"line":144,"address":[],"length":0,"stats":{"Line":3}},{"line":145,"address":[],"length":0,"stats":{"Line":1}},{"line":148,"address":[],"length":0,"stats":{"Line":34}},{"line":149,"address":[],"length":0,"stats":{"Line":2}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":64}},{"line":157,"address":[],"length":0,"stats":{"Line":34}},{"line":158,"address":[],"length":0,"stats":{"Line":4}},{"line":159,"address":[],"length":0,"stats":{"Line":6}},{"line":160,"address":[],"length":0,"stats":{"Line":6}},{"line":161,"address":[],"length":0,"stats":{"Line":1}},{"line":163,"address":[],"length":0,"stats":{"Line":1}},{"line":165,"address":[],"length":0,"stats":{"Line":12}},{"line":167,"address":[],"length":0,"stats":{"Line":64}},{"line":170,"address":[],"length":0,"stats":{"Line":48}},{"line":171,"address":[],"length":0,"stats":{"Line":32}},{"line":172,"address":[],"length":0,"stats":{"Line":48}},{"line":174,"address":[],"length":0,"stats":{"Line":16}},{"line":175,"address":[],"length":0,"stats":{"Line":16}},{"line":176,"address":[],"length":0,"stats":{"Line":32}},{"line":177,"address":[],"length":0,"stats":{"Line":64}},{"line":179,"address":[],"length":0,"stats":{"Line":32}},{"line":183,"address":[],"length":0,"stats":{"Line":32}},{"line":184,"address":[],"length":0,"stats":{"Line":48}},{"line":185,"address":[],"length":0,"stats":{"Line":80}},{"line":188,"address":[],"length":0,"stats":{"Line":17}},{"line":189,"address":[],"length":0,"stats":{"Line":3}},{"line":193,"address":[],"length":0,"stats":{"Line":18}},{"line":194,"address":[],"length":0,"stats":{"Line":6}},{"line":199,"address":[],"length":0,"stats":{"Line":11}},{"line":200,"address":[],"length":0,"stats":{"Line":55}},{"line":210,"address":[],"length":0,"stats":{"Line":30}},{"line":214,"address":[],"length":0,"stats":{"Line":60}},{"line":215,"address":[],"length":0,"stats":{"Line":15}},{"line":218,"address":[],"length":0,"stats":{"Line":60}},{"line":219,"address":[],"length":0,"stats":{"Line":60}},{"line":220,"address":[],"length":0,"stats":{"Line":60}},{"line":222,"address":[],"length":0,"stats":{"Line":75}},{"line":223,"address":[],"length":0,"stats":{"Line":54}},{"line":225,"address":[],"length":0,"stats":{"Line":45}},{"line":226,"address":[],"length":0,"stats":{"Line":45}},{"line":227,"address":[],"length":0,"stats":{"Line":45}},{"line":229,"address":[],"length":0,"stats":{"Line":36}},{"line":230,"address":[],"length":0,"stats":{"Line":63}},{"line":231,"address":[],"length":0,"stats":{"Line":45}},{"line":232,"address":[],"length":0,"stats":{"Line":12}},{"line":236,"address":[],"length":0,"stats":{"Line":42}},{"line":237,"address":[],"length":0,"stats":{"Line":1}},{"line":241,"address":[],"length":0,"stats":{"Line":80}},{"line":242,"address":[],"length":0,"stats":{"Line":40}},{"line":243,"address":[],"length":0,"stats":{"Line":10}},{"line":244,"address":[],"length":0,"stats":{"Line":30}},{"line":246,"address":[],"length":0,"stats":{"Line":20}},{"line":247,"address":[],"length":0,"stats":{"Line":20}},{"line":248,"address":[],"length":0,"stats":{"Line":50}},{"line":249,"address":[],"length":0,"stats":{"Line":9}},{"line":251,"address":[],"length":0,"stats":{"Line":14}},{"line":253,"address":[],"length":0,"stats":{"Line":40}},{"line":254,"address":[],"length":0,"stats":{"Line":10}},{"line":255,"address":[],"length":0,"stats":{"Line":10}},{"line":258,"address":[],"length":0,"stats":{"Line":10}},{"line":262,"address":[],"length":0,"stats":{"Line":40}},{"line":263,"address":[],"length":0,"stats":{"Line":6}},{"line":265,"address":[],"length":0,"stats":{"Line":51}},{"line":267,"address":[],"length":0,"stats":{"Line":80}},{"line":270,"address":[],"length":0,"stats":{"Line":60}},{"line":271,"address":[],"length":0,"stats":{"Line":60}},{"line":272,"address":[],"length":0,"stats":{"Line":80}},{"line":274,"address":[],"length":0,"stats":{"Line":80}},{"line":275,"address":[],"length":0,"stats":{"Line":60}},{"line":276,"address":[],"length":0,"stats":{"Line":3}},{"line":277,"address":[],"length":0,"stats":{"Line":21}},{"line":278,"address":[],"length":0,"stats":{"Line":12}},{"line":279,"address":[],"length":0,"stats":{"Line":14}},{"line":280,"address":[],"length":0,"stats":{"Line":3}},{"line":282,"address":[],"length":0,"stats":{"Line":26}},{"line":285,"address":[],"length":0,"stats":{"Line":60}},{"line":286,"address":[],"length":0,"stats":{"Line":80}},{"line":287,"address":[],"length":0,"stats":{"Line":100}},{"line":289,"address":[],"length":0,"stats":{"Line":60}},{"line":290,"address":[],"length":0,"stats":{"Line":20}},{"line":291,"address":[],"length":0,"stats":{"Line":20}},{"line":294,"address":[],"length":0,"stats":{"Line":23}},{"line":295,"address":[],"length":0,"stats":{"Line":9}},{"line":297,"address":[],"length":0,"stats":{"Line":31}},{"line":298,"address":[],"length":0,"stats":{"Line":56}},{"line":300,"address":[],"length":0,"stats":{"Line":26}},{"line":301,"address":[],"length":0,"stats":{"Line":36}},{"line":305,"address":[],"length":0,"stats":{"Line":80}},{"line":308,"address":[],"length":0,"stats":{"Line":15}},{"line":312,"address":[],"length":0,"stats":{"Line":21}},{"line":313,"address":[],"length":0,"stats":{"Line":21}},{"line":314,"address":[],"length":0,"stats":{"Line":8}},{"line":315,"address":[],"length":0,"stats":{"Line":8}},{"line":316,"address":[],"length":0,"stats":{"Line":3}},{"line":317,"address":[],"length":0,"stats":{"Line":2}},{"line":321,"address":[],"length":0,"stats":{"Line":2}},{"line":322,"address":[],"length":0,"stats":{"Line":4}},{"line":323,"address":[],"length":0,"stats":{"Line":2}},{"line":325,"address":[],"length":0,"stats":{"Line":8}},{"line":327,"address":[],"length":0,"stats":{"Line":8}},{"line":328,"address":[],"length":0,"stats":{"Line":8}},{"line":331,"address":[],"length":0,"stats":{"Line":4}},{"line":332,"address":[],"length":0,"stats":{"Line":10}},{"line":333,"address":[],"length":0,"stats":{"Line":8}},{"line":335,"address":[],"length":0,"stats":{"Line":6}},{"line":336,"address":[],"length":0,"stats":{"Line":8}},{"line":339,"address":[],"length":0,"stats":{"Line":1}},{"line":341,"address":[],"length":0,"stats":{"Line":3}},{"line":342,"address":[],"length":0,"stats":{"Line":2}},{"line":345,"address":[],"length":0,"stats":{"Line":6}},{"line":347,"address":[],"length":0,"stats":{"Line":2}},{"line":350,"address":[],"length":0,"stats":{"Line":3}},{"line":351,"address":[],"length":0,"stats":{"Line":1}},{"line":353,"address":[],"length":0,"stats":{"Line":9}},{"line":356,"address":[],"length":0,"stats":{"Line":2}},{"line":357,"address":[],"length":0,"stats":{"Line":6}},{"line":358,"address":[],"length":0,"stats":{"Line":5}},{"line":359,"address":[],"length":0,"stats":{"Line":3}},{"line":362,"address":[],"length":0,"stats":{"Line":2}},{"line":363,"address":[],"length":0,"stats":{"Line":4}},{"line":366,"address":[],"length":0,"stats":{"Line":3}},{"line":368,"address":[],"length":0,"stats":{"Line":2}},{"line":369,"address":[],"length":0,"stats":{"Line":1}},{"line":371,"address":[],"length":0,"stats":{"Line":4}},{"line":373,"address":[],"length":0,"stats":{"Line":5}},{"line":374,"address":[],"length":0,"stats":{"Line":4}},{"line":377,"address":[],"length":0,"stats":{"Line":16}},{"line":378,"address":[],"length":0,"stats":{"Line":59}},{"line":379,"address":[],"length":0,"stats":{"Line":11}},{"line":381,"address":[],"length":0,"stats":{"Line":10}},{"line":384,"address":[],"length":0,"stats":{"Line":32}},{"line":385,"address":[],"length":0,"stats":{"Line":64}},{"line":386,"address":[],"length":0,"stats":{"Line":2}},{"line":387,"address":[],"length":0,"stats":{"Line":2}},{"line":388,"address":[],"length":0,"stats":{"Line":1}},{"line":391,"address":[],"length":0,"stats":{"Line":2}},{"line":392,"address":[],"length":0,"stats":{"Line":4}},{"line":393,"address":[],"length":0,"stats":{"Line":1}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":2}},{"line":399,"address":[],"length":0,"stats":{"Line":1}},{"line":400,"address":[],"length":0,"stats":{"Line":1}},{"line":401,"address":[],"length":0,"stats":{"Line":2}},{"line":402,"address":[],"length":0,"stats":{"Line":2}},{"line":403,"address":[],"length":0,"stats":{"Line":2}},{"line":404,"address":[],"length":0,"stats":{"Line":1}},{"line":407,"address":[],"length":0,"stats":{"Line":3}},{"line":408,"address":[],"length":0,"stats":{"Line":2}},{"line":409,"address":[],"length":0,"stats":{"Line":1}},{"line":410,"address":[],"length":0,"stats":{"Line":1}},{"line":411,"address":[],"length":0,"stats":{"Line":2}},{"line":412,"address":[],"length":0,"stats":{"Line":2}},{"line":413,"address":[],"length":0,"stats":{"Line":1}},{"line":416,"address":[],"length":0,"stats":{"Line":1}},{"line":417,"address":[],"length":0,"stats":{"Line":2}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":60}},{"line":425,"address":[],"length":0,"stats":{"Line":48}},{"line":426,"address":[],"length":0,"stats":{"Line":32}},{"line":427,"address":[],"length":0,"stats":{"Line":64}},{"line":428,"address":[],"length":0,"stats":{"Line":64}},{"line":429,"address":[],"length":0,"stats":{"Line":64}},{"line":431,"address":[],"length":0,"stats":{"Line":64}},{"line":433,"address":[],"length":0,"stats":{"Line":16}},{"line":434,"address":[],"length":0,"stats":{"Line":16}},{"line":435,"address":[],"length":0,"stats":{"Line":32}},{"line":436,"address":[],"length":0,"stats":{"Line":32}},{"line":437,"address":[],"length":0,"stats":{"Line":32}},{"line":439,"address":[],"length":0,"stats":{"Line":32}},{"line":441,"address":[],"length":0,"stats":{"Line":64}},{"line":444,"address":[],"length":0,"stats":{"Line":16}},{"line":445,"address":[],"length":0,"stats":{"Line":27}},{"line":446,"address":[],"length":0,"stats":{"Line":2}},{"line":447,"address":[],"length":0,"stats":{"Line":10}},{"line":448,"address":[],"length":0,"stats":{"Line":1}},{"line":449,"address":[],"length":0,"stats":{"Line":2}},{"line":450,"address":[],"length":0,"stats":{"Line":2}},{"line":453,"address":[],"length":0,"stats":{"Line":33}},{"line":454,"address":[],"length":0,"stats":{"Line":1}},{"line":456,"address":[],"length":0,"stats":{"Line":15}},{"line":459,"address":[],"length":0,"stats":{"Line":64}},{"line":460,"address":[],"length":0,"stats":{"Line":16}},{"line":461,"address":[],"length":0,"stats":{"Line":16}},{"line":462,"address":[],"length":0,"stats":{"Line":32}},{"line":463,"address":[],"length":0,"stats":{"Line":32}},{"line":464,"address":[],"length":0,"stats":{"Line":16}},{"line":467,"address":[],"length":0,"stats":{"Line":64}},{"line":470,"address":[],"length":0,"stats":{"Line":8}},{"line":471,"address":[],"length":0,"stats":{"Line":32}},{"line":472,"address":[],"length":0,"stats":{"Line":32}},{"line":473,"address":[],"length":0,"stats":{"Line":72}},{"line":476,"address":[],"length":0,"stats":{"Line":2}},{"line":477,"address":[],"length":0,"stats":{"Line":6}},{"line":479,"address":[],"length":0,"stats":{"Line":6}},{"line":480,"address":[],"length":0,"stats":{"Line":6}},{"line":481,"address":[],"length":0,"stats":{"Line":6}},{"line":482,"address":[],"length":0,"stats":{"Line":6}},{"line":486,"address":[],"length":0,"stats":{"Line":2}},{"line":487,"address":[],"length":0,"stats":{"Line":4}},{"line":488,"address":[],"length":0,"stats":{"Line":4}},{"line":489,"address":[],"length":0,"stats":{"Line":10}},{"line":490,"address":[],"length":0,"stats":{"Line":8}},{"line":492,"address":[],"length":0,"stats":{"Line":6}},{"line":495,"address":[],"length":0,"stats":{"Line":6}},{"line":496,"address":[],"length":0,"stats":{"Line":8}},{"line":497,"address":[],"length":0,"stats":{"Line":2}},{"line":499,"address":[],"length":0,"stats":{"Line":2}},{"line":501,"address":[],"length":0,"stats":{"Line":8}},{"line":502,"address":[],"length":0,"stats":{"Line":8}},{"line":503,"address":[],"length":0,"stats":{"Line":2}},{"line":504,"address":[],"length":0,"stats":{"Line":4}},{"line":505,"address":[],"length":0,"stats":{"Line":2}},{"line":507,"address":[],"length":0,"stats":{"Line":2}},{"line":509,"address":[],"length":0,"stats":{"Line":20}},{"line":513,"address":[],"length":0,"stats":{"Line":8}},{"line":514,"address":[],"length":0,"stats":{"Line":2}},{"line":515,"address":[],"length":0,"stats":{"Line":2}},{"line":516,"address":[],"length":0,"stats":{"Line":2}},{"line":517,"address":[],"length":0,"stats":{"Line":8}},{"line":519,"address":[],"length":0,"stats":{"Line":8}},{"line":522,"address":[],"length":0,"stats":{"Line":2}},{"line":523,"address":[],"length":0,"stats":{"Line":8}},{"line":524,"address":[],"length":0,"stats":{"Line":8}},{"line":526,"address":[],"length":0,"stats":{"Line":6}},{"line":527,"address":[],"length":0,"stats":{"Line":4}},{"line":528,"address":[],"length":0,"stats":{"Line":2}},{"line":529,"address":[],"length":0,"stats":{"Line":4}},{"line":532,"address":[],"length":0,"stats":{"Line":4}},{"line":533,"address":[],"length":0,"stats":{"Line":8}},{"line":534,"address":[],"length":0,"stats":{"Line":2}},{"line":535,"address":[],"length":0,"stats":{"Line":2}},{"line":536,"address":[],"length":0,"stats":{"Line":2}},{"line":537,"address":[],"length":0,"stats":{"Line":8}},{"line":539,"address":[],"length":0,"stats":{"Line":8}}],"covered":318,"coverable":323}],"coverage":82.50283125707814,"covered":1457,"coverable":1766}