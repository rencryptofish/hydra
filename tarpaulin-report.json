{"files":[{"path":["/","Users","cat","hydra","src","app.rs"],"content":"use std::cell::Cell;\nuse std::collections::HashMap;\nuse std::time::Instant;\n\nuse crossterm::event::{MouseEvent, MouseEventKind};\nuse ratatui::layout::{Position, Rect};\n\nuse crate::session::{AgentType, Session, SessionStatus};\nuse crate::tmux::{SessionManager, TmuxSessionManager};\n\n#[derive(Debug, Clone, PartialEq)]\npub enum Mode {\n    Browse,\n    Attached,\n    NewSessionAgent,\n    ConfirmDelete,\n}\n\npub struct App {\n    pub sessions: Vec<Session>,\n    pub selected: usize,\n    pub preview: String,\n    pub mode: Mode,\n    pub agent_selection: usize,\n    pub should_quit: bool,\n    pub project_id: String,\n    pub cwd: String,\n    pub status_message: Option<String>,\n    pub sidebar_area: Cell<Rect>,\n    pub preview_area: Cell<Rect>,\n    pub preview_scroll_offset: u16,\n    prev_captures: HashMap<String, String>,\n    task_starts: HashMap<String, Instant>,\n    task_last_active: HashMap<String, Instant>,\n    pub last_messages: HashMap<String, String>,\n    log_uuids: HashMap<String, String>,\n    message_tick: u8,\n    manager: Box<dyn SessionManager>,\n}\n\nimpl App {\n    pub fn new(project_id: String, cwd: String) -> Self {\n        Self::new_with_manager(project_id, cwd, Box::new(TmuxSessionManager::new()))\n    }\n\n    pub fn new_with_manager(\n        project_id: String,\n        cwd: String,\n        manager: Box<dyn SessionManager>,\n    ) -> Self {\n        Self {\n            sessions: Vec::new(),\n            selected: 0,\n            preview: String::new(),\n            mode: Mode::Browse,\n            agent_selection: 0,\n            should_quit: false,\n            project_id,\n            cwd,\n            status_message: None,\n            sidebar_area: Cell::new(Rect::default()),\n            preview_area: Cell::new(Rect::default()),\n            preview_scroll_offset: 0,\n            prev_captures: HashMap::new(),\n            task_starts: HashMap::new(),\n            task_last_active: HashMap::new(),\n            last_messages: HashMap::new(),\n            log_uuids: HashMap::new(),\n            message_tick: 0,\n            manager,\n        }\n    }\n\n    pub async fn refresh_sessions(&mut self) {\n        let pid = self.project_id.clone();\n        let result = self.manager.list_sessions(&pid).await;\n        match result {\n            Ok(mut sessions) => {\n                let now = Instant::now();\n\n                for session in &mut sessions {\n                    let name = session.tmux_name.clone();\n\n                    // Determine Running vs Idle by comparing pane content\n                    if session.status != SessionStatus::Exited {\n                        let content = self\n                            .manager\n                            .capture_pane(&name)\n                            .await\n                            .unwrap_or_default();\n                        let prev = self.prev_captures.get(&name);\n                        session.status = if prev.is_some_and(|p| p == &content) {\n                            SessionStatus::Idle\n                        } else {\n                            SessionStatus::Running\n                        };\n                        self.prev_captures.insert(name.clone(), content);\n                    }\n\n                    // Track task elapsed time\n                    match session.status {\n                        SessionStatus::Running => {\n                            self.task_starts.entry(name.clone()).or_insert(now);\n                            self.task_last_active.insert(name.clone(), now);\n                            let start = self.task_starts[&name];\n                            session.task_elapsed = Some(now.duration_since(start));\n                        }\n                        SessionStatus::Idle => {\n                            if let (Some(&start), Some(&last)) = (\n                                self.task_starts.get(&name),\n                                self.task_last_active.get(&name),\n                            ) {\n                                if now.duration_since(last).as_secs() < 5 {\n                                    // Brief pause — show frozen duration from last activity\n                                    session.task_elapsed = Some(last.duration_since(start));\n                                } else {\n                                    // Task is done — clear timer\n                                    self.task_starts.remove(&name);\n                                    self.task_last_active.remove(&name);\n                                }\n                            }\n                        }\n                        SessionStatus::Exited => {\n                            self.task_starts.remove(&name);\n                            self.task_last_active.remove(&name);\n                        }\n                    }\n                }\n                self.sessions = sessions;\n            }\n            Err(e) => {\n                self.status_message = Some(format!(\"Error listing sessions: {e}\"));\n            }\n        }\n        // Keep selected index in bounds\n        if self.selected >= self.sessions.len() && !self.sessions.is_empty() {\n            self.selected = self.sessions.len() - 1;\n        }\n    }\n\n    pub async fn refresh_preview(&mut self) {\n        let tmux_name = self\n            .sessions\n            .get(self.selected)\n            .map(|s| s.tmux_name.clone());\n        if let Some(tmux_name) = tmux_name {\n            let result = self.manager.capture_pane_scrollback(&tmux_name).await;\n            match result {\n                Ok(content) => self.preview = content,\n                Err(_) => self.preview = String::from(\"[unable to capture pane]\"),\n            }\n        } else {\n            self.preview = String::from(\"No sessions. Press 'n' to create one.\");\n        }\n    }\n\n    pub async fn refresh_messages(&mut self) {\n        self.message_tick = self.message_tick.wrapping_add(1);\n        // Run every 20 ticks (~5 seconds at 250ms interval)\n        if self.message_tick % 20 != 0 {\n            return;\n        }\n\n        for session in &self.sessions {\n            let tmux_name = &session.tmux_name;\n\n            // Try to resolve UUID if not cached\n            if !self.log_uuids.contains_key(tmux_name) {\n                if let Some(uuid) = crate::logs::resolve_session_uuid(tmux_name).await {\n                    self.log_uuids.insert(tmux_name.clone(), uuid);\n                }\n            }\n\n            // Read last message if UUID is known\n            if let Some(uuid) = self.log_uuids.get(tmux_name).cloned() {\n                if let Some(msg) = crate::logs::read_last_assistant_message(&self.cwd, &uuid) {\n                    self.last_messages.insert(tmux_name.clone(), msg);\n                }\n            }\n        }\n    }\n\n    pub fn select_next(&mut self) {\n        if !self.sessions.is_empty() {\n            self.selected = (self.selected + 1) % self.sessions.len();\n            self.preview_scroll_offset = 0;\n        }\n    }\n\n    pub fn select_prev(&mut self) {\n        if !self.sessions.is_empty() {\n            self.selected = if self.selected == 0 {\n                self.sessions.len() - 1\n            } else {\n                self.selected - 1\n            };\n            self.preview_scroll_offset = 0;\n        }\n    }\n\n    pub fn scroll_preview_up(&mut self) {\n        self.preview_scroll_offset = self.preview_scroll_offset.saturating_add(3);\n    }\n\n    pub fn scroll_preview_down(&mut self) {\n        self.preview_scroll_offset = self.preview_scroll_offset.saturating_sub(3);\n    }\n\n    pub fn attach_selected(&mut self) {\n        if !self.sessions.is_empty() {\n            self.mode = Mode::Attached;\n        }\n    }\n\n    pub fn detach(&mut self) {\n        self.mode = Mode::Browse;\n    }\n\n    pub fn start_new_session(&mut self) {\n        self.mode = Mode::NewSessionAgent;\n        self.agent_selection = 0;\n        self.status_message = None;\n    }\n\n    pub async fn confirm_new_session(&mut self) {\n        let agents = AgentType::all();\n        let agent = agents[self.agent_selection].clone();\n        let existing: Vec<String> = self.sessions.iter().map(|s| s.name.clone()).collect();\n        let name = crate::session::generate_name(&existing);\n        let pid = self.project_id.clone();\n        let cwd = self.cwd.clone();\n\n        let result = self.manager.create_session(&pid, &name, &agent, &cwd).await;\n        match result {\n            Ok(_) => {\n                self.status_message = Some(format!(\n                    \"Created session '{}' with {}\",\n                    name, agent\n                ));\n                self.refresh_sessions().await;\n                if let Some(idx) = self.sessions.iter().position(|s| s.name == name) {\n                    self.selected = idx;\n                }\n            }\n            Err(e) => {\n                self.status_message = Some(format!(\"Failed to create session: {e}\"));\n            }\n        }\n        self.mode = Mode::Browse;\n    }\n\n    pub fn request_delete(&mut self) {\n        if !self.sessions.is_empty() {\n            self.mode = Mode::ConfirmDelete;\n            self.status_message = None;\n        }\n    }\n\n    pub async fn confirm_delete(&mut self) {\n        if let Some(session) = self.sessions.get(self.selected) {\n            let name = session.name.clone();\n            let tmux_name = session.tmux_name.clone();\n            let result = self.manager.kill_session(&tmux_name).await;\n            match result {\n                Ok(_) => {\n                    self.status_message = Some(format!(\"Killed session '{name}'\"));\n                }\n                Err(e) => {\n                    self.status_message = Some(format!(\"Failed to kill session: {e}\"));\n                }\n            }\n        }\n        self.mode = Mode::Browse;\n        self.refresh_sessions().await;\n    }\n\n    pub fn cancel_mode(&mut self) {\n        self.mode = Mode::Browse;\n        self.status_message = None;\n    }\n\n    pub fn handle_mouse(&mut self, mouse: MouseEvent) {\n        let pos = Position::new(mouse.column, mouse.row);\n        let sidebar = self.sidebar_area.get();\n        let preview = self.preview_area.get();\n\n        fn inner(r: Rect) -> Rect {\n            if r.width < 2 || r.height < 2 {\n                Rect::default()\n            } else {\n                Rect::new(r.x + 1, r.y + 1, r.width - 2, r.height - 2)\n            }\n        }\n\n        match self.mode {\n            Mode::Browse => match mouse.kind {\n                MouseEventKind::Down(_) => {\n                    let sidebar_inner = inner(sidebar);\n                    if sidebar_inner.contains(pos) {\n                        let row_offset = (mouse.row - sidebar_inner.y) as usize;\n                        let mut cumulative = 0usize;\n                        let mut target_idx = None;\n                        for (i, session) in self.sessions.iter().enumerate() {\n                            let item_height =\n                                if self.last_messages.contains_key(&session.tmux_name) {\n                                    2\n                                } else {\n                                    1\n                                };\n                            if row_offset < cumulative + item_height {\n                                target_idx = Some(i);\n                                break;\n                            }\n                            cumulative += item_height;\n                        }\n                        if let Some(idx) = target_idx {\n                            if self.selected != idx {\n                                self.selected = idx;\n                                self.preview_scroll_offset = 0;\n                            }\n                        }\n                    } else if preview.contains(pos) {\n                        self.attach_selected();\n                    }\n                }\n                MouseEventKind::ScrollUp => {\n                    if preview.contains(pos) {\n                        self.scroll_preview_up();\n                    } else if sidebar.contains(pos) {\n                        self.select_prev();\n                    }\n                }\n                MouseEventKind::ScrollDown => {\n                    if preview.contains(pos) {\n                        self.scroll_preview_down();\n                    } else if sidebar.contains(pos) {\n                        self.select_next();\n                    }\n                }\n                _ => {}\n            },\n            Mode::Attached => match mouse.kind {\n                MouseEventKind::ScrollUp => {\n                    if preview.contains(pos) {\n                        self.scroll_preview_up();\n                    }\n                }\n                MouseEventKind::ScrollDown => {\n                    if preview.contains(pos) {\n                        self.scroll_preview_down();\n                    }\n                }\n                MouseEventKind::Down(_) => {\n                    if !inner(preview).contains(pos) {\n                        self.detach();\n                    }\n                }\n                _ => {}\n            },\n            _ => {}\n        }\n    }\n\n    pub fn agent_select_next(&mut self) {\n        let count = AgentType::all().len();\n        self.agent_selection = (self.agent_selection + 1) % count;\n    }\n\n    pub fn agent_select_prev(&mut self) {\n        let count = AgentType::all().len();\n        self.agent_selection = if self.agent_selection == 0 {\n            count - 1\n        } else {\n            self.agent_selection - 1\n        };\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::session::{AgentType, Session};\n    use crate::tmux::SessionManager;\n\n    // ── Mock and helpers ─────────────────────────────────────────────\n\n    struct MockSessionManager {\n        sessions: Vec<Session>,\n        create_result: Result<String, String>,\n    }\n\n    impl MockSessionManager {\n        fn new() -> Self {\n            Self {\n                sessions: vec![],\n                create_result: Ok(\"mock-session\".to_string()),\n            }\n        }\n        fn with_sessions(sessions: Vec<Session>) -> Self {\n            Self {\n                sessions,\n                create_result: Ok(\"mock-session\".to_string()),\n            }\n        }\n    }\n\n    #[async_trait::async_trait]\n    impl SessionManager for MockSessionManager {\n        async fn list_sessions(&self, _project_id: &str) -> anyhow::Result<Vec<Session>> {\n            Ok(self.sessions.clone())\n        }\n        async fn create_session(\n            &self,\n            _project_id: &str,\n            _name: &str,\n            _agent: &AgentType,\n            _cwd: &str,\n        ) -> anyhow::Result<String> {\n            self.create_result.clone().map_err(|e| anyhow::anyhow!(e))\n        }\n        async fn capture_pane(&self, _tmux_name: &str) -> anyhow::Result<String> {\n            Ok(\"mock pane content\".to_string())\n        }\n        async fn kill_session(&self, _tmux_name: &str) -> anyhow::Result<()> {\n            Ok(())\n        }\n        async fn send_keys(&self, _tmux_name: &str, _key: &str) -> anyhow::Result<()> {\n            Ok(())\n        }\n        async fn send_mouse(\n            &self,\n            _tmux_name: &str,\n            _kind: &str,\n            _button: u8,\n            _x: u16,\n            _y: u16,\n        ) -> anyhow::Result<()> {\n            Ok(())\n        }\n        async fn capture_pane_scrollback(&self, _tmux_name: &str) -> anyhow::Result<String> {\n            Ok(\"mock pane content\".to_string())\n        }\n    }\n\n    fn test_app() -> App {\n        App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(MockSessionManager::new()),\n        )\n    }\n\n    fn test_app_with_sessions(sessions: Vec<Session>) -> App {\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(MockSessionManager::with_sessions(sessions.clone())),\n        );\n        app.sessions = sessions;\n        app\n    }\n\n    fn make_session(name: &str, agent: AgentType) -> Session {\n        Session {\n            name: name.to_string(),\n            tmux_name: format!(\"hydra-testid-{name}\"),\n            agent_type: agent,\n            status: crate::session::SessionStatus::Idle,\n            task_elapsed: None,\n            _alive: true,\n        }\n    }\n\n    // ── Navigation tests ─────────────────────────────────────────────\n\n    #[test]\n    fn select_next_wraps_around() {\n        let sessions = vec![\n            make_session(\"a\", AgentType::Claude),\n            make_session(\"b\", AgentType::Claude),\n            make_session(\"c\", AgentType::Claude),\n        ];\n        let mut app = test_app_with_sessions(sessions);\n        app.selected = 2; // last item\n        app.select_next();\n        assert_eq!(app.selected, 0, \"select_next should wrap from last to first\");\n    }\n\n    #[test]\n    fn select_prev_wraps_around() {\n        let sessions = vec![\n            make_session(\"a\", AgentType::Claude),\n            make_session(\"b\", AgentType::Claude),\n            make_session(\"c\", AgentType::Claude),\n        ];\n        let mut app = test_app_with_sessions(sessions);\n        app.selected = 0; // first item\n        app.select_prev();\n        assert_eq!(app.selected, 2, \"select_prev should wrap from first to last\");\n    }\n\n    #[test]\n    fn select_next_with_empty_sessions_does_nothing() {\n        let mut app = test_app();\n        assert!(app.sessions.is_empty());\n        app.selected = 0;\n        app.select_next();\n        assert_eq!(\n            app.selected, 0,\n            \"select_next on empty sessions should not change selected\"\n        );\n    }\n\n    #[test]\n    fn select_prev_with_empty_sessions_does_nothing() {\n        let mut app = test_app();\n        assert!(app.sessions.is_empty());\n        app.selected = 0;\n        app.select_prev();\n        assert_eq!(\n            app.selected, 0,\n            \"select_prev on empty sessions should not change selected\"\n        );\n    }\n\n    #[test]\n    fn select_next_updates_index_correctly() {\n        let sessions = vec![\n            make_session(\"a\", AgentType::Claude),\n            make_session(\"b\", AgentType::Claude),\n            make_session(\"c\", AgentType::Claude),\n        ];\n        let mut app = test_app_with_sessions(sessions);\n        assert_eq!(app.selected, 0);\n        app.select_next();\n        assert_eq!(app.selected, 1);\n        app.select_next();\n        assert_eq!(app.selected, 2);\n    }\n\n    #[test]\n    fn select_prev_updates_index_correctly() {\n        let sessions = vec![\n            make_session(\"a\", AgentType::Claude),\n            make_session(\"b\", AgentType::Claude),\n            make_session(\"c\", AgentType::Claude),\n        ];\n        let mut app = test_app_with_sessions(sessions);\n        app.selected = 2;\n        app.select_prev();\n        assert_eq!(app.selected, 1);\n        app.select_prev();\n        assert_eq!(app.selected, 0);\n    }\n\n    // ── Mode transition tests ────────────────────────────────────────\n\n    #[test]\n    fn start_new_session_goes_to_agent_select() {\n        let mut app = test_app();\n        app.status_message = Some(\"old status\".to_string());\n        app.start_new_session();\n        assert_eq!(app.mode, Mode::NewSessionAgent);\n        assert_eq!(app.agent_selection, 0);\n        assert!(\n            app.status_message.is_none(),\n            \"status_message should be cleared\"\n        );\n    }\n\n    #[test]\n    fn cancel_mode_returns_to_browse() {\n        let mut app = test_app();\n        app.mode = Mode::NewSessionAgent;\n        app.status_message = Some(\"error message\".to_string());\n        app.cancel_mode();\n        assert_eq!(app.mode, Mode::Browse);\n        assert!(\n            app.status_message.is_none(),\n            \"status_message should be cleared\"\n        );\n    }\n\n    #[test]\n    fn cancel_mode_from_confirm_delete_returns_to_browse() {\n        let sessions = vec![make_session(\"s1\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.mode = Mode::ConfirmDelete;\n        app.cancel_mode();\n        assert_eq!(app.mode, Mode::Browse);\n    }\n\n    #[test]\n    fn request_delete_with_sessions_transitions_to_confirm_delete() {\n        let sessions = vec![make_session(\"s1\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.status_message = Some(\"old\".to_string());\n        app.request_delete();\n        assert_eq!(app.mode, Mode::ConfirmDelete);\n        assert!(\n            app.status_message.is_none(),\n            \"status_message should be cleared\"\n        );\n    }\n\n    #[test]\n    fn request_delete_with_no_sessions_stays_in_browse() {\n        let mut app = test_app();\n        assert!(app.sessions.is_empty());\n        app.request_delete();\n        assert_eq!(\n            app.mode,\n            Mode::Browse,\n            \"mode should remain Browse when no sessions\"\n        );\n    }\n\n    #[test]\n    fn attach_selected_with_sessions_transitions_to_attached() {\n        let sessions = vec![make_session(\"s1\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.attach_selected();\n        assert_eq!(app.mode, Mode::Attached);\n    }\n\n    #[test]\n    fn attach_selected_with_no_sessions_stays_in_browse() {\n        let mut app = test_app();\n        assert!(app.sessions.is_empty());\n        app.attach_selected();\n        assert_eq!(\n            app.mode,\n            Mode::Browse,\n            \"mode should remain Browse when no sessions\"\n        );\n    }\n\n    #[test]\n    fn detach_transitions_to_browse() {\n        let sessions = vec![make_session(\"s1\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.mode = Mode::Attached;\n        app.detach();\n        assert_eq!(app.mode, Mode::Browse);\n    }\n\n    // ── Agent selection tests ────────────────────────────────────────\n\n    #[test]\n    fn agent_select_next_wraps_around() {\n        let mut app = test_app();\n        let agent_count = AgentType::all().len();\n        app.agent_selection = agent_count - 1; // last agent\n        app.agent_select_next();\n        assert_eq!(\n            app.agent_selection, 0,\n            \"agent_select_next should wrap from last to first\"\n        );\n    }\n\n    #[test]\n    fn agent_select_prev_wraps_around() {\n        let mut app = test_app();\n        app.agent_selection = 0; // first agent\n        app.agent_select_prev();\n        let agent_count = AgentType::all().len();\n        assert_eq!(\n            app.agent_selection,\n            agent_count - 1,\n            \"agent_select_prev should wrap from first to last\"\n        );\n    }\n\n    #[test]\n    fn agent_select_next_increments() {\n        let mut app = test_app();\n        app.agent_selection = 0;\n        app.agent_select_next();\n        assert_eq!(app.agent_selection, 1);\n    }\n\n    #[test]\n    fn agent_select_prev_decrements() {\n        let mut app = test_app();\n        let agent_count = AgentType::all().len();\n        app.agent_selection = agent_count - 1;\n        app.agent_select_prev();\n        assert_eq!(app.agent_selection, agent_count - 2);\n    }\n\n    // ── Session creation flow tests ──────────────────────────────────\n\n    #[test]\n    fn full_new_session_flow() {\n        let mut app = test_app();\n\n        // Step 1: start new session — goes straight to agent select\n        app.start_new_session();\n        assert_eq!(app.mode, Mode::NewSessionAgent);\n        assert_eq!(app.agent_selection, 0);\n\n        // Step 2: cycle agent selection\n        app.agent_select_next();\n        assert_eq!(app.agent_selection, 1);\n    }\n\n    #[tokio::test]\n    async fn confirm_new_session_auto_generates_name() {\n        let mut app = test_app();\n        app.mode = Mode::NewSessionAgent;\n        app.agent_selection = 0;\n\n        app.confirm_new_session().await;\n\n        assert_eq!(\n            app.mode,\n            Mode::Browse,\n            \"mode should return to Browse after confirm\"\n        );\n        assert!(app.status_message.is_some());\n        assert!(\n            app.status_message.as_ref().unwrap().contains(\"Created session 'alpha'\"),\n            \"should auto-generate name 'alpha': got {:?}\",\n            app.status_message\n        );\n    }\n\n    // ── Delete flow tests ────────────────────────────────────────────\n\n    #[tokio::test]\n    async fn delete_flow_request_then_confirm() {\n        let sessions = vec![make_session(\"doomed\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n\n        // Step 1: request delete\n        app.request_delete();\n        assert_eq!(app.mode, Mode::ConfirmDelete);\n\n        // Step 2: confirm delete (mock kill_session returns Ok)\n        app.confirm_delete().await;\n        assert_eq!(\n            app.mode,\n            Mode::Browse,\n            \"mode should return to Browse after confirm_delete\"\n        );\n        assert!(app.status_message.is_some());\n        assert!(\n            app.status_message.as_ref().unwrap().contains(\"Killed session\"),\n            \"status should indicate session was killed: got {:?}\",\n            app.status_message\n        );\n    }\n\n    #[test]\n    fn delete_flow_request_then_cancel() {\n        let sessions = vec![make_session(\"safe\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n\n        app.request_delete();\n        assert_eq!(app.mode, Mode::ConfirmDelete);\n\n        app.cancel_mode();\n        assert_eq!(app.mode, Mode::Browse, \"cancel should return to Browse\");\n        assert!(app.status_message.is_none());\n    }\n\n    // ── Quit tests ───────────────────────────────────────────────────\n\n    #[test]\n    fn should_quit_starts_false() {\n        let app = test_app();\n        assert!(!app.should_quit, \"should_quit should start as false\");\n    }\n\n    #[test]\n    fn should_quit_stays_true_once_set() {\n        let mut app = test_app();\n        app.should_quit = true;\n        assert!(app.should_quit, \"should_quit should remain true once set\");\n        // Verify it doesn't reset unexpectedly after other operations\n        app.select_next();\n        assert!(\n            app.should_quit,\n            \"should_quit should still be true after other operations\"\n        );\n    }\n\n    // ── Additional edge-case tests ───────────────────────────────────\n\n    #[test]\n    fn select_next_with_single_session_stays_at_zero() {\n        let sessions = vec![make_session(\"only\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        assert_eq!(app.selected, 0);\n        app.select_next();\n        assert_eq!(app.selected, 0, \"single session: next should wrap to 0\");\n    }\n\n    #[test]\n    fn select_prev_with_single_session_stays_at_zero() {\n        let sessions = vec![make_session(\"only\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        assert_eq!(app.selected, 0);\n        app.select_prev();\n        assert_eq!(app.selected, 0, \"single session: prev should wrap to 0\");\n    }\n\n    #[test]\n    fn new_app_starts_in_browse_mode() {\n        let app = test_app();\n        assert_eq!(app.mode, Mode::Browse);\n    }\n\n    #[test]\n    fn new_app_has_empty_sessions() {\n        let app = test_app();\n        assert!(app.sessions.is_empty());\n    }\n\n    #[test]\n    fn new_app_has_zero_selected() {\n        let app = test_app();\n        assert_eq!(app.selected, 0);\n    }\n\n    #[test]\n    fn new_app_has_no_status_message() {\n        let app = test_app();\n        assert!(app.status_message.is_none());\n    }\n\n    #[test]\n    fn multiple_cancel_mode_calls_remain_in_browse() {\n        let mut app = test_app();\n        app.mode = Mode::NewSessionAgent;\n        app.cancel_mode();\n        assert_eq!(app.mode, Mode::Browse);\n        app.cancel_mode();\n        assert_eq!(\n            app.mode,\n            Mode::Browse,\n            \"repeated cancel should stay in Browse\"\n        );\n    }\n\n    #[test]\n    fn request_delete_clears_status_message() {\n        let sessions = vec![make_session(\"s\", AgentType::Codex)];\n        let mut app = test_app_with_sessions(sessions);\n        app.status_message = Some(\"old msg\".to_string());\n        app.request_delete();\n        assert!(\n            app.status_message.is_none(),\n            \"request_delete should clear status_message\"\n        );\n    }\n\n    #[test]\n    fn detach_from_already_browse_stays_browse() {\n        let mut app = test_app();\n        assert_eq!(app.mode, Mode::Browse);\n        app.detach();\n        assert_eq!(\n            app.mode,\n            Mode::Browse,\n            \"detach from Browse should remain Browse\"\n        );\n    }\n\n    #[tokio::test]\n    async fn refresh_preview_with_no_sessions_shows_placeholder() {\n        let mut app = test_app();\n        app.refresh_preview().await;\n        assert!(\n            app.preview.contains(\"No sessions\"),\n            \"preview with no sessions should show placeholder, got: {:?}\",\n            app.preview\n        );\n    }\n\n    #[tokio::test]\n    async fn refresh_preview_with_session_captures_pane() {\n        let sessions = vec![make_session(\"s1\", AgentType::Claude)];\n        let mut app = test_app_with_sessions(sessions);\n        app.refresh_preview().await;\n        assert_eq!(\n            app.preview, \"mock pane content\",\n            \"preview should contain mock pane content\"\n        );\n    }\n\n    #[tokio::test]\n    async fn refresh_sessions_populates_from_manager() {\n        let sessions = vec![\n            make_session(\"a\", AgentType::Claude),\n            make_session(\"b\", AgentType::Codex),\n        ];\n        let mut app = App::new_with_manager(\n            \"testid\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(MockSessionManager::with_sessions(sessions.clone())),\n        );\n        assert!(app.sessions.is_empty(), \"sessions should start empty\");\n        app.refresh_sessions().await;\n        assert_eq!(\n            app.sessions.len(),\n            2,\n            \"refresh_sessions should populate from manager\"\n        );\n    }\n}\n","traces":[{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":42}},{"line":52,"address":[],"length":0,"stats":{"Line":84}},{"line":54,"address":[],"length":0,"stats":{"Line":84}},{"line":61,"address":[],"length":0,"stats":{"Line":126}},{"line":62,"address":[],"length":0,"stats":{"Line":126}},{"line":64,"address":[],"length":0,"stats":{"Line":84}},{"line":65,"address":[],"length":0,"stats":{"Line":84}},{"line":66,"address":[],"length":0,"stats":{"Line":84}},{"line":67,"address":[],"length":0,"stats":{"Line":84}},{"line":68,"address":[],"length":0,"stats":{"Line":42}},{"line":74,"address":[],"length":0,"stats":{"Line":6}},{"line":75,"address":[],"length":0,"stats":{"Line":9}},{"line":76,"address":[],"length":0,"stats":{"Line":12}},{"line":77,"address":[],"length":0,"stats":{"Line":3}},{"line":78,"address":[],"length":0,"stats":{"Line":3}},{"line":79,"address":[],"length":0,"stats":{"Line":6}},{"line":81,"address":[],"length":0,"stats":{"Line":6}},{"line":82,"address":[],"length":0,"stats":{"Line":9}},{"line":85,"address":[],"length":0,"stats":{"Line":3}},{"line":86,"address":[],"length":0,"stats":{"Line":9}},{"line":87,"address":[],"length":0,"stats":{"Line":6}},{"line":88,"address":[],"length":0,"stats":{"Line":6}},{"line":89,"address":[],"length":0,"stats":{"Line":3}},{"line":91,"address":[],"length":0,"stats":{"Line":12}},{"line":92,"address":[],"length":0,"stats":{"Line":6}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":3}},{"line":97,"address":[],"length":0,"stats":{"Line":15}},{"line":101,"address":[],"length":0,"stats":{"Line":3}},{"line":102,"address":[],"length":0,"stats":{"Line":3}},{"line":103,"address":[],"length":0,"stats":{"Line":21}},{"line":104,"address":[],"length":0,"stats":{"Line":18}},{"line":105,"address":[],"length":0,"stats":{"Line":9}},{"line":106,"address":[],"length":0,"stats":{"Line":6}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":6}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":7}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":4}},{"line":142,"address":[],"length":0,"stats":{"Line":6}},{"line":143,"address":[],"length":0,"stats":{"Line":4}},{"line":144,"address":[],"length":0,"stats":{"Line":2}},{"line":145,"address":[],"length":0,"stats":{"Line":4}},{"line":146,"address":[],"length":0,"stats":{"Line":3}},{"line":147,"address":[],"length":0,"stats":{"Line":4}},{"line":148,"address":[],"length":0,"stats":{"Line":1}},{"line":149,"address":[],"length":0,"stats":{"Line":2}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":1}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":6}},{"line":184,"address":[],"length":0,"stats":{"Line":10}},{"line":185,"address":[],"length":0,"stats":{"Line":8}},{"line":186,"address":[],"length":0,"stats":{"Line":4}},{"line":190,"address":[],"length":0,"stats":{"Line":5}},{"line":191,"address":[],"length":0,"stats":{"Line":5}},{"line":192,"address":[],"length":0,"stats":{"Line":4}},{"line":193,"address":[],"length":0,"stats":{"Line":2}},{"line":195,"address":[],"length":0,"stats":{"Line":2}},{"line":197,"address":[],"length":0,"stats":{"Line":4}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":2}},{"line":210,"address":[],"length":0,"stats":{"Line":3}},{"line":211,"address":[],"length":0,"stats":{"Line":1}},{"line":215,"address":[],"length":0,"stats":{"Line":2}},{"line":216,"address":[],"length":0,"stats":{"Line":2}},{"line":219,"address":[],"length":0,"stats":{"Line":2}},{"line":220,"address":[],"length":0,"stats":{"Line":2}},{"line":221,"address":[],"length":0,"stats":{"Line":2}},{"line":222,"address":[],"length":0,"stats":{"Line":4}},{"line":225,"address":[],"length":0,"stats":{"Line":2}},{"line":226,"address":[],"length":0,"stats":{"Line":2}},{"line":227,"address":[],"length":0,"stats":{"Line":3}},{"line":228,"address":[],"length":0,"stats":{"Line":5}},{"line":229,"address":[],"length":0,"stats":{"Line":3}},{"line":230,"address":[],"length":0,"stats":{"Line":3}},{"line":231,"address":[],"length":0,"stats":{"Line":3}},{"line":233,"address":[],"length":0,"stats":{"Line":7}},{"line":234,"address":[],"length":0,"stats":{"Line":1}},{"line":236,"address":[],"length":0,"stats":{"Line":2}},{"line":237,"address":[],"length":0,"stats":{"Line":1}},{"line":238,"address":[],"length":0,"stats":{"Line":1}},{"line":240,"address":[],"length":0,"stats":{"Line":2}},{"line":241,"address":[],"length":0,"stats":{"Line":2}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":1}},{"line":252,"address":[],"length":0,"stats":{"Line":5}},{"line":253,"address":[],"length":0,"stats":{"Line":9}},{"line":254,"address":[],"length":0,"stats":{"Line":8}},{"line":255,"address":[],"length":0,"stats":{"Line":4}},{"line":259,"address":[],"length":0,"stats":{"Line":2}},{"line":260,"address":[],"length":0,"stats":{"Line":3}},{"line":261,"address":[],"length":0,"stats":{"Line":3}},{"line":262,"address":[],"length":0,"stats":{"Line":3}},{"line":263,"address":[],"length":0,"stats":{"Line":4}},{"line":264,"address":[],"length":0,"stats":{"Line":1}},{"line":265,"address":[],"length":0,"stats":{"Line":1}},{"line":266,"address":[],"length":0,"stats":{"Line":1}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":1}},{"line":274,"address":[],"length":0,"stats":{"Line":2}},{"line":277,"address":[],"length":0,"stats":{"Line":5}},{"line":278,"address":[],"length":0,"stats":{"Line":5}},{"line":279,"address":[],"length":0,"stats":{"Line":10}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":3}},{"line":365,"address":[],"length":0,"stats":{"Line":9}},{"line":366,"address":[],"length":0,"stats":{"Line":3}},{"line":369,"address":[],"length":0,"stats":{"Line":2}},{"line":370,"address":[],"length":0,"stats":{"Line":6}},{"line":371,"address":[],"length":0,"stats":{"Line":2}},{"line":372,"address":[],"length":0,"stats":{"Line":1}},{"line":374,"address":[],"length":0,"stats":{"Line":1}}],"covered":104,"coverable":190},{"path":["/","Users","cat","hydra","src","event.rs"],"content":"use crossterm::event::{Event as CrosstermEvent, EventStream, KeyEvent, MouseEvent};\nuse futures::StreamExt;\nuse std::time::Duration;\nuse tokio::sync::mpsc;\n\n#[derive(Debug)]\npub enum Event {\n    Key(KeyEvent),\n    Mouse(MouseEvent),\n    Tick,\n    Resize,\n}\n\npub struct EventHandler {\n    rx: mpsc::UnboundedReceiver<Event>,\n    _task: tokio::task::JoinHandle<()>,\n}\n\nimpl EventHandler {\n    pub fn new(tick_rate: Duration) -> Self {\n        let (tx, rx) = mpsc::unbounded_channel();\n\n        let task = tokio::spawn(async move {\n            let mut reader = EventStream::new();\n            let mut tick = tokio::time::interval(tick_rate);\n\n            loop {\n                tokio::select! {\n                    _ = tick.tick() => {\n                        if tx.send(Event::Tick).is_err() {\n                            break;\n                        }\n                    }\n                    event = reader.next() => {\n                        match event {\n                            Some(Ok(CrosstermEvent::Key(key))) => {\n                                if tx.send(Event::Key(key)).is_err() {\n                                    break;\n                                }\n                            }\n                            Some(Ok(CrosstermEvent::Mouse(mouse))) => {\n                                if tx.send(Event::Mouse(mouse)).is_err() {\n                                    break;\n                                }\n                            }\n                            Some(Ok(CrosstermEvent::Resize(_, _))) => {\n                                if tx.send(Event::Resize).is_err() {\n                                    break;\n                                }\n                            }\n                            Some(Err(_)) | None => break,\n                            _ => {}\n                        }\n                    }\n                }\n            }\n        });\n\n        Self { rx, _task: task }\n    }\n\n    pub async fn next(&mut self) -> Option<Event> {\n        self.rx.recv().await\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":23},{"path":["/","Users","cat","hydra","src","logs.rs"],"content":"use std::io::{Read, Seek, SeekFrom};\nuse std::path::PathBuf;\n\nuse tokio::process::Command;\n\n/// Get the pane PID for a tmux session.\npub async fn get_pane_pid(tmux_name: &str) -> Option<u32> {\n    let output = Command::new(\"tmux\")\n        .args([\"list-panes\", \"-t\", tmux_name, \"-F\", \"#{pane_pid}\"])\n        .output()\n        .await\n        .ok()?;\n\n    if !output.status.success() {\n        return None;\n    }\n\n    String::from_utf8_lossy(&output.stdout)\n        .trim()\n        .parse()\n        .ok()\n}\n\n/// Use lsof to find the Claude tasks UUID from a process PID.\nasync fn resolve_uuid_from_pid(pid: u32) -> Option<String> {\n    let output = Command::new(\"lsof\")\n        .args([\"-p\", &pid.to_string()])\n        .output()\n        .await\n        .ok()?;\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    for line in stdout.lines() {\n        if let Some(idx) = line.find(\".claude/tasks/\") {\n            let rest = &line[idx + \".claude/tasks/\".len()..];\n            if rest.len() >= 36 {\n                let candidate = &rest[..36];\n                if is_uuid(candidate) {\n                    return Some(candidate.to_string());\n                }\n            }\n        }\n    }\n    None\n}\n\nfn is_uuid(s: &str) -> bool {\n    s.len() == 36\n        && s.chars().enumerate().all(|(i, c)| {\n            if i == 8 || i == 13 || i == 18 || i == 23 {\n                c == '-'\n            } else {\n                c.is_ascii_hexdigit()\n            }\n        })\n}\n\n/// Resolve the Claude session UUID for a tmux session via PID tracing.\npub async fn resolve_session_uuid(tmux_name: &str) -> Option<String> {\n    let pid = get_pane_pid(tmux_name).await?;\n    resolve_uuid_from_pid(pid).await\n}\n\n/// Convert a CWD path to the Claude projects directory escape format.\n/// e.g. \"/Users/monkey/hydra\" → \"-Users-monkey-hydra\"\nfn escape_project_path(cwd: &str) -> String {\n    cwd.replace('/', \"-\")\n}\n\n/// Read the last assistant message from a Claude JSONL log file.\n/// Reads only the tail of the file for efficiency on large logs.\npub fn read_last_assistant_message(cwd: &str, uuid: &str) -> Option<String> {\n    let escaped = escape_project_path(cwd);\n    let home = std::env::var(\"HOME\").ok()?;\n    let path = PathBuf::from(&home)\n        .join(\".claude\")\n        .join(\"projects\")\n        .join(&escaped)\n        .join(format!(\"{uuid}.jsonl\"));\n\n    let mut file = std::fs::File::open(&path).ok()?;\n    let file_len = file.metadata().ok()?.len();\n\n    // Read last 200KB — enough to find the most recent assistant message\n    let chunk_size: u64 = 200 * 1024;\n    let start = file_len.saturating_sub(chunk_size);\n    file.seek(SeekFrom::Start(start)).ok()?;\n\n    let mut buf = Vec::new();\n    file.read_to_end(&mut buf).ok()?;\n    let text = String::from_utf8_lossy(&buf);\n\n    let mut last_text: Option<String> = None;\n\n    for line in text.lines() {\n        // Quick filter before JSON parse\n        if !line.contains(\"\\\"assistant\\\"\") {\n            continue;\n        }\n        let v: serde_json::Value = match serde_json::from_str(line) {\n            Ok(v) => v,\n            Err(_) => continue, // partial line from mid-file seek\n        };\n        if v.get(\"type\").and_then(|t| t.as_str()) != Some(\"assistant\") {\n            continue;\n        }\n        if let Some(content) = v\n            .get(\"message\")\n            .and_then(|m| m.get(\"content\"))\n            .and_then(|c| c.as_array())\n        {\n            let mut parts = Vec::new();\n            for item in content {\n                if let Some(t) = item.get(\"text\").and_then(|t| t.as_str()) {\n                    parts.push(t);\n                }\n            }\n            if !parts.is_empty() {\n                last_text = Some(parts.join(\" \"));\n            }\n        }\n    }\n\n    // Condense whitespace for display\n    last_text.map(|t| t.split_whitespace().collect::<Vec<_>>().join(\" \"))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_uuid_valid() {\n        assert!(is_uuid(\"7c04c22f-796f-403a-9521-d83ad13fd60d\"));\n    }\n\n    #[test]\n    fn is_uuid_invalid_length() {\n        assert!(!is_uuid(\"7c04c22f-796f-403a-9521\"));\n    }\n\n    #[test]\n    fn is_uuid_invalid_chars() {\n        assert!(!is_uuid(\"zzzzzzzz-zzzz-zzzz-zzzz-zzzzzzzzzzzz\"));\n    }\n\n    #[test]\n    fn is_uuid_missing_dashes() {\n        assert!(!is_uuid(\"7c04c22f0796f0403a09521od83ad13fd60d\"));\n    }\n\n    #[test]\n    fn escape_project_path_basic() {\n        assert_eq!(escape_project_path(\"/Users/monkey/hydra\"), \"-Users-monkey-hydra\");\n    }\n\n    #[test]\n    fn escape_project_path_root() {\n        assert_eq!(escape_project_path(\"/\"), \"-\");\n    }\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":4}},{"line":48,"address":[],"length":0,"stats":{"Line":4}},{"line":49,"address":[],"length":0,"stats":{"Line":55}},{"line":50,"address":[],"length":0,"stats":{"Line":175}},{"line":51,"address":[],"length":0,"stats":{"Line":5}},{"line":53,"address":[],"length":0,"stats":{"Line":82}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":6}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}}],"covered":8,"coverable":64},{"path":["/","Users","cat","hydra","src","main.rs"],"content":"mod app;\nmod event;\nmod logs;\nmod session;\nmod tmux;\nmod ui;\n\nuse anyhow::{Context, Result};\nuse clap::{Parser, Subcommand};\nuse crossterm::{\n    event::{DisableMouseCapture, EnableMouseCapture, KeyCode, KeyEvent, KeyEventKind},\n    execute,\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\n};\nuse ratatui::backend::CrosstermBackend;\nuse ratatui::Terminal;\nuse std::io;\nuse std::time::Duration;\n\nuse app::{App, Mode};\nuse event::{Event, EventHandler};\nuse session::{project_id, AgentType};\n\n#[derive(Parser)]\n#[command(name = \"hydra\", about = \"AI Agent tmux session manager\")]\nstruct Cli {\n    #[command(subcommand)]\n    command: Option<Commands>,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    /// Create a new agent session\n    New {\n        /// Agent type (claude, codex)\n        agent: String,\n        /// Session name\n        name: String,\n    },\n    /// Kill a session\n    Kill {\n        /// Session name\n        name: String,\n    },\n    /// List sessions for the current project\n    Ls,\n}\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    let cli = Cli::parse();\n\n    let cwd = std::env::current_dir()\n        .context(\"Failed to get current directory\")?\n        .to_string_lossy()\n        .to_string();\n    let pid = project_id(&cwd);\n\n    match cli.command {\n        Some(Commands::New { agent, name }) => cmd_new(&pid, &name, &agent, &cwd).await,\n        Some(Commands::Kill { name }) => cmd_kill(&pid, &name).await,\n        Some(Commands::Ls) => cmd_ls(&pid).await,\n        None => run_tui(pid, cwd).await,\n    }\n}\n\nasync fn cmd_new(project_id: &str, name: &str, agent_str: &str, cwd: &str) -> Result<()> {\n    let agent: AgentType = agent_str.parse()?;\n    let tmux_name = tmux::create_session(project_id, name, &agent, cwd).await?;\n    println!(\"Created session: {tmux_name}\");\n    Ok(())\n}\n\nasync fn cmd_kill(project_id: &str, name: &str) -> Result<()> {\n    let tmux_name = session::tmux_session_name(project_id, name);\n    tmux::kill_session(&tmux_name).await?;\n    println!(\"Killed session: {tmux_name}\");\n    Ok(())\n}\n\nasync fn cmd_ls(project_id: &str) -> Result<()> {\n    let manager = tmux::TmuxSessionManager::new();\n    let sessions = tmux::SessionManager::list_sessions(&manager, project_id).await?;\n    if sessions.is_empty() {\n        println!(\"No sessions for this project.\");\n    } else {\n        for s in &sessions {\n            println!(\"{} [{}]\", s.name, s.agent_type);\n        }\n    }\n    Ok(())\n}\n\nasync fn run_tui(project_id: String, cwd: String) -> Result<()> {\n    // Setup terminal\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen, EnableMouseCapture)?;\n    let backend = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backend)?;\n\n    let mut app = App::new(project_id, cwd);\n    app.refresh_sessions().await;\n    app.refresh_preview().await;\n\n    let mut events = EventHandler::new(Duration::from_millis(250));\n\n    // Main loop\n    loop {\n        terminal.draw(|frame| ui::draw(frame, &app))?;\n\n        if app.should_quit {\n            break;\n        }\n\n        match events.next().await {\n            Some(Event::Key(key)) => {\n                if key.kind == KeyEventKind::Press {\n                    handle_key(&mut app, key).await;\n                    app.refresh_preview().await;\n                }\n            }\n            Some(Event::Mouse(mouse)) => {\n                app.handle_mouse(mouse);\n                app.refresh_preview().await;\n            }\n            Some(Event::Tick) => {\n                app.refresh_sessions().await;\n                app.refresh_preview().await;\n                app.refresh_messages().await;\n            }\n            Some(Event::Resize) => {}\n            None => break,\n        }\n    }\n\n    // Restore terminal\n    disable_raw_mode()?;\n    execute!(\n        terminal.backend_mut(),\n        LeaveAlternateScreen,\n        DisableMouseCapture\n    )?;\n    terminal.show_cursor()?;\n\n    Ok(())\n}\n\nasync fn handle_key(app: &mut App, key: KeyEvent) {\n    match app.mode {\n        Mode::Browse => handle_browse_key(app, key.code),\n        Mode::Attached => handle_attached_key(app, key).await,\n        Mode::NewSessionAgent => handle_agent_select_key(app, key.code).await,\n        Mode::ConfirmDelete => handle_confirm_delete_key(app, key.code).await,\n    }\n}\n\nfn handle_browse_key(app: &mut App, code: KeyCode) {\n    match code {\n        KeyCode::Char('q') => app.should_quit = true,\n        KeyCode::Char('j') | KeyCode::Down => app.select_next(),\n        KeyCode::Char('k') | KeyCode::Up => app.select_prev(),\n        KeyCode::Enter => app.attach_selected(),\n        KeyCode::Char('n') => app.start_new_session(),\n        KeyCode::Char('d') => app.request_delete(),\n        _ => {}\n    }\n}\n\nasync fn handle_agent_select_key(app: &mut App, code: KeyCode) {\n    match code {\n        KeyCode::Enter => app.confirm_new_session().await,\n        KeyCode::Esc => app.cancel_mode(),\n        KeyCode::Char('j') | KeyCode::Down => app.agent_select_next(),\n        KeyCode::Char('k') | KeyCode::Up => app.agent_select_prev(),\n        _ => {}\n    }\n}\n\nasync fn handle_attached_key(app: &mut App, key: KeyEvent) {\n    if key.code == KeyCode::Esc {\n        app.detach();\n        return;\n    }\n\n    if let Some(session) = app.sessions.get(app.selected) {\n        if let Some(tmux_key) = tmux::keycode_to_tmux(key.code, key.modifiers) {\n            let tmux_name = session.tmux_name.clone();\n            let _ = tmux::send_keys(&tmux_name, &tmux_key).await;\n        }\n    }\n}\n\nasync fn handle_confirm_delete_key(app: &mut App, code: KeyCode) {\n    match code {\n        KeyCode::Char('y') => app.confirm_delete().await,\n        KeyCode::Esc | KeyCode::Char('n') => app.cancel_mode(),\n        _ => {}\n    }\n}\n\n","traces":[{"line":50,"address":[],"length":0,"stats":{"Line":12}},{"line":51,"address":[],"length":0,"stats":{"Line":12}},{"line":53,"address":[],"length":0,"stats":{"Line":12}},{"line":57,"address":[],"length":0,"stats":{"Line":18}},{"line":59,"address":[],"length":0,"stats":{"Line":8}},{"line":60,"address":[],"length":0,"stats":{"Line":13}},{"line":61,"address":[],"length":0,"stats":{"Line":6}},{"line":62,"address":[],"length":0,"stats":{"Line":8}},{"line":63,"address":[],"length":0,"stats":{"Line":18}},{"line":67,"address":[],"length":0,"stats":{"Line":2}},{"line":68,"address":[],"length":0,"stats":{"Line":3}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":2}},{"line":82,"address":[],"length":0,"stats":{"Line":2}},{"line":83,"address":[],"length":0,"stats":{"Line":4}},{"line":84,"address":[],"length":0,"stats":{"Line":2}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":3}},{"line":88,"address":[],"length":0,"stats":{"Line":1}},{"line":91,"address":[],"length":0,"stats":{"Line":1}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}}],"covered":18,"coverable":93},{"path":["/","Users","cat","hydra","src","session.rs"],"content":"use sha2::{Digest, Sha256};\nuse std::fmt;\nuse std::time::Duration;\n\n#[derive(Debug, Clone, PartialEq)]\npub enum AgentType {\n    Claude,\n    Codex,\n}\n\nimpl AgentType {\n    pub fn command(&self) -> &str {\n        match self {\n            AgentType::Claude => \"claude --dangerously-skip-permissions\",\n            AgentType::Codex => \"codex --yolo\",\n        }\n    }\n\n    pub fn all() -> &'static [AgentType] {\n        &[AgentType::Claude, AgentType::Codex]\n    }\n}\n\nimpl fmt::Display for AgentType {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            AgentType::Claude => write!(f, \"Claude\"),\n            AgentType::Codex => write!(f, \"Codex\"),\n        }\n    }\n}\n\nimpl std::str::FromStr for AgentType {\n    type Err = anyhow::Error;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        match s.to_lowercase().as_str() {\n            \"claude\" => Ok(AgentType::Claude),\n            \"codex\" => Ok(AgentType::Codex),\n            _ => Err(anyhow::anyhow!(\"Unknown agent type: {s}. Use 'claude' or 'codex'.\")),\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum SessionStatus {\n    Running,\n    Idle,\n    Exited,\n}\n\n#[derive(Debug, Clone)]\npub struct Session {\n    pub name: String,\n    pub tmux_name: String,\n    pub agent_type: AgentType,\n    pub status: SessionStatus,\n    pub task_elapsed: Option<Duration>,\n    pub _alive: bool,\n}\n\npub fn format_duration(d: Duration) -> String {\n    let secs = d.as_secs();\n    if secs < 60 {\n        format!(\"{secs}s\")\n    } else if secs < 3600 {\n        format!(\"{}m {:02}s\", secs / 60, secs % 60)\n    } else {\n        format!(\"{}h {:02}m\", secs / 3600, (secs % 3600) / 60)\n    }\n}\n\n/// Generate an 8-char hex hash from the absolute CWD path.\npub fn project_id(cwd: &str) -> String {\n    let mut hasher = Sha256::new();\n    hasher.update(cwd.as_bytes());\n    let result = hasher.finalize();\n    hex::encode(&result[..4])\n}\n\n/// Build the tmux session name: `hydra-<hash>-<name>`\npub fn tmux_session_name(project_id: &str, name: &str) -> String {\n    format!(\"hydra-{project_id}-{name}\")\n}\n\n/// Extract the user-facing session name from a tmux session name.\npub fn parse_session_name(tmux_name: &str, project_id: &str) -> Option<String> {\n    let prefix = format!(\"hydra-{project_id}-\");\n    tmux_name.strip_prefix(&prefix).map(|s| s.to_string())\n}\n\nconst AUTO_NAMES: &[&str] = &[\n    \"alpha\", \"bravo\", \"charlie\", \"delta\", \"echo\", \"foxtrot\", \"golf\", \"hotel\", \"india\", \"juliet\",\n    \"kilo\", \"lima\", \"mike\", \"november\", \"oscar\", \"papa\", \"quebec\", \"romeo\", \"sierra\", \"tango\",\n    \"uniform\", \"victor\", \"whiskey\", \"xray\", \"yankee\", \"zulu\",\n];\n\n/// Generate the next available session name from the NATO phonetic alphabet.\npub fn generate_name(existing: &[String]) -> String {\n    for name in AUTO_NAMES {\n        if !existing.iter().any(|n| n == name) {\n            return name.to_string();\n        }\n    }\n    let mut i = AUTO_NAMES.len() + 1;\n    loop {\n        let name = format!(\"agent-{i}\");\n        if !existing.iter().any(|n| *n == name) {\n            return name;\n        }\n        i += 1;\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::str::FromStr;\n\n    // ── project_id tests ──────────────────────────────────────────────\n\n    #[test]\n    fn project_id_is_deterministic() {\n        let id1 = project_id(\"/home/user/project\");\n        let id2 = project_id(\"/home/user/project\");\n        assert_eq!(id1, id2);\n    }\n\n    #[test]\n    fn project_id_different_inputs_produce_different_ids() {\n        let id1 = project_id(\"/home/user/project-a\");\n        let id2 = project_id(\"/home/user/project-b\");\n        assert_ne!(id1, id2);\n    }\n\n    #[test]\n    fn project_id_is_8_char_hex() {\n        let id = project_id(\"/some/path\");\n        assert_eq!(id.len(), 8);\n        assert!(\n            id.chars().all(|c| c.is_ascii_hexdigit()),\n            \"project_id should only contain hex characters, got: {id}\"\n        );\n    }\n\n    #[test]\n    fn project_id_empty_string_input() {\n        let id = project_id(\"\");\n        assert_eq!(id.len(), 8);\n        assert!(id.chars().all(|c| c.is_ascii_hexdigit()));\n    }\n\n    // ── tmux_session_name tests ───────────────────────────────────────\n\n    #[test]\n    fn tmux_session_name_correct_format() {\n        let name = tmux_session_name(\"abcd1234\", \"my-session\");\n        assert_eq!(name, \"hydra-abcd1234-my-session\");\n    }\n\n    #[test]\n    fn tmux_session_name_with_empty_name() {\n        let name = tmux_session_name(\"abcd1234\", \"\");\n        assert_eq!(name, \"hydra-abcd1234-\");\n    }\n\n    // ── parse_session_name tests ──────────────────────────────────────\n\n    #[test]\n    fn parse_session_name_roundtrip() {\n        let pid = project_id(\"/home/user/my-project\");\n        let session = \"worker-1\";\n        let tmux = tmux_session_name(&pid, session);\n        let parsed = parse_session_name(&tmux, &pid);\n        assert_eq!(parsed, Some(session.to_string()));\n    }\n\n    #[test]\n    fn parse_session_name_wrong_prefix_returns_none() {\n        let result = parse_session_name(\"other-prefix-session\", \"abcd1234\");\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn parse_session_name_wrong_project_id_returns_none() {\n        let tmux = tmux_session_name(\"aaaaaaaa\", \"session\");\n        let result = parse_session_name(&tmux, \"bbbbbbbb\");\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn parse_session_name_exact_prefix_no_name() {\n        let tmux = \"hydra-abcd1234-\";\n        let result = parse_session_name(tmux, \"abcd1234\");\n        assert_eq!(result, Some(String::new()));\n    }\n\n    // ── AgentType::command tests ──────────────────────────────────────\n\n    #[test]\n    fn agent_type_command_claude() {\n        assert_eq!(AgentType::Claude.command(), \"claude --dangerously-skip-permissions\");\n    }\n\n    #[test]\n    fn agent_type_command_codex() {\n        assert_eq!(AgentType::Codex.command(), \"codex --yolo\");\n    }\n\n    // ── AgentType::all tests ──────────────────────────────────────────\n\n    #[test]\n    fn agent_type_all_returns_both_variants() {\n        let all = AgentType::all();\n        assert_eq!(all.len(), 2);\n        assert_eq!(all[0], AgentType::Claude);\n        assert_eq!(all[1], AgentType::Codex);\n    }\n\n    // ── AgentType Display tests ───────────────────────────────────────\n\n    #[test]\n    fn agent_type_display_claude() {\n        assert_eq!(format!(\"{}\", AgentType::Claude), \"Claude\");\n    }\n\n    #[test]\n    fn agent_type_display_codex() {\n        assert_eq!(format!(\"{}\", AgentType::Codex), \"Codex\");\n    }\n\n    // ── AgentType FromStr tests ───────────────────────────────────────\n\n    #[test]\n    fn agent_type_from_str_claude_lowercase() {\n        let agent = AgentType::from_str(\"claude\").unwrap();\n        assert_eq!(agent, AgentType::Claude);\n    }\n\n    #[test]\n    fn agent_type_from_str_codex_lowercase() {\n        let agent = AgentType::from_str(\"codex\").unwrap();\n        assert_eq!(agent, AgentType::Codex);\n    }\n\n    #[test]\n    fn agent_type_from_str_case_insensitive_uppercase() {\n        let agent = AgentType::from_str(\"CLAUDE\").unwrap();\n        assert_eq!(agent, AgentType::Claude);\n    }\n\n    #[test]\n    fn agent_type_from_str_case_insensitive_mixed() {\n        let agent = AgentType::from_str(\"Codex\").unwrap();\n        assert_eq!(agent, AgentType::Codex);\n    }\n\n    #[test]\n    fn agent_type_from_str_invalid_returns_error() {\n        let result = AgentType::from_str(\"gpt\");\n        assert!(result.is_err());\n        let err_msg = result.unwrap_err().to_string();\n        assert!(\n            err_msg.contains(\"Unknown agent type\"),\n            \"Error message should mention 'Unknown agent type', got: {err_msg}\"\n        );\n    }\n\n    #[test]\n    fn agent_type_from_str_empty_returns_error() {\n        let result = AgentType::from_str(\"\");\n        assert!(result.is_err());\n    }\n\n    // ── generate_name tests ──────────────────────────────────────────\n\n    #[test]\n    fn generate_name_first_is_alpha() {\n        let name = generate_name(&[]);\n        assert_eq!(name, \"alpha\");\n    }\n\n    #[test]\n    fn generate_name_skips_existing() {\n        let existing = vec![\"alpha\".to_string(), \"bravo\".to_string()];\n        let name = generate_name(&existing);\n        assert_eq!(name, \"charlie\");\n    }\n\n    #[test]\n    fn generate_name_fills_gaps() {\n        let existing = vec![\"alpha\".to_string(), \"charlie\".to_string()];\n        let name = generate_name(&existing);\n        assert_eq!(name, \"bravo\");\n    }\n\n    #[test]\n    fn generate_name_fallback_when_all_taken() {\n        let all_taken: Vec<String> = AUTO_NAMES.iter().map(|s| s.to_string()).collect();\n        let name = generate_name(&all_taken);\n        assert_eq!(name, \"agent-27\");\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":2}},{"line":13,"address":[],"length":0,"stats":{"Line":2}},{"line":14,"address":[],"length":0,"stats":{"Line":1}},{"line":15,"address":[],"length":0,"stats":{"Line":1}},{"line":19,"address":[],"length":0,"stats":{"Line":11}},{"line":20,"address":[],"length":0,"stats":{"Line":11}},{"line":25,"address":[],"length":0,"stats":{"Line":11}},{"line":26,"address":[],"length":0,"stats":{"Line":11}},{"line":27,"address":[],"length":0,"stats":{"Line":16}},{"line":28,"address":[],"length":0,"stats":{"Line":6}},{"line":36,"address":[],"length":0,"stats":{"Line":8}},{"line":37,"address":[],"length":0,"stats":{"Line":8}},{"line":38,"address":[],"length":0,"stats":{"Line":11}},{"line":39,"address":[],"length":0,"stats":{"Line":7}},{"line":40,"address":[],"length":0,"stats":{"Line":3}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":9}},{"line":75,"address":[],"length":0,"stats":{"Line":18}},{"line":76,"address":[],"length":0,"stats":{"Line":36}},{"line":77,"address":[],"length":0,"stats":{"Line":27}},{"line":78,"address":[],"length":0,"stats":{"Line":18}},{"line":82,"address":[],"length":0,"stats":{"Line":4}},{"line":83,"address":[],"length":0,"stats":{"Line":4}},{"line":87,"address":[],"length":0,"stats":{"Line":5}},{"line":88,"address":[],"length":0,"stats":{"Line":10}},{"line":89,"address":[],"length":0,"stats":{"Line":26}},{"line":99,"address":[],"length":0,"stats":{"Line":5}},{"line":100,"address":[],"length":0,"stats":{"Line":33}},{"line":101,"address":[],"length":0,"stats":{"Line":784}},{"line":102,"address":[],"length":0,"stats":{"Line":8}},{"line":105,"address":[],"length":0,"stats":{"Line":2}},{"line":107,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":54}},{"line":109,"address":[],"length":0,"stats":{"Line":1}},{"line":111,"address":[],"length":0,"stats":{"Line":0}}],"covered":33,"coverable":41},{"path":["/","Users","cat","hydra","src","tmux.rs"],"content":"use anyhow::{bail, Context, Result};\nuse std::collections::HashMap;\nuse std::sync::Mutex;\nuse tokio::process::Command;\n\nuse crate::session::{parse_session_name, AgentType, Session, SessionStatus};\n\n#[async_trait::async_trait]\npub trait SessionManager: Send + Sync {\n    async fn list_sessions(&self, project_id: &str) -> Result<Vec<Session>>;\n    async fn create_session(\n        &self,\n        project_id: &str,\n        name: &str,\n        agent: &AgentType,\n        cwd: &str,\n    ) -> Result<String>;\n    async fn capture_pane(&self, tmux_name: &str) -> Result<String>;\n    async fn kill_session(&self, tmux_name: &str) -> Result<()>;\n    async fn send_keys(&self, tmux_name: &str, key: &str) -> Result<()>;\n    async fn send_mouse(\n        &self,\n        tmux_name: &str,\n        kind: &str,\n        button: u8,\n        x: u16,\n        y: u16,\n    ) -> Result<()>;\n    async fn capture_pane_scrollback(&self, tmux_name: &str) -> Result<String>;\n}\n\npub struct TmuxSessionManager {\n    agent_cache: Mutex<HashMap<String, AgentType>>,\n}\n\nimpl TmuxSessionManager {\n    pub fn new() -> Self {\n        Self {\n            agent_cache: Mutex::new(HashMap::new()),\n        }\n    }\n}\n\n#[async_trait::async_trait]\nimpl SessionManager for TmuxSessionManager {\n    async fn list_sessions(&self, project_id: &str) -> Result<Vec<Session>> {\n        let output = Command::new(\"tmux\")\n            .args([\"list-sessions\", \"-F\", \"#{session_name}\"])\n            .output()\n            .await;\n\n        let output = match output {\n            Ok(o) => o,\n            Err(_) => return Ok(vec![]),\n        };\n\n        // tmux returns error when no server is running - that's fine, just no sessions\n        if !output.status.success() {\n            return Ok(vec![]);\n        }\n\n        let stdout = String::from_utf8_lossy(&output.stdout);\n        let prefix = format!(\"hydra-{project_id}-\");\n        let mut sessions = Vec::new();\n\n        for line in stdout.lines() {\n            let tmux_name = line.trim();\n            if !tmux_name.starts_with(&prefix) {\n                continue;\n            }\n            let name = match parse_session_name(tmux_name, project_id) {\n                Some(n) => n,\n                None => continue,\n            };\n\n            let agent_type = {\n                let cached = self.agent_cache.lock().unwrap().get(tmux_name).cloned();\n                match cached {\n                    Some(a) => a,\n                    None => {\n                        let agent =\n                            get_agent_type(tmux_name).await.unwrap_or(AgentType::Claude);\n                        self.agent_cache\n                            .lock()\n                            .unwrap()\n                            .insert(tmux_name.to_string(), agent.clone());\n                        agent\n                    }\n                }\n            };\n\n            let status = if is_pane_dead(tmux_name).await {\n                SessionStatus::Exited\n            } else {\n                // Default to Idle; App will upgrade to Running via content comparison\n                SessionStatus::Idle\n            };\n\n            sessions.push(Session {\n                name,\n                tmux_name: tmux_name.to_string(),\n                agent_type,\n                status,\n                task_elapsed: None,\n                _alive: true,\n            });\n        }\n\n        Ok(sessions)\n    }\n\n    async fn create_session(\n        &self,\n        project_id: &str,\n        name: &str,\n        agent: &AgentType,\n        cwd: &str,\n    ) -> Result<String> {\n        let tmux_name = create_session(project_id, name, agent, cwd).await?;\n        self.agent_cache\n            .lock()\n            .unwrap()\n            .insert(tmux_name.clone(), agent.clone());\n        Ok(tmux_name)\n    }\n\n    async fn capture_pane(&self, tmux_name: &str) -> Result<String> {\n        capture_pane(tmux_name).await\n    }\n\n    async fn kill_session(&self, tmux_name: &str) -> Result<()> {\n        kill_session(tmux_name).await\n    }\n\n    async fn send_keys(&self, tmux_name: &str, key: &str) -> Result<()> {\n        send_keys(tmux_name, key).await\n    }\n\n    async fn send_mouse(\n        &self,\n        tmux_name: &str,\n        kind: &str,\n        button: u8,\n        x: u16,\n        y: u16,\n    ) -> Result<()> {\n        send_mouse(tmux_name, kind, button, x, y).await\n    }\n\n    async fn capture_pane_scrollback(&self, tmux_name: &str) -> Result<String> {\n        capture_pane_scrollback(tmux_name).await\n    }\n}\n\n/// Check if the pane in a tmux session has exited (requires remain-on-exit).\nasync fn is_pane_dead(tmux_name: &str) -> bool {\n    let output = Command::new(\"tmux\")\n        .args([\"list-panes\", \"-t\", tmux_name, \"-F\", \"#{pane_dead}\"])\n        .output()\n        .await;\n\n    match output {\n        Ok(o) if o.status.success() => String::from_utf8_lossy(&o.stdout).trim() == \"1\",\n        _ => false,\n    }\n}\n\n/// Read the HYDRA_AGENT_TYPE env var from the tmux session.\nasync fn get_agent_type(tmux_name: &str) -> Option<AgentType> {\n    let output = Command::new(\"tmux\")\n        .args([\"show-environment\", \"-t\", tmux_name, \"HYDRA_AGENT_TYPE\"])\n        .output()\n        .await\n        .ok()?;\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    // Output format: HYDRA_AGENT_TYPE=claude\n    let val = stdout.trim().strip_prefix(\"HYDRA_AGENT_TYPE=\")?;\n    val.parse().ok()\n}\n\n/// Create a new detached tmux session running the given agent command.\npub async fn create_session(\n    project_id: &str,\n    name: &str,\n    agent: &AgentType,\n    cwd: &str,\n) -> Result<String> {\n    let tmux_name = crate::session::tmux_session_name(project_id, name);\n\n    let status = Command::new(\"tmux\")\n        .args([\n            \"new-session\",\n            \"-d\",\n            \"-s\",\n            &tmux_name,\n            \"-c\",\n            cwd,\n            agent.command(),\n        ])\n        .status()\n        .await\n        .context(\"Failed to create tmux session\")?;\n\n    if !status.success() {\n        bail!(\"tmux new-session failed for '{tmux_name}'\");\n    }\n\n    // Keep pane alive after command exits so we can detect Exited status\n    let _ = Command::new(\"tmux\")\n        .args([\"set-option\", \"-t\", &tmux_name, \"remain-on-exit\", \"on\"])\n        .status()\n        .await;\n\n    // Store agent type as env var on the session\n    let _ = Command::new(\"tmux\")\n        .args([\n            \"set-environment\",\n            \"-t\",\n            &tmux_name,\n            \"HYDRA_AGENT_TYPE\",\n            &agent.to_string().to_lowercase(),\n        ])\n        .status()\n        .await;\n\n    Ok(tmux_name)\n}\n\n/// Capture the current pane content of a tmux session.\npub async fn capture_pane(tmux_name: &str) -> Result<String> {\n    let output = Command::new(\"tmux\")\n        .args([\"capture-pane\", \"-t\", tmux_name, \"-p\"])\n        .output()\n        .await\n        .context(\"Failed to capture tmux pane\")?;\n\n    if !output.status.success() {\n        return Ok(String::from(\"[session not available]\"));\n    }\n\n    Ok(String::from_utf8_lossy(&output.stdout).to_string())\n}\n\n/// Capture the full scrollback buffer of a tmux session.\npub async fn capture_pane_scrollback(tmux_name: &str) -> Result<String> {\n    let output = Command::new(\"tmux\")\n        .args([\"capture-pane\", \"-t\", tmux_name, \"-p\", \"-S\", \"-\"])\n        .output()\n        .await\n        .context(\"Failed to capture tmux pane scrollback\")?;\n\n    if !output.status.success() {\n        return Ok(String::from(\"[session not available]\"));\n    }\n\n    Ok(String::from_utf8_lossy(&output.stdout).to_string())\n}\n\n/// Send a key to a tmux session via `tmux send-keys`.\npub async fn send_keys(tmux_name: &str, key: &str) -> Result<()> {\n    let status = Command::new(\"tmux\")\n        .args([\"send-keys\", \"-t\", tmux_name, key])\n        .status()\n        .await\n        .context(\"Failed to send keys to tmux session\")?;\n\n    if !status.success() {\n        bail!(\"tmux send-keys failed for '{tmux_name}'\");\n    }\n\n    Ok(())\n}\n\n/// Send a mouse event to a tmux session using SGR escape sequences.\n///\n/// `kind` is \"press\" or \"release\". Coordinates are 1-based for SGR encoding.\npub async fn send_mouse(\n    tmux_name: &str,\n    kind: &str,\n    button: u8,\n    x: u16,\n    y: u16,\n) -> Result<()> {\n    // SGR mouse encoding: press = \\x1b[<button;x;yM  release = \\x1b[<button;x;ym\n    let suffix = if kind == \"press\" { 'M' } else { 'm' };\n    let seq = format!(\"\\x1b[<{button};{x};{y}{suffix}\");\n    let status = Command::new(\"tmux\")\n        .args([\"send-keys\", \"-t\", tmux_name, \"-l\", &seq])\n        .status()\n        .await\n        .context(\"Failed to send mouse event to tmux session\")?;\n\n    if !status.success() {\n        bail!(\"tmux send-keys (mouse) failed for '{tmux_name}'\");\n    }\n\n    Ok(())\n}\n\n/// Map a crossterm KeyCode + KeyModifiers to a tmux key name.\npub fn keycode_to_tmux(\n    code: crossterm::event::KeyCode,\n    modifiers: crossterm::event::KeyModifiers,\n) -> Option<String> {\n    use crossterm::event::{KeyCode, KeyModifiers};\n\n    // Character keys: apply modifier prefix directly\n    if let KeyCode::Char(c) = code {\n        return Some(if modifiers.contains(KeyModifiers::CONTROL) {\n            format!(\"C-{c}\")\n        } else if modifiers.contains(KeyModifiers::ALT) {\n            format!(\"M-{c}\")\n        } else {\n            // SHIFT is already reflected in the char value (uppercase)\n            c.to_string()\n        });\n    }\n\n    // BackTab is Shift+Tab — already a distinct keycode, no modifier prefix needed\n    if code == KeyCode::BackTab {\n        return Some(\"BTab\".to_string());\n    }\n\n    // Special keys → tmux base names\n    let base = match code {\n        KeyCode::Enter => \"Enter\",\n        KeyCode::Backspace => \"BSpace\",\n        KeyCode::Tab => \"Tab\",\n        KeyCode::Up => \"Up\",\n        KeyCode::Down => \"Down\",\n        KeyCode::Left => \"Left\",\n        KeyCode::Right => \"Right\",\n        KeyCode::Home => \"Home\",\n        KeyCode::End => \"End\",\n        KeyCode::PageUp => \"PageUp\",\n        KeyCode::PageDown => \"PageDown\",\n        KeyCode::Delete => \"DC\",\n        KeyCode::Insert => \"IC\",\n        KeyCode::F(n) => return Some(apply_tmux_modifiers(&format!(\"F{n}\"), modifiers)),\n        _ => return None,\n    };\n\n    Some(apply_tmux_modifiers(base, modifiers))\n}\n\n/// Wrap a tmux key name with modifier prefixes (C-, M-, S-).\nfn apply_tmux_modifiers(base: &str, modifiers: crossterm::event::KeyModifiers) -> String {\n    use crossterm::event::KeyModifiers;\n\n    let mut key = base.to_string();\n    if modifiers.contains(KeyModifiers::SHIFT) {\n        key = format!(\"S-{key}\");\n    }\n    if modifiers.contains(KeyModifiers::ALT) {\n        key = format!(\"M-{key}\");\n    }\n    if modifiers.contains(KeyModifiers::CONTROL) {\n        key = format!(\"C-{key}\");\n    }\n    key\n}\n\n/// Kill a tmux session.\npub async fn kill_session(tmux_name: &str) -> Result<()> {\n    let status = Command::new(\"tmux\")\n        .args([\"kill-session\", \"-t\", tmux_name])\n        .status()\n        .await\n        .context(\"Failed to kill tmux session\")?;\n\n    if !status.success() {\n        bail!(\"tmux kill-session failed for '{tmux_name}'\");\n    }\n\n    Ok(())\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":39,"address":[],"length":0,"stats":{"Line":1}},{"line":46,"address":[],"length":0,"stats":{"Line":1}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":2}},{"line":157,"address":[],"length":0,"stats":{"Line":4}},{"line":158,"address":[],"length":0,"stats":{"Line":5}},{"line":160,"address":[],"length":0,"stats":{"Line":1}},{"line":162,"address":[],"length":0,"stats":{"Line":1}},{"line":163,"address":[],"length":0,"stats":{"Line":5}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":2}},{"line":170,"address":[],"length":0,"stats":{"Line":4}},{"line":171,"address":[],"length":0,"stats":{"Line":4}},{"line":173,"address":[],"length":0,"stats":{"Line":1}},{"line":176,"address":[],"length":0,"stats":{"Line":3}},{"line":178,"address":[],"length":0,"stats":{"Line":3}},{"line":179,"address":[],"length":0,"stats":{"Line":3}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}}],"covered":16,"coverable":119},{"path":["/","Users","cat","hydra","src","ui.rs"],"content":"use ratatui::{\n    layout::{Constraint, Direction, Layout, Rect},\n    style::{Color, Modifier, Style},\n    text::{Line, Span},\n    widgets::{Block, BorderType, Borders, Clear, List, ListItem, Paragraph},\n    Frame,\n};\n\nuse crate::app::{App, Mode};\nuse crate::session::{format_duration, AgentType, SessionStatus};\n\npub fn draw(frame: &mut Frame, app: &App) {\n    let chunks = Layout::default()\n        .direction(Direction::Vertical)\n        .constraints([Constraint::Min(1), Constraint::Length(1)])\n        .split(frame.area());\n\n    let main_area = chunks[0];\n    let help_area = chunks[1];\n\n    // Main layout: sidebar | preview\n    let panels = Layout::default()\n        .direction(Direction::Horizontal)\n        .constraints([Constraint::Percentage(30), Constraint::Percentage(70)])\n        .split(main_area);\n\n    app.sidebar_area.set(panels[0]);\n    app.preview_area.set(panels[1]);\n\n    draw_sidebar(frame, app, panels[0]);\n    draw_preview(frame, app, panels[1]);\n    draw_help_bar(frame, app, help_area);\n\n    // Draw modal overlays\n    match app.mode {\n        Mode::NewSessionAgent => draw_agent_select(frame, app),\n        Mode::ConfirmDelete => draw_confirm_delete(frame, app),\n        Mode::Browse | Mode::Attached => {}\n    }\n}\n\nfn status_color(status: &SessionStatus) -> Color {\n    match status {\n        SessionStatus::Idle => Color::Green,\n        SessionStatus::Running => Color::Red,\n        SessionStatus::Exited => Color::Yellow,\n    }\n}\n\nfn draw_sidebar(frame: &mut Frame, app: &App, area: Rect) {\n    let items: Vec<ListItem> = app\n        .sessions\n        .iter()\n        .enumerate()\n        .map(|(i, session)| {\n            let marker = if i == app.selected { \">> \" } else { \"   \" };\n            let name_style = if i == app.selected {\n                Style::default()\n                    .fg(Color::Yellow)\n                    .add_modifier(Modifier::BOLD)\n            } else {\n                Style::default().fg(Color::White)\n            };\n            let mut spans = vec![\n                Span::styled(marker, name_style),\n                Span::styled(\"● \", Style::default().fg(status_color(&session.status))),\n                Span::styled(format!(\"{} [{}]\", session.name, session.agent_type), name_style),\n            ];\n            if let Some(elapsed) = session.task_elapsed {\n                spans.push(Span::styled(\n                    format!(\" {}\", format_duration(elapsed)),\n                    Style::default().fg(Color::DarkGray),\n                ));\n            }\n            let mut lines = vec![Line::from(spans)];\n            if let Some(msg) = app.last_messages.get(&session.tmux_name) {\n                let max_chars = 50;\n                let display = if msg.chars().count() > max_chars {\n                    let truncated: String = msg.chars().take(max_chars).collect();\n                    format!(\"     {truncated}...\")\n                } else {\n                    format!(\"     {msg}\")\n                };\n                lines.push(Line::from(Span::styled(\n                    display,\n                    Style::default().fg(Color::DarkGray),\n                )));\n            }\n            ListItem::new(lines)\n        })\n        .collect();\n\n    let session_count = app.sessions.len();\n    let title = format!(\" Sessions ({session_count}) \");\n    let list = List::new(items).block(\n        Block::default()\n            .borders(Borders::ALL)\n            .title(title)\n            .border_style(Style::default().fg(Color::Cyan)),\n    );\n\n    frame.render_widget(list, area);\n}\n\nfn draw_preview(frame: &mut Frame, app: &App, area: Rect) {\n    let title = if let Some(session) = app.sessions.get(app.selected) {\n        format!(\" {} \", session.name)\n    } else {\n        \" Preview \".to_string()\n    };\n\n    let (border_style, border_type) = if app.mode == Mode::Attached {\n        (\n            Style::default()\n                .fg(Color::Green)\n                .add_modifier(Modifier::BOLD),\n            BorderType::Thick,\n        )\n    } else {\n        (Style::default().fg(Color::Cyan), BorderType::Plain)\n    };\n\n    let inner_height = area.height.saturating_sub(2) as u16;\n    let total_lines = app.preview.lines().count() as u16;\n    let max_scroll_offset = total_lines.saturating_sub(inner_height);\n    let capped_offset = app.preview_scroll_offset.min(max_scroll_offset);\n    let scroll_y = max_scroll_offset.saturating_sub(capped_offset);\n\n    let preview = Paragraph::new(app.preview.as_str())\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .border_type(border_type)\n                .title(title)\n                .border_style(border_style),\n        )\n        .scroll((scroll_y, 0));\n\n    frame.render_widget(preview, area);\n}\n\nfn draw_help_bar(frame: &mut Frame, app: &App, area: Rect) {\n    let help_text = match app.mode {\n        Mode::Browse => \"j/k: navigate  Enter: attach  n: new  d: delete  q: quit\",\n        Mode::Attached => \"Esc: detach  (keys forwarded to session)\",\n        Mode::NewSessionAgent => \"j/k: select agent  Enter: confirm  Esc: cancel\",\n        Mode::ConfirmDelete => \"y: confirm delete  Esc: cancel\",\n    };\n\n    let status = if let Some(msg) = &app.status_message {\n        format!(\" {msg} | {help_text}\")\n    } else {\n        format!(\" {help_text}\")\n    };\n\n    let bar = Paragraph::new(Line::from(Span::styled(\n        status,\n        Style::default()\n            .fg(Color::Black)\n            .bg(Color::Cyan)\n            .add_modifier(Modifier::BOLD),\n    )));\n\n    frame.render_widget(bar, area);\n}\n\nfn centered_rect(width: u16, height: u16, area: Rect) -> Rect {\n    let x = area.x + area.width.saturating_sub(width) / 2;\n    let y = area.y + area.height.saturating_sub(height) / 2;\n    Rect::new(x, y, width.min(area.width), height.min(area.height))\n}\n\nfn draw_agent_select(frame: &mut Frame, app: &App) {\n    let agents = AgentType::all();\n    let height = agents.len() as u16 + 2;\n    let area = centered_rect(30, height, frame.area());\n    frame.render_widget(Clear, area);\n\n    let items: Vec<ListItem> = agents\n        .iter()\n        .enumerate()\n        .map(|(i, agent)| {\n            let marker = if i == app.agent_selection {\n                \">> \"\n            } else {\n                \"   \"\n            };\n            let label = format!(\"{marker}{agent}\");\n            let style = if i == app.agent_selection {\n                Style::default()\n                    .fg(Color::Yellow)\n                    .add_modifier(Modifier::BOLD)\n            } else {\n                Style::default().fg(Color::White)\n            };\n            ListItem::new(Line::from(Span::styled(label, style)))\n        })\n        .collect();\n\n    let list = List::new(items).block(\n        Block::default()\n            .borders(Borders::ALL)\n            .title(\" Select Agent \")\n            .border_style(Style::default().fg(Color::Yellow)),\n    );\n    frame.render_widget(list, area);\n}\n\nfn draw_confirm_delete(frame: &mut Frame, app: &App) {\n    let area = centered_rect(40, 5, frame.area());\n    frame.render_widget(Clear, area);\n\n    let name = app\n        .sessions\n        .get(app.selected)\n        .map(|s| s.name.as_str())\n        .unwrap_or(\"?\");\n\n    let text = format!(\" Kill session '{name}'? (y/n)\");\n    let confirm = Paragraph::new(text).block(\n        Block::default()\n            .borders(Borders::ALL)\n            .title(\" Confirm Delete \")\n            .border_style(Style::default().fg(Color::Red)),\n    );\n    frame.render_widget(confirm, area);\n}\n\n#[cfg(test)]\nmod tests {\n    use ratatui::{backend::TestBackend, Terminal};\n\n    use crate::app::{App, Mode};\n    use crate::session::{AgentType, Session, SessionStatus};\n    use crate::tmux::SessionManager;\n\n    struct NoopSessionManager;\n\n    #[async_trait::async_trait]\n    impl SessionManager for NoopSessionManager {\n        async fn list_sessions(&self, _: &str) -> anyhow::Result<Vec<Session>> {\n            Ok(vec![])\n        }\n        async fn create_session(\n            &self,\n            _: &str,\n            _: &str,\n            _: &AgentType,\n            _: &str,\n        ) -> anyhow::Result<String> {\n            Ok(String::new())\n        }\n        async fn capture_pane(&self, _: &str) -> anyhow::Result<String> {\n            Ok(String::new())\n        }\n        async fn kill_session(&self, _: &str) -> anyhow::Result<()> {\n            Ok(())\n        }\n        async fn send_keys(&self, _: &str, _: &str) -> anyhow::Result<()> {\n            Ok(())\n        }\n        async fn send_mouse(&self, _: &str, _: &str, _: u8, _: u16, _: u16) -> anyhow::Result<()> {\n            Ok(())\n        }\n        async fn capture_pane_scrollback(&self, _: &str) -> anyhow::Result<String> {\n            Ok(String::new())\n        }\n    }\n\n    fn make_app() -> App {\n        App::new_with_manager(\n            \"testproj\".to_string(),\n            \"/tmp/test\".to_string(),\n            Box::new(NoopSessionManager),\n        )\n    }\n\n    fn make_session(name: &str, agent: AgentType) -> Session {\n        make_session_with_status(name, agent, SessionStatus::Idle)\n    }\n\n    fn make_session_with_status(name: &str, agent: AgentType, status: SessionStatus) -> Session {\n        Session {\n            name: name.to_string(),\n            tmux_name: format!(\"hydra-testproj-{name}\"),\n            agent_type: agent,\n            status,\n            task_elapsed: None,\n            _alive: true,\n        }\n    }\n\n    fn buffer_to_string(terminal: &Terminal<TestBackend>) -> String {\n        let buf = terminal.backend().buffer();\n        let mut output = String::new();\n        for y in 0..buf.area.height {\n            for x in 0..buf.area.width {\n                let cell = &buf[(x, y)];\n                output.push_str(cell.symbol());\n            }\n            let trimmed = output.trim_end();\n            output = trimmed.to_string();\n            output.push('\\n');\n        }\n        output\n    }\n\n    #[test]\n    fn browse_mode_with_sessions() {\n        let backend = TestBackend::new(80, 24);\n        let mut terminal = Terminal::new(backend).unwrap();\n\n        let mut app = make_app();\n        app.sessions = vec![\n            make_session(\"worker-1\", AgentType::Claude),\n            make_session(\"worker-2\", AgentType::Codex),\n            make_session(\"research\", AgentType::Claude),\n        ];\n        app.selected = 0;\n        app.preview = \"some preview content\".to_string();\n\n        terminal.draw(|f| super::draw(f, &app)).unwrap();\n        let output = buffer_to_string(&terminal);\n\n        insta::assert_snapshot!(output);\n    }\n\n    #[test]\n    fn browse_mode_empty() {\n        let backend = TestBackend::new(80, 24);\n        let mut terminal = Terminal::new(backend).unwrap();\n\n        let mut app = make_app();\n        app.preview = \"No sessions. Press 'n' to create one.\".to_string();\n\n        terminal.draw(|f| super::draw(f, &app)).unwrap();\n        let output = buffer_to_string(&terminal);\n\n        insta::assert_snapshot!(output);\n    }\n\n    #[test]\n    fn new_session_agent_modal() {\n        let backend = TestBackend::new(80, 24);\n        let mut terminal = Terminal::new(backend).unwrap();\n\n        let mut app = make_app();\n        app.mode = Mode::NewSessionAgent;\n        app.agent_selection = 0;\n\n        terminal.draw(|f| super::draw(f, &app)).unwrap();\n        let output = buffer_to_string(&terminal);\n\n        insta::assert_snapshot!(output);\n    }\n\n    #[test]\n    fn confirm_delete_modal() {\n        let backend = TestBackend::new(80, 24);\n        let mut terminal = Terminal::new(backend).unwrap();\n\n        let mut app = make_app();\n        app.sessions = vec![\n            make_session(\"doomed-session\", AgentType::Claude),\n        ];\n        app.selected = 0;\n        app.mode = Mode::ConfirmDelete;\n\n        terminal.draw(|f| super::draw(f, &app)).unwrap();\n        let output = buffer_to_string(&terminal);\n\n        insta::assert_snapshot!(output);\n    }\n\n    #[test]\n    fn attached_mode() {\n        let backend = TestBackend::new(80, 24);\n        let mut terminal = Terminal::new(backend).unwrap();\n\n        let mut app = make_app();\n        app.sessions = vec![\n            make_session(\"active-session\", AgentType::Claude),\n        ];\n        app.selected = 0;\n        app.mode = Mode::Attached;\n        app.preview = \"$ claude\\nHello, how can I help?\".to_string();\n\n        terminal.draw(|f| super::draw(f, &app)).unwrap();\n        let output = buffer_to_string(&terminal);\n\n        insta::assert_snapshot!(output);\n    }\n\n    #[test]\n    fn status_message_displayed() {\n        let backend = TestBackend::new(80, 24);\n        let mut terminal = Terminal::new(backend).unwrap();\n\n        let mut app = make_app();\n        app.status_message = Some(\"Created session 'worker-1' with Claude\".to_string());\n        app.preview = \"No sessions. Press 'n' to create one.\".to_string();\n\n        terminal.draw(|f| super::draw(f, &app)).unwrap();\n        let output = buffer_to_string(&terminal);\n\n        insta::assert_snapshot!(output);\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":6}},{"line":13,"address":[],"length":0,"stats":{"Line":18}},{"line":14,"address":[],"length":0,"stats":{"Line":18}},{"line":15,"address":[],"length":0,"stats":{"Line":12}},{"line":16,"address":[],"length":0,"stats":{"Line":18}},{"line":18,"address":[],"length":0,"stats":{"Line":12}},{"line":19,"address":[],"length":0,"stats":{"Line":12}},{"line":22,"address":[],"length":0,"stats":{"Line":18}},{"line":23,"address":[],"length":0,"stats":{"Line":18}},{"line":24,"address":[],"length":0,"stats":{"Line":12}},{"line":25,"address":[],"length":0,"stats":{"Line":12}},{"line":27,"address":[],"length":0,"stats":{"Line":18}},{"line":28,"address":[],"length":0,"stats":{"Line":18}},{"line":30,"address":[],"length":0,"stats":{"Line":24}},{"line":31,"address":[],"length":0,"stats":{"Line":24}},{"line":32,"address":[],"length":0,"stats":{"Line":24}},{"line":35,"address":[],"length":0,"stats":{"Line":6}},{"line":36,"address":[],"length":0,"stats":{"Line":3}},{"line":37,"address":[],"length":0,"stats":{"Line":3}},{"line":38,"address":[],"length":0,"stats":{"Line":4}},{"line":42,"address":[],"length":0,"stats":{"Line":5}},{"line":43,"address":[],"length":0,"stats":{"Line":5}},{"line":44,"address":[],"length":0,"stats":{"Line":5}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":6}},{"line":51,"address":[],"length":0,"stats":{"Line":18}},{"line":52,"address":[],"length":0,"stats":{"Line":6}},{"line":55,"address":[],"length":0,"stats":{"Line":11}},{"line":56,"address":[],"length":0,"stats":{"Line":15}},{"line":57,"address":[],"length":0,"stats":{"Line":10}},{"line":58,"address":[],"length":0,"stats":{"Line":3}},{"line":59,"address":[],"length":0,"stats":{"Line":6}},{"line":60,"address":[],"length":0,"stats":{"Line":3}},{"line":62,"address":[],"length":0,"stats":{"Line":6}},{"line":64,"address":[],"length":0,"stats":{"Line":10}},{"line":65,"address":[],"length":0,"stats":{"Line":15}},{"line":66,"address":[],"length":0,"stats":{"Line":25}},{"line":67,"address":[],"length":0,"stats":{"Line":15}},{"line":69,"address":[],"length":0,"stats":{"Line":5}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":20}},{"line":76,"address":[],"length":0,"stats":{"Line":10}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":10}},{"line":93,"address":[],"length":0,"stats":{"Line":18}},{"line":94,"address":[],"length":0,"stats":{"Line":12}},{"line":95,"address":[],"length":0,"stats":{"Line":24}},{"line":96,"address":[],"length":0,"stats":{"Line":6}},{"line":97,"address":[],"length":0,"stats":{"Line":6}},{"line":98,"address":[],"length":0,"stats":{"Line":12}},{"line":99,"address":[],"length":0,"stats":{"Line":24}},{"line":102,"address":[],"length":0,"stats":{"Line":24}},{"line":105,"address":[],"length":0,"stats":{"Line":6}},{"line":106,"address":[],"length":0,"stats":{"Line":21}},{"line":107,"address":[],"length":0,"stats":{"Line":3}},{"line":109,"address":[],"length":0,"stats":{"Line":6}},{"line":112,"address":[],"length":0,"stats":{"Line":18}},{"line":114,"address":[],"length":0,"stats":{"Line":2}},{"line":115,"address":[],"length":0,"stats":{"Line":3}},{"line":116,"address":[],"length":0,"stats":{"Line":1}},{"line":117,"address":[],"length":0,"stats":{"Line":1}},{"line":120,"address":[],"length":0,"stats":{"Line":15}},{"line":123,"address":[],"length":0,"stats":{"Line":18}},{"line":124,"address":[],"length":0,"stats":{"Line":12}},{"line":125,"address":[],"length":0,"stats":{"Line":24}},{"line":126,"address":[],"length":0,"stats":{"Line":24}},{"line":127,"address":[],"length":0,"stats":{"Line":24}},{"line":129,"address":[],"length":0,"stats":{"Line":24}},{"line":131,"address":[],"length":0,"stats":{"Line":6}},{"line":132,"address":[],"length":0,"stats":{"Line":6}},{"line":133,"address":[],"length":0,"stats":{"Line":12}},{"line":134,"address":[],"length":0,"stats":{"Line":12}},{"line":135,"address":[],"length":0,"stats":{"Line":12}},{"line":137,"address":[],"length":0,"stats":{"Line":12}},{"line":139,"address":[],"length":0,"stats":{"Line":24}},{"line":142,"address":[],"length":0,"stats":{"Line":6}},{"line":143,"address":[],"length":0,"stats":{"Line":12}},{"line":144,"address":[],"length":0,"stats":{"Line":3}},{"line":145,"address":[],"length":0,"stats":{"Line":1}},{"line":146,"address":[],"length":0,"stats":{"Line":1}},{"line":147,"address":[],"length":0,"stats":{"Line":1}},{"line":150,"address":[],"length":0,"stats":{"Line":13}},{"line":151,"address":[],"length":0,"stats":{"Line":1}},{"line":153,"address":[],"length":0,"stats":{"Line":5}},{"line":156,"address":[],"length":0,"stats":{"Line":24}},{"line":157,"address":[],"length":0,"stats":{"Line":6}},{"line":158,"address":[],"length":0,"stats":{"Line":6}},{"line":159,"address":[],"length":0,"stats":{"Line":12}},{"line":160,"address":[],"length":0,"stats":{"Line":12}},{"line":161,"address":[],"length":0,"stats":{"Line":6}},{"line":164,"address":[],"length":0,"stats":{"Line":24}},{"line":167,"address":[],"length":0,"stats":{"Line":2}},{"line":168,"address":[],"length":0,"stats":{"Line":8}},{"line":169,"address":[],"length":0,"stats":{"Line":8}},{"line":170,"address":[],"length":0,"stats":{"Line":18}},{"line":173,"address":[],"length":0,"stats":{"Line":1}},{"line":174,"address":[],"length":0,"stats":{"Line":2}},{"line":175,"address":[],"length":0,"stats":{"Line":2}},{"line":176,"address":[],"length":0,"stats":{"Line":5}},{"line":177,"address":[],"length":0,"stats":{"Line":4}},{"line":179,"address":[],"length":0,"stats":{"Line":3}},{"line":182,"address":[],"length":0,"stats":{"Line":3}},{"line":183,"address":[],"length":0,"stats":{"Line":4}},{"line":184,"address":[],"length":0,"stats":{"Line":1}},{"line":186,"address":[],"length":0,"stats":{"Line":1}},{"line":188,"address":[],"length":0,"stats":{"Line":4}},{"line":189,"address":[],"length":0,"stats":{"Line":4}},{"line":190,"address":[],"length":0,"stats":{"Line":1}},{"line":191,"address":[],"length":0,"stats":{"Line":2}},{"line":192,"address":[],"length":0,"stats":{"Line":1}},{"line":194,"address":[],"length":0,"stats":{"Line":3}},{"line":196,"address":[],"length":0,"stats":{"Line":10}},{"line":200,"address":[],"length":0,"stats":{"Line":4}},{"line":201,"address":[],"length":0,"stats":{"Line":1}},{"line":202,"address":[],"length":0,"stats":{"Line":1}},{"line":203,"address":[],"length":0,"stats":{"Line":1}},{"line":204,"address":[],"length":0,"stats":{"Line":4}},{"line":206,"address":[],"length":0,"stats":{"Line":4}},{"line":209,"address":[],"length":0,"stats":{"Line":1}},{"line":210,"address":[],"length":0,"stats":{"Line":4}},{"line":211,"address":[],"length":0,"stats":{"Line":4}},{"line":213,"address":[],"length":0,"stats":{"Line":3}},{"line":214,"address":[],"length":0,"stats":{"Line":2}},{"line":215,"address":[],"length":0,"stats":{"Line":1}},{"line":216,"address":[],"length":0,"stats":{"Line":3}},{"line":219,"address":[],"length":0,"stats":{"Line":2}},{"line":220,"address":[],"length":0,"stats":{"Line":4}},{"line":221,"address":[],"length":0,"stats":{"Line":1}},{"line":222,"address":[],"length":0,"stats":{"Line":1}},{"line":223,"address":[],"length":0,"stats":{"Line":1}},{"line":224,"address":[],"length":0,"stats":{"Line":4}},{"line":226,"address":[],"length":0,"stats":{"Line":4}}],"covered":129,"coverable":142}],"coverage":45.83333333333333,"covered":308,"coverable":672}